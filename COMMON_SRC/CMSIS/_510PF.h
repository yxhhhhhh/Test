
/****************************************************************************************************//**
 * @file     _510PF.h
 *
 * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
 *           _510PF from SONiX Technology Co., Ltd..
 *
 * @version  V1.0
 * @date     22. December 2017
 *
 * @note     Generated with SVDConv V2.87l 
 *           from CMSIS SVD File '_510PF.svd' Version 1.0,
 *
 * @par      The information contained herein is the exclusive property of SONiX and shall not be
 *           distributed, or disclosed in whole or in part without prior permission of SONiX.
 *           SONiX reserves the right to make changes without further notice to the product to improve
 *           reliability, function or design. SONiX does not assume any liability arising out of the
 *           application or use of any product or circuits described herein. All application information
 *           is advisor and does not from part of the specification.
 *
 *******************************************************************************************************/



/** @addtogroup SONiX Technology Co., Ltd.
  * @{
  */

/** @addtogroup _510PF
  * @{
  */

#ifndef _510PF_H
#define _510PF_H

#ifdef __cplusplus
extern "C" {
#endif


/* -------------------------  Interrupt Number Definition  ------------------------ */

typedef enum {
/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
/* ----------------------  _510PF Specific Interrupt Numbers  --------------------- */
  TIMER1_INT_IRQn               =   0,              /*!<   0  TIMER1_INT                                                       */
  TIMER2_INT_IRQn               =   1,              /*!<   1  TIMER2_INT                                                       */
  TIMER3_INT_IRQn               =   2,              /*!<   2  TIMER3_INT                                                       */
  USB2DEV_INT_IRQn              =   3,              /*!<   3  USB2DEV_INT                                                      */
  USB2HOST2_INT_IRQn            =   4,              /*!<   4  USB2HOST2_INT                                                    */
  USB2HOST1_INT_IRQn            =   5,              /*!<   5  USB2HOST1_INT                                                    */
  LCD_INT_IRQn                  =   6,              /*!<   6  LCD_INT                                                          */
  MIPI_INT_IRQn                 =   7,              /*!<   7  MIPI_INT                                                         */
  SEN_HSYNC_INT_IRQn            =   8,              /*!<   8  SEN_HSYNC_INT                                                    */
  ISP_WIN_END_INT_IRQn          =   9,              /*!<   9  ISP_WIN_END_INT                                                  */
  SEN_VSYNC_INT_IRQn            =  10,              /*!<  10  SEN_VSYNC_INT                                                    */
  ISP_DIS_INT_IRQn              =  11,              /*!<  11  ISP_DIS_INT                                                      */
  IMG_TX_INT_IRQn               =  12,              /*!<  12  IMG_TX_INT                                                       */
  H264_ENCODE_INT_IRQn          =  13,              /*!<  13  H264_ENCODE_INT                                                  */
  JPEG_INT_IRQn                 =  14,              /*!<  14  JPEG_INT                                                         */
  RF1_INT_IRQn                  =  15,              /*!<  15  RF1_INT                                                          */
  RF2_INT_IRQn                  =  16,              /*!<  16  RF2_INT                                                          */
  MAC_INT_IRQn                  =  17,              /*!<  17  MAC_INT                                                          */
  UART1_INT_IRQn                =  18,              /*!<  18  UART1_INT                                                        */
  UART2_INT_IRQn                =  19,              /*!<  19  UART2_INT                                                        */
  SD1_DET_INT_IRQn              =  20,              /*!<  20  SD1_DET_INT                                                      */
  SD1_INT_IRQn                  =  21,              /*!<  21  SD1_INT                                                          */
  SD2_DET_INT_IRQn              =  22,              /*!<  22  SD2_DET_INT                                                      */
  SD2_INT_IRQn                  =  23,              /*!<  23  SD2_INT                                                          */
  SD3_INT_IRQn                  =  24,              /*!<  24  SD3_INT                                                          */
  SF_INT_IRQn                   =  25,              /*!<  25  SF_INT                                                           */
  CRC_OK_INT_IRQn               =  26,              /*!<  26  CRC_OK_INT                                                       */
  CIPHER_OK_INT_IRQn            =  27,              /*!<  27  CIPHER_OK_INT                                                    */
  GPIO_INT_IRQn                 =  28,              /*!<  28  GPIO_INT                                                         */
  DMA_INT_IRQn                  =  29,              /*!<  29  DMA_INT                                                          */
  ADO_R_INT_IRQn                =  30,              /*!<  30  ADO_R_INT                                                        */
  ADO_W_INT_IRQn                =  31,              /*!<  31  ADO_W_INT                                                        */
  AHB0_AHBC_INT_IRQn            =  32,              /*!<  32  AHB0_AHBC_INT                                                    */
  AHBC1_INT_IRQn                =  33,              /*!<  33  AHBC1_INT                                                        */
  AHBC2_INT_IRQn                =  34,              /*!<  34  AHBC2_INT                                                        */
  AHBC3_INT_IRQn                =  35,              /*!<  35  AHBC3_INT                                                        */
  I2C1_INT_IRQn                 =  36,              /*!<  36  I2C1_INT                                                         */
  I2C2_INT_IRQn                 =  37,              /*!<  37  I2C2_INT                                                         */
  I2C3_INT_IRQn                 =  38,              /*!<  38  I2C3_INT                                                         */
  I2C4_INT_IRQn                 =  39,              /*!<  39  I2C4_INT                                                         */
  I2C5_INT_IRQn                 =  40,              /*!<  40  I2C5_INT                                                         */
  SSP_INT_IRQn                  =  41,              /*!<  41  SSP_INT                                                          */
  APB_INT_IRQn                  =  42,              /*!<  42  APB_INT                                                          */
  DDR_CTRL_INT_IRQn             =  43,              /*!<  43  DDR_CTRL_INT                                                     */
  WDOG_INT_IRQn                 =  44,              /*!<  44  WDOG_INT                                                         */
  RTC_ALARM_INT_IRQn            =  45,              /*!<  45  RTC_ALARM_INT                                                    */
  RTC_WAKEUP_INT_IRQn           =  46,              /*!<  46  RTC_WAKEUP_INT                                                   */
  CMDQUE_INT_IRQn               =  47,              /*!<  47  CMDQUE_INT                                                       */
  KEY_INT_IRQn                  =  48,              /*!<  48  KEY_INT                                                          */
  RTC_GPIO0_INT_IRQn            =  49,              /*!<  49  RTC_GPIO0_INT                                                    */
  RTC_GPIO1_INT_IRQn            =  50,              /*!<  50  RTC_GPIO1_INT                                                    */
  REG_RW_ERR_INT_IRQn           =  51,              /*!<  51  REG_RW_ERR_INT                                                   */
  ISP_MD_INT_IRQn               =  52               /*!<  52  ISP_MD_INT                                                       */
} IRQn_Type;


/** @addtogroup Configuration_of_CMSIS
  * @{
  */


/* ================================================================================ */
/* ================      Processor and Core Peripheral Section     ================ */
/* ================================================================================ */

/* ----------------Configuration of the Cortex-M0 Processor and Core Peripherals---------------- */
#define __CM0_REV                 0x0000            /*!< Cortex-M0 Core Revision                                               */
#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
#define __NVIC_PRIO_BITS               1            /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
/** @} */ /* End of group Configuration_of_CMSIS */

#include "system__510PF.h"                          /*!< _510PF System                                                         */


/* ================================================================================ */
/* ================       Device Specific Peripheral Section       ================ */
/* ================================================================================ */


/** @addtogroup Device_Peripheral_Registers
  * @{
  */


/* -------------------  Start of section using anonymous unions  ------------------ */
#if defined(__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined(__ICCARM__)
  #pragma language=extended
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
/* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning 586
#else
  #warning Not supported compiler type
#endif



/* ================================================================================ */
/* ================                       GLB                      ================ */
/* ================================================================================ */


/**
  * @brief Global setting register (GLB)
  */

typedef struct {                                    /*!< GLB Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< Power down ASIC.(Rising edge trigger)
                                                         1. Chip reset.
                                                         2. Power-on reset.
                                                         3. USB wake up.
                                                         4. KEY = 1.
                                                         5. GPIOn is in input mode, GPIOn_WU_EN=1 and GPIOn is at trigger
                                                         level.
                                                         Note: When PWR_DN_MODE=0, you must clear PWR_DOWN before the
                                                          next power down.                                                     */
    
    struct {
      __IO uint32_t  PWR_DOWN   :  1;               /*!< Power down ASIC                                                       */
      __IO uint32_t  PWR_DN_MODE:  1;               /*!< Power down mode selection                                             */
           uint32_t             :  2;
      __I  uint32_t  TESTER     :  1;               /*!< Tester Mode                                                           */
      __IO uint32_t  TEST       :  1;               /*!< Test mode for testing Internal circuit                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
      __IO uint32_t  JPG_RATE   :  4;               /*!< JPEG Code clock frequency control. (Range:2 -15)
                                                         F(JPG_CLK) = DDR_PLL/2 pow SYS_RATE/JPG_RATE.                         */
      __IO uint32_t  ISP_RATE   :  4;               /*!< ISP Code clock frequency control. (Range:2 -15)
                                                         F(ISP_CLK) = DDR_PLL/2 pow SYS_RATE/ISP_RATE.                         */
      __IO uint32_t  LCD_RATE   :  4;               /*!< LCD control clock frequency control. (Range:2 -15)
                                                         F(LCD_CLK) = H264_PLL/2 pow SYS_RATE/LCD_RATE.
                                                         Note: DDR_PLL is 200MHz in FPGA.                                      */
      __IO uint32_t  LCD_PIX_RATE:  4;              /*!< LCD pix clock frequency control. (Range:2 -15)
                                                         F(TG_MST_CK) = LCD_PLL/LCD_PIX_RATE.                                  */
      __IO uint32_t  AHB1_RATE  :  4;               /*!< AHB bus 1 clock frequency control. (Range:2 -15)
                                                         F(AHB1_CLK) = USB_HOST_PLL/2 pow SYS_RATE/ISP_RATE.                   */
      __IO uint32_t  AHB2_RATE  :  4;               /*!< AHB bus 2 clock frequency control. (Range:2 -15)
                                                         F(AHB2_CLK) = USB_HOST_PLL/2 pow SYS_RATE/ISP_RATE.                   */
      __IO uint32_t  AHB3_RATE  :  4;               /*!< AHB bus 3 clock frequency control. (Range:2 -15)
                                                         F(LCD_CLK) = DDR_PLL/2 pow SYS_RATE/LCD_RATE.Note: DDR_PLL is
                                                         200MHz in FPGA.                                                       */
      __IO uint32_t  APBC_RATE  :  4;               /*!< APBC clock frequency control. (Range:2 -15)
                                                         F(APBC_CLK) = USB_HOST_PLL/2 pow SYS_RATE//APB_RATE.                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< REG_0x0008                                                            */
    
    struct {
      __IO uint32_t  SYS_RATE   :  2;               /*!< System clock source (SYS_CLK) frequency
                                                         0: 480MHz
                                                         1: 240MHz
                                                         2: 120MHz
                                                         3: 60MHz                                                              */
      __IO uint32_t  MAC_PHY_CLK_OE:  1;            /*!< Enable output clock to MAC PHY.                                       */
      __IO uint32_t  MAC_CK_SEL :  1;               /*!< MAC Clock Select.                                                     */
      __IO uint32_t  DDR_RATE   :  4;               /*!< DDR clock (DDR_CLK) frequency selection. (Range: 2-15)
                                                         F(DDR_CLK) = DDR_PLL/2 pow SYS_RATE/DDR_RATE.
                                                         Note: DDR_PLL is 200MHz in FPGA and DDR_CLK is fixed to 25MHz.        */
      __IO uint32_t  CPU_RATE   :  4;               /*!< CPU clock frequency control. (Range: 2-15)
                                                         IF CPU_PLL_SEL = 0
                                                          F(CPU_CLK) = DDR_PLL/2 pow SYS_RATE/CPU_RATE.
                                                         Else IF CPU_PLL_SEL = 1
                                                          F(CPU_CLK) = USB_HOST_PLL/2 pow SYS_RATE/ISP_RATE.
                                                         Note: CPU_CLK = 100MHz/CPU_RATE in FPGA                               */
      __IO uint32_t  H264_RATE  :  4;               /*!< H264 clock frequency control. (Range: 2-15)
                                                         F(H264_CLK)=H264_PLL/2 pow SYS_RATE/H264_RATE..                       */
      __IO uint32_t  IMG_RATE   :  4;               /*!< IMG controller clock frequency control. (Range: 2-15)
                                                         F(IMG_CLK)=H264_PLL/2 pow SYS_RATE/IMG_RATE.                          */
      __IO uint32_t  EROM_CK_DIV:  2;               /*!< External Flash ROM clock.                                             */
      __IO uint32_t  UART_RATE  :  1;               /*!< 0:UART clock is 10MHz.
                                                         1:UART clock is 96MHz.                                                */
           uint32_t             :  1;
      __IO uint32_t  SAR_RATE   :  8;               /*!< SAR ADC clock frequency control
                                                         SAR clock = 6MHz/(2*SAR_RATE)
                                                         Note: this value must be in 1 ~255                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG_0x000C                                                            */
    
    struct {
      __IO uint32_t  CPU_PLL_SEL:  1;               /*!< Clock source selection.
                                                         0: DDR PLL
                                                         1: USB HOST PLL                                                       */
           uint32_t             :  2;
      __IO uint32_t  ISP_AXI_RATE:  4;              /*!< ISP AXI bus clock frequency control. (Range: 2-511)                   */
      __IO uint32_t  LOAD_DQS_DLY:  1;              /*!< DQS Re-Load                                                           */
      __IO uint32_t  DDR_DQS0_IDLY:  7;             /*!< DDR DQS0 strob delay.
                                                         Note: Only active if FPGA                                             */
           uint32_t             :  1;
      __IO uint32_t  DDR_DQS1_IDLY:  7;             /*!< DDR DQS1 strob delay.
                                                         Note: Only active if FPGA                                             */
           uint32_t             :  1;
      __IO uint32_t  DDR_DQS0_ODLY:  4;             /*!< DDR DQS0 output delay.
                                                         Note: Only active if FPGA                                             */
      __IO uint32_t  DDR_DQS1_ODLY:  4;             /*!< DDR DQS1 output delay.
                                                         Note: Only active if FPGA                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG_0x0010                                                            */
    
    struct {
      __IO uint32_t  PWR_SW_ENN :  1;               /*!< Power down domain switch enable signal.                               */
      __IO uint32_t  PWR_ISO_ENN:  1;               /*!< Power down domain isolation control signal.                           */
      __IO uint32_t  PWR_DDR_ISO_ENN:  1;           /*!< Power down domain isolation control signal for DDR PHY.               */
           uint32_t             : 13;
      __IO uint32_t  REG_RESP_TIME:  8;             /*!< Sonix bus register time out counter.                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_0x0014                                                            */
    
    struct {
      __IO uint32_t  REMAP      :  1;               /*!< Activate remap function, switch base addresses mapping                */
      __IO uint32_t  MEM_MODE   :  1;               /*!< System memory mapping mode                                            */
           uint32_t             :  6;
      __IO uint32_t  AHB0_INCR_LEN:  8;             /*!< When a master issues an INCR command, the arbiter will grant
                                                         the
                                                         master to transfer a total amount of (INCR_LENGTH+1) bursts.(range
                                                          1~255)                                                               */
      __IO uint32_t  AHB0_INTR_EN:  1;              /*!< Enable or disable the interrupt when receiving a non-existing
                                                         address.                                                              */
           uint32_t             :  3;
      __IO uint32_t  AHB0_AHBC_RESP:  2;            /*!< Response status, when receiving a non-existing address, the
                                                         decoder responds to the master.                                       */
           uint32_t             :  2;
      __IO uint32_t  AHB0_AHBC_INTR_FLAG:  1;       /*!< Interrupt status, set when receiving a non-existing address.
                                                         Note:Writing a '0' to this bit clears the interrupt.                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG_0x0018                                                            */
    
    struct {
      __IO uint32_t  PLEVEL     : 16;               /*!< Bit n represents the priority level of master n(n=1~15)
                                                         The arbitration is 2-level round-robin.
                                                         Note: bit1: ARM926-I, bit2:ARM926-D.                                  */
      __IO uint32_t  IDLE_COUNT :  6;               /*!< The arbiter will re-arbitrate if a granted master dosen't issue
                                                         a
                                                         NON-SEN command within the idle count period.                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG_0x001C                                                            */
    
    struct {
      __IO uint32_t  REG_CK_MODE:  1;               /*!< Register access mode                                                  */
      __IO uint32_t  ADO_FUNC_DIS:  1;              /*!< Disable Audio function (gating clock)                                 */
      __IO uint32_t  ENC_FUNC_DIS:  1;              /*!< Disable Cipher function (gating clock)                                */
      __IO uint32_t  CRC_FUNC_DIS:  1;              /*!< Disable CRC function (gating clock)                                   */
      __IO uint32_t  TMR_FUNC_DIS:  1;              /*!< Disable TIMER function (gating clock)                                 */
      __IO uint32_t  FAT_FUNC_DIS:  1;              /*!< Disable FAT function (gating clock)                                   */
      __IO uint32_t  CMDQUE_FUNC_DIS:  1;           /*!< Disable Command queue function (gating clock)                         */
      __IO uint32_t  OTH_FUNC_DIS:  1;              /*!< Disable TX/SPI function (gating clock)                                */
      __IO uint32_t  MT1_FUNC_DIS:  1;              /*!< Disable Motor 1 function (gating clock)                               */
      __IO uint32_t  MT2_FUNC_DIS:  1;              /*!< Disable Motor 2 function (gating clock)                               */
           uint32_t             :  1;
      __IO uint32_t  UH1_FUNC_DIS:  1;              /*!< Disable USB Host 1 function (gating clock)                            */
      __IO uint32_t  UH2_FUNC_DIS:  1;              /*!< Disable USB Host 2 function (gating clock)                            */
      __IO uint32_t  UD_FUNC_DIS:  1;               /*!< Disable USB Device function (gating clock)                            */
           uint32_t             :  9;
      __IO uint32_t  UART1_FUNC_DIS:  1;            /*!< Disable UART 1 function (gating clock)                                */
      __IO uint32_t  UART2_FUNC_DIS:  1;            /*!< Disable UART 2 function (gating clock)                                */
      __IO uint32_t  SF_FUNC_DIS:  1;               /*!< Disable Serial Flash function (gating clock)                          */
      __IO uint32_t  SDIO1_FUNC_DIS:  1;            /*!< Disable SDIO 1 function (gating clock)                                */
      __IO uint32_t  SDIO2_FUNC_DIS:  1;            /*!< Disable SDIO 2 function (gating clock)                                */
      __IO uint32_t  SDIO3_FUNC_DIS:  1;            /*!< Disable SDIO 3 function (gating clock)                                */
      __IO uint32_t  IMG_FUNC_DIS:  1;              /*!< Disable IMG_TOP function (gating clock)                               */
      __IO uint32_t  SAR_FUNC_DIS:  1;              /*!< Disable SAR ADC function (gating clock)                               */
      __IO uint32_t  SSP_FUNC_DIS:  1;              /*!< Disable SSP function (gating clock)                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG_0x0020                                                            */
    
    struct {
           uint32_t             :  9;
      __IO uint32_t  ISP_MD_FUNC_DIS:  1;           /*!< Disable ISP MD function. (gating clock)                               */
      __IO uint32_t  ISP_DIS_FUNC_DIS:  1;          /*!< Disable ISP DIS function. (gating clock)                              */
           uint32_t             :  2;
      __IO uint32_t  LCD_FUNC_DIS:  1;              /*!< Disable LCD function (gating clock)                                   */
      __IO uint32_t  TG_FUNC_DIS:  1;               /*!< Disable TG function (gating clock)                                    */
      __IO uint32_t  H264_FUNC_DIS:  1;             /*!< Disable H264 function (gating clock)                                  */
      __IO uint32_t  JPG_FUNC_DIS:  1;              /*!< Disable JPEG function (gating clock)                                  */
      __IO uint32_t  ISP_FUNC_DIS:  1;              /*!< Disable ISP function (gating clock)                                   */
      __IO uint32_t  MIPI_FUNC_DIS:  1;             /*!< Disable MIPI function (gating clock)                                  */
      __IO uint32_t  RF1_FUNC_DIS:  1;              /*!< Disable RF 1 function (gating clock)                                  */
      __IO uint32_t  RF2_FUNC_DIS:  1;              /*!< Disable RF 2 function (gating clock)                                  */
      __IO uint32_t  DDR_FUNC_DIS:  1;              /*!< Disable DDR function (gating clock)                                   */
      __IO uint32_t  PWM_FUNC_DIS:  1;              /*!< Disable PWM function (gating clock)                                   */
      __IO uint32_t  MAC_FUNC_DIS:  1;              /*!< Disable MAC function (gating clock)                                   */
      __IO uint32_t  ISP_YUV_PATH1_FUNC_DIS:  1;    /*!< Disable ISP_YUV_SCAL1, ISP_FIRF1, ISP_YEE1 andISP_OSD1                */
      __IO uint32_t  ISP_YUV_PATH2_FUNC_DIS:  1;    /*!< Disable ISP_YUV_SCAL2, ISP_FIRF2, ISP_YEE2 andISP_OSD2                */
      __IO uint32_t  ISP_YUV_PATH3_FUNC_DIS:  1;    /*!< Disable ISP_YUV_SCAL3 and ISP_FIRF3                                   */
    };
  };
  __I  uint32_t  RESERVED[2];
  
  union {
    __IO uint32_t  PIN_MUX1;                        /*!< PIN_MUX[29:0]PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO0     :  3;               /*!< PADIO0                                                                */
      __IO uint32_t  PADIO1     :  3;               /*!< PADIO1                                                                */
      __IO uint32_t  PADIO2     :  3;               /*!< PADIO2                                                                */
      __IO uint32_t  PADIO3     :  3;               /*!< PADIO3                                                                */
      __IO uint32_t  PADIO4     :  3;               /*!< PADIO4                                                                */
      __IO uint32_t  PADIO5     :  3;               /*!< PADIO5                                                                */
      __IO uint32_t  PADIO6     :  3;               /*!< PADIO6                                                                */
      __IO uint32_t  PADIO7     :  3;               /*!< PADIO7                                                                */
      __IO uint32_t  PADIO8     :  3;               /*!< PADIO8                                                                */
      __IO uint32_t  PADIO9     :  3;               /*!< PADIO9                                                                */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX2;                        /*!< PIN_MUX[59:30]PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO10    :  3;               /*!< PADIO10                                                               */
      __IO uint32_t  PADIO11    :  3;               /*!< PADIO11                                                               */
      __IO uint32_t  PADIO12    :  3;               /*!< PADIO12                                                               */
      __IO uint32_t  PADIO13    :  3;               /*!< PADIO13                                                               */
      __IO uint32_t  PADIO14    :  3;               /*!< PADIO14                                                               */
      __IO uint32_t  PADIO15    :  3;               /*!< PADIO15                                                               */
      __IO uint32_t  PADIO16    :  3;               /*!< PADIO16                                                               */
      __IO uint32_t  PADIO17    :  3;               /*!< PADIO17                                                               */
      __IO uint32_t  PADIO18    :  3;               /*!< PADIO18                                                               */
      __IO uint32_t  PADIO19    :  3;               /*!< PADIO19                                                               */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX3;                        /*!< PIN_MUX[89:60]PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO20    :  3;               /*!< PADIO20                                                               */
      __IO uint32_t  PADIO21    :  3;               /*!< PADIO21                                                               */
      __IO uint32_t  PADIO22    :  3;               /*!< PADIO22                                                               */
      __IO uint32_t  PADIO23    :  3;               /*!< PADIO23                                                               */
      __IO uint32_t  PADIO24    :  3;               /*!< PADIO24                                                               */
      __IO uint32_t  PADIO25    :  3;               /*!< PADIO25                                                               */
      __IO uint32_t  PADIO26    :  3;               /*!< PADIO26                                                               */
      __IO uint32_t  PADIO27    :  3;               /*!< PADIO27                                                               */
      __IO uint32_t  PADIO28    :  3;               /*!< PADIO28                                                               */
      __IO uint32_t  PADIO29    :  3;               /*!< PADIO29                                                               */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX4;                        /*!< PIN_MUX[119:90]PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO30    :  3;               /*!< PADIO30                                                               */
      __IO uint32_t  PADIO31    :  3;               /*!< PADIO31                                                               */
      __IO uint32_t  PADIO32    :  3;               /*!< PADIO32                                                               */
      __IO uint32_t  PADIO33    :  3;               /*!< PADIO33                                                               */
      __IO uint32_t  PADIO34    :  3;               /*!< PADIO34                                                               */
      __IO uint32_t  PADIO35    :  3;               /*!< PADIO35                                                               */
      __IO uint32_t  PADIO36    :  3;               /*!< PADIO36                                                               */
      __IO uint32_t  PADIO37    :  3;               /*!< PADIO37                                                               */
      __IO uint32_t  PADIO38    :  3;               /*!< PADIO38                                                               */
      __IO uint32_t  PADIO39    :  3;               /*!< PADIO39                                                               */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX5;                        /*!< PIN_MUX[149:120]PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO40    :  3;               /*!< PADIO40                                                               */
      __IO uint32_t  PADIO41    :  3;               /*!< PADIO41                                                               */
      __IO uint32_t  PADIO42    :  3;               /*!< PADIO42                                                               */
      __IO uint32_t  PADIO43    :  3;               /*!< PADIO43                                                               */
      __IO uint32_t  PADIO44    :  3;               /*!< PADIO44                                                               */
      __IO uint32_t  PADIO45    :  3;               /*!< PADIO45                                                               */
      __IO uint32_t  PADIO46    :  3;               /*!< PADIO46                                                               */
      __IO uint32_t  PADIO47    :  3;               /*!< PADIO47                                                               */
      __IO uint32_t  PADIO48    :  3;               /*!< PADIO48                                                               */
      __IO uint32_t  PADIO49    :  3;               /*!< PADIO49                                                               */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX6;                        /*!< PIN_MUX[179:150]PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO50    :  3;               /*!< PADIO50                                                               */
      __IO uint32_t  PADIO51    :  3;               /*!< PADIO51                                                               */
      __IO uint32_t  PADIO52    :  3;               /*!< PADIO52                                                               */
      __IO uint32_t  PADIO53    :  3;               /*!< PADIO53                                                               */
      __IO uint32_t  PADIO54    :  3;               /*!< PADIO54                                                               */
      __IO uint32_t  PADIO55    :  3;               /*!< PADIO55                                                               */
      __IO uint32_t  PADIO56    :  3;               /*!< PADIO56                                                               */
      __IO uint32_t  PADIO57    :  3;               /*!< PADIO57                                                               */
      __IO uint32_t  PADIO58    :  3;               /*!< PADIO58                                                               */
      __IO uint32_t  PADIO59    :  3;               /*!< PADIO59                                                               */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX7;                        /*!< PIN_MUX[209:180]
                                                         PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO60    :  3;               /*!< PADIO60                                                               */
      __IO uint32_t  PADIO61    :  3;               /*!< PADIO61                                                               */
      __IO uint32_t  PADIO62    :  3;               /*!< PADIO62                                                               */
      __IO uint32_t  PADIO63    :  3;               /*!< PADIO63                                                               */
      __IO uint32_t  PADIO64    :  3;               /*!< PADIO64                                                               */
      __IO uint32_t  PADIO65    :  3;               /*!< PADIO65                                                               */
      __IO uint32_t  PADIO66    :  3;               /*!< PADIO66                                                               */
      __IO uint32_t  PADIO67    :  3;               /*!< PADIO67                                                               */
      __IO uint32_t  PADIO68    :  3;               /*!< PADIO68                                                               */
      __IO uint32_t  PADIO69    :  3;               /*!< PADIO69                                                               */
    };
  };
  
  union {
    __IO uint32_t  PIN_MUX8;                        /*!< PIN_MUX[218:210]
                                                         PIN_MUX[2:0] the function select for PADIO[0].
                                                         Note: For each PADIO[N] the respective function select bits
                                                         is
                                                         PIN_MUX[N*3+2:N*3].                                                   */
    
    struct {
      __IO uint32_t  PADIO70    :  3;               /*!< PADIO70                                                               */
      __IO uint32_t  PADIO71    :  3;               /*!< PADIO71                                                               */
      __IO uint32_t  PADIO72    :  3;               /*!< PADIO72                                                               */
    };
  };
  
  union {
    __IO uint32_t  PADIO_PUN1;                      /*!< Pull-Up the PADIO[31:0]
                                                         Note: 0 = Pull UP the PADIO[7:0] & PADIO[31:18]
                                                          0 = Pull Down the PADIO[17:8]                                        */
    
    struct {
      __IO uint32_t  PADIO0_PUN :  1;               /*!< PADIO0_PUN                                                            */
      __IO uint32_t  PADIO1_PUN :  1;               /*!< PADIO1_PUN                                                            */
      __IO uint32_t  PADIO2_PUN :  1;               /*!< PADIO2_PUN                                                            */
      __IO uint32_t  PADIO3_PUN :  1;               /*!< PADIO3_PUN                                                            */
      __IO uint32_t  PADIO4_PUN :  1;               /*!< PADIO4_PUN                                                            */
      __IO uint32_t  PADIO5_PUN :  1;               /*!< PADIO5_PUN                                                            */
      __IO uint32_t  PADIO6_PUN :  1;               /*!< PADIO6_PUN                                                            */
      __IO uint32_t  PADIO7_PUN :  1;               /*!< PADIO7_PUN                                                            */
      __IO uint32_t  PADIO8_PUN :  1;               /*!< PADIO8_PUN                                                            */
      __IO uint32_t  PADIO9_PUN :  1;               /*!< PADIO9_PUN                                                            */
      __IO uint32_t  PADIO10_PUN:  1;               /*!< PADIO10_PUN                                                           */
      __IO uint32_t  PADIO11_PUN:  1;               /*!< PADIO11_PUN                                                           */
      __IO uint32_t  PADIO12_PUN:  1;               /*!< PADIO12_PUN                                                           */
      __IO uint32_t  PADIO13_PUN:  1;               /*!< PADIO13_PUN                                                           */
      __IO uint32_t  PADIO14_PUN:  1;               /*!< PADIO14_PUN                                                           */
      __IO uint32_t  PADIO15_PUN:  1;               /*!< PADIO15_PUN                                                           */
      __IO uint32_t  PADIO16_PUN:  1;               /*!< PADIO16_PUN                                                           */
      __IO uint32_t  PADIO17_PUN:  1;               /*!< PADIO17_PUN                                                           */
      __IO uint32_t  PADIO18_PUN:  1;               /*!< PADIO18_PUN                                                           */
      __IO uint32_t  PADIO19_PUN:  1;               /*!< PADIO19_PUN                                                           */
      __IO uint32_t  PADIO20_PUN:  1;               /*!< PADIO20_PUN                                                           */
      __IO uint32_t  PADIO21_PUN:  1;               /*!< PADIO21_PUN                                                           */
      __IO uint32_t  PADIO22_PUN:  1;               /*!< PADIO22_PUN                                                           */
      __IO uint32_t  PADIO23_PUN:  1;               /*!< PADIO23_PUN                                                           */
      __IO uint32_t  PADIO24_PUN:  1;               /*!< PADIO24_PUN                                                           */
      __IO uint32_t  PADIO25_PUN:  1;               /*!< PADIO25_PUN                                                           */
      __IO uint32_t  PADIO26_PUN:  1;               /*!< PADIO26_PUN                                                           */
      __IO uint32_t  PADIO27_PUN:  1;               /*!< PADIO27_PUN                                                           */
      __IO uint32_t  PADIO28_PUN:  1;               /*!< PADIO28_PUN                                                           */
      __IO uint32_t  PADIO29_PUN:  1;               /*!< PADIO29_PUN                                                           */
      __IO uint32_t  PADIO30_PUN:  1;               /*!< PADIO30_PUN                                                           */
      __IO uint32_t  PADIO31_PUN:  1;               /*!< PADIO31_PUN                                                           */
    };
  };
  
  union {
    __IO uint32_t  PADIO_PUN2;                      /*!< Pull-Up the PADIO[63:32]                                              */
    
    struct {
      __IO uint32_t  PADIO32_PUN:  1;               /*!< PADIO32_PUN                                                           */
      __IO uint32_t  PADIO33_PUN:  1;               /*!< PADIO33_PUN                                                           */
      __IO uint32_t  PADIO34_PUN:  1;               /*!< PADIO34_PUN                                                           */
      __IO uint32_t  PADIO35_PUN:  1;               /*!< PADIO35_PUN                                                           */
      __IO uint32_t  PADIO36_PUN:  1;               /*!< PADIO36_PUN                                                           */
      __IO uint32_t  PADIO37_PUN:  1;               /*!< PADIO37_PUN                                                           */
      __IO uint32_t  PADIO38_PUN:  1;               /*!< PADIO38_PUN                                                           */
      __IO uint32_t  PADIO39_PUN:  1;               /*!< PADIO39_PUN                                                           */
      __IO uint32_t  PADIO40_PUN:  1;               /*!< PADIO40_PUN                                                           */
      __IO uint32_t  PADIO41_PUN:  1;               /*!< PADIO41_PUN                                                           */
      __IO uint32_t  PADIO42_PUN:  1;               /*!< PADIO42_PUN                                                           */
      __IO uint32_t  PADIO43_PUN:  1;               /*!< PADIO43_PUN                                                           */
      __IO uint32_t  PADIO44_PUN:  1;               /*!< PADIO44_PUN                                                           */
      __IO uint32_t  PADIO45_PUN:  1;               /*!< PADIO45_PUN                                                           */
      __IO uint32_t  PADIO46_PUN:  1;               /*!< PADIO46_PUN                                                           */
      __IO uint32_t  PADIO47_PUN:  1;               /*!< PADIO47_PUN                                                           */
      __IO uint32_t  PADIO48_PUN:  1;               /*!< PADIO48_PUN                                                           */
      __IO uint32_t  PADIO49_PUN:  1;               /*!< PADIO49_PUN                                                           */
      __IO uint32_t  PADIO50_PUN:  1;               /*!< PADIO50_PUN                                                           */
      __IO uint32_t  PADIO51_PUN:  1;               /*!< PADIO51_PUN                                                           */
      __IO uint32_t  PADIO52_PUN:  1;               /*!< PADIO52_PUN                                                           */
      __IO uint32_t  PADIO53_PUN:  1;               /*!< PADIO53_PUN                                                           */
      __IO uint32_t  PADIO54_PUN:  1;               /*!< PADIO54_PUN                                                           */
      __IO uint32_t  PADIO55_PUN:  1;               /*!< PADIO55_PUN                                                           */
      __IO uint32_t  PADIO56_PUN:  1;               /*!< PADIO56_PUN                                                           */
      __IO uint32_t  PADIO57_PUN:  1;               /*!< PADIO57_PUN                                                           */
      __IO uint32_t  PADIO58_PUN:  1;               /*!< PADIO58_PUN                                                           */
      __IO uint32_t  PADIO59_PUN:  1;               /*!< PADIO59_PUN                                                           */
      __IO uint32_t  PADIO60_PUN:  1;               /*!< PADIO60_PUN                                                           */
      __IO uint32_t  PADIO61_PUN:  1;               /*!< PADIO61_PUN                                                           */
      __IO uint32_t  PADIO62_PUN:  1;               /*!< PADIO62_PUN                                                           */
      __IO uint32_t  PADIO63_PUN:  1;               /*!< PADIO63_PUN                                                           */
    };
  };
  
  union {
    __IO uint32_t  PADIO_PUN3;                      /*!< Pull-Up the PADIO[72:64]                                              */
    
    struct {
      __IO uint32_t  PADIO64_PUN:  1;               /*!< PADIO64_PUN                                                           */
      __IO uint32_t  PADIO65_PUN:  1;               /*!< PADIO65_PUN                                                           */
      __IO uint32_t  PADIO66_PUN:  1;               /*!< PADIO66_PUN                                                           */
      __IO uint32_t  PADIO67_PUN:  1;               /*!< PADIO67_PUN                                                           */
      __IO uint32_t  PADIO68_PUN:  1;               /*!< PADIO68_PUN                                                           */
      __IO uint32_t  PADIO69_PUN:  1;               /*!< PADIO697_PUN                                                          */
      __IO uint32_t  PADIO70_PUN:  1;               /*!< PADIO70_PUN                                                           */
      __IO uint32_t  PADIO71_PUN:  1;               /*!< PADIO71_PUN                                                           */
      __IO uint32_t  PADIO72_PUN:  1;               /*!< PADIO72_PUN                                                           */
    };
  };
  __IO uint32_t  LCD_SEN_PSEL;                      /*!< 0: LCD IO
                                                         1: LCD_IO[24:11] switch to Sensor IF                                  */
  __I  uint32_t  RESERVED1[17];
  __I  uint32_t  FPGA_VER;                          /*!< FPGA version                                                          */
  __I  uint32_t  ASIC_ID;                           /*!< ASIC chip ID (Return 53510h)                                          */
  
  union {
    __IO uint32_t  REG_0x00A8;                      /*!< REG_0x00A8                                                            */
    
    struct {
      __IO uint32_t  DDR_VREF_EN:  1;               /*!< Enable output DDR VREF                                                */
      __IO uint32_t  SF_MI_PDN  :  1;               /*!< Pull-Down the SF_MI_PAD when in input Mode.
                                                         0: Enabel the Pull-Down Function.                                     */
           uint32_t             :  2;
      __IO uint32_t  TRSTN_PDN  :  1;               /*!< Pull-Down the TRSTN_PAD when in input Mode.
                                                         0: Enabel the Pull-Down Function.                                     */
      __IO uint32_t  TCK_PDN    :  1;               /*!< Pull-Down the TCK_PAD when in input Mode.
                                                         0: Enabel the Pull-Down Function.                                     */
      __IO uint32_t  TMS_PDN    :  1;               /*!< Pull-Down the TMS_PAD when in input Mode.
                                                         0: Enabel the Pull-Down Function.                                     */
      __IO uint32_t  TDI_PDN    :  1;               /*!< Pull-Down the TDI_PAD when in input Mode.
                                                         0: Enabel the Pull-Down Function.                                     */
      __IO uint32_t  TDO_PDN    :  1;               /*!< Pull-Down the TDO_PAD when in input Mode.
                                                         0: Enabel the Pull-Down Function.                                     */
      __IO uint32_t  I2C_SEL    :  2;               /*!< Select which I2C Signal is connected to PADIO                         */
      __IO uint32_t  DDR1_PHY_EN:  1;               /*!< Enable the DDR1_PHY Function.                                         */
      __IO uint32_t  JTAG_EN    :  1;               /*!< Enable the JTAG Function.                                             */
      __IO uint32_t  DBG_PROB_EN:  1;               /*!< Enable the Debug Signal to PADIO.                                     */
      __IO uint32_t  DBG_SEL    :  2;               /*!< Selection wihich debug signal connect to PADIO                        */
      __IO uint32_t  LVD_EN     :  1;               /*!< LVD Enable Pin.                                                       */
      __IO uint32_t  LVD_SYS_EN_N:  1;              /*!< LVD SYS Enalbe pin.                                                   */
      __IO uint32_t  R2R_SEL    :  2;               /*!< R2R DAC OPAMP Current Select.                                         */
      __IO uint32_t  TV_DAC_PD  :  1;               /*!< Power-Down the TV-DAC                                                 */
      __IO uint32_t  TV_DAC_STBY:  1;               /*!< DAC Standby control signal, all circuits are off except bandgap.      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00AC;                      /*!< REG_0x00AC                                                            */
    
    struct {
      __IO uint32_t  PLL100_ICP :  2;               /*!< PLL100 Charge pump current control.                                   */
      __IO uint32_t  PLL100_CK_SEL:  1;             /*!< Reference clock selection.
                                                         Note: Default(0) is 12MHz                                             */
      __IO uint32_t  PLL100_PD_N:  1;               /*!< Enable the PLL100 Power on.
                                                         Note: 1 = Power-On                                                    */
      __IO uint32_t  PLL100_NBW :  2;               /*!< VCO supply tracking bandwidth control bit.                            */
      __IO uint32_t  PLL300_ICP :  2;               /*!< PLL300 Charge pump current control                                    */
      __IO uint32_t  PLL300_CK_SEL:  1;             /*!< Reference clock selection.
                                                         Note: Default(0) is 12MHz                                             */
      __IO uint32_t  PLL300_PD_N:  1;               /*!< Enable the PLL300 Power on.
                                                         Note: 1 = Power-On                                                    */
      __IO uint32_t  PLL300_NBW :  2;               /*!< VCO supply tracking bandwidth control bit.                            */
      __IO uint32_t  PLL300_DIV :  6;               /*!< PLL300 division ration control.                                       */
      __IO uint32_t  PLL800_ICP :  2;               /*!< PLL800 Charge pump current control                                    */
      __IO uint32_t  PLL800_DLY_SEL:  1;            /*!< PLL800 delay control.                                                 */
      __IO uint32_t  PLL300_FDIV_SEL:  1;           /*!< TX output clock selection.                                            */
      __IO uint32_t  PLL800_PD_N:  1;               /*!< Enable the PLL800 Power on.
                                                         Note: 1 = Power-On                                                    */
      __IO uint32_t  PLL800_NBW :  2;               /*!< VCO supply tracking bandwidth control bit.                            */
      __IO uint32_t  PLL800_DIV :  7;               /*!< PLL800 division ration control.                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00B0;                      /*!< REG_0x00B0                                                            */
    
    struct {
      __IO uint32_t  LCDPLL_ICP :  2;               /*!< Charge pump current selection                                         */
      __IO uint32_t  LCDPLL_CK_SEL:  2;             /*!< Output frequecny selection.                                           */
      __IO uint32_t  LCDPLL_PD_N:  1;               /*!< LCD PLL power down control.
                                                         Note: 1 = Power-On PLL                                                */
      __IO uint32_t  LCDPLL_DLY_SEL:  1;            /*!< LCD PLL delay control.                                                */
      __IO uint32_t  LCDPLL_LDO_EN:  1;             /*!< LDO Enable control.
                                                         1: Enable LDO.                                                        */
      __IO uint32_t  LCDPLL_SDM_EN:  1;             /*!< Sigma-Delta modulation(SDM) enable or disable.                        */
      __IO uint32_t  LCDPLL_INT :  5;               /*!< Integer number for SDM.                                               */
      __O  uint32_t  LCDPLL_INT_FRA_VLD:  1;        /*!< Integer Number for SDM.                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00B4;                      /*!< REG_0x00B4                                                            */
    
    struct {
      __IO uint32_t  LCDPLL_FRA : 20;               /*!< Fractional number for SDM                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00B8;                      /*!< REG_0x00B8                                                            */
    
    struct {
      __IO uint32_t  REG_LVD_SEL_EN:  1;            /*!< LVD_SEL_EN                                                            */
      __IO uint32_t  REG_TV_DAC_BG_EN:  1;          /*!< TV_DAC_BG_EN                                                          */
      __IO uint32_t  REG_ILRC_TRIM_EN:  1;          /*!< ILRC_TRIM_EN                                                          */
      __IO uint32_t  REG_UPHY1_TX_TERM_EN:  1;      /*!< UPHY1_TX_TERM_EN                                                      */
      __IO uint32_t  REG_UPHY1_SQULVL_EN:  1;       /*!< UPHY1_SQULVL_EN                                                       */
      __IO uint32_t  REG_UPHY1_DISTLVL_EN:  1;      /*!< UPHY1_DISTLVL_EN                                                      */
      __IO uint32_t  REG_UPHY1_KVCO_EN:  1;         /*!< UPHY1_KVCO_EN                                                         */
      __IO uint32_t  REG_UPHY1_BW_SW_EN:  1;        /*!< UPHY1_BW_SW_EN                                                        */
      __IO uint32_t  REG_UPHY2_TX_TERM_EN:  1;      /*!< UPHY2_TX_TERM_EN                                                      */
      __IO uint32_t  REG_UPHY2_SQULVL_EN:  1;       /*!< UPHY2_SQULVL_EN                                                       */
      __IO uint32_t  REG_UPHY2_DISTLVL_EN:  1;      /*!< UPHY2_DISTLVL_EN                                                      */
      __IO uint32_t  REG_UPHY2_KVCO_EN:  1;         /*!< UPHY2_KVCO_EN                                                         */
      __IO uint32_t  REG_UPHY2_BW_SW_EN:  1;        /*!< UPHY2_BW_SW_EN                                                        */
      __IO uint32_t  REG_UPHY1_TX_SW:  1;           /*!< UPHY1_TX_SW                                                           */
      __IO uint32_t  REG_UPHY2_TX_SW:  1;           /*!< UPHY2_TX_SW                                                           */
           uint32_t             :  1;
      __IO uint32_t  REG_LVD_SEL:  4;               /*!< LVD_SEL setting value.                                                */
      __IO uint32_t  REG_TV_DAC_BG:  3;             /*!< TV_DAC_BG.                                                            */
      __IO uint32_t  REG_ILRC_TRIM:  6;             /*!< ILRC Trim.                                                            */
    };
  };
} GLB_Type;


/* ================================================================================ */
/* ================                      SARAD                     ================ */
/* ================================================================================ */


/**
  * @brief SAR ADC (SARAD)
  */

typedef struct {                                    /*!< SARAD Structure                                                       */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG 0x0000                                                            */
    
    struct {
      __IO uint32_t  SAR_CLK_EN :  1;               /*!< SAR ADC clock enable                                                  */
      __IO uint32_t  SAR_EN     :  1;               /*!< SAR ADC enable                                                        */
    };
  };
  
  union {
    __IO uint32_t  CH_TRIGGER;                      /*!< Detect Channel voltage.                                               */
    
    struct {
      __O  uint32_t  Detect_channel_1_voltage:  1;  /*!< To detect CH1 voltage, ADC analog and digital circuit must be
                                                         enable                                                                */
      __O  uint32_t  Detect_channel_2_voltage:  1;  /*!< To detect CH2 voltage, ADC analog and digital circuit must be
                                                         enable                                                                */
      __O  uint32_t  Detect_channel_3_voltage:  1;  /*!< To detect CH3 voltage, ADC analog and digital circuit must be
                                                         enable                                                                */
      __O  uint32_t  Detect_channel_4_voltage:  1;  /*!< To detect CH4 voltage, ADC analog and digital circuit must be
                                                         enable                                                                */
      __O  uint32_t  Detect_channel_5_voltage:  1;  /*!< To detect CH5 voltage, ADC analog and digital circuit must be
                                                         enable                                                                */
    };
  };
  
  union {
    __IO uint32_t  CH_RDY;                          /*!< Ready to read Channel voltage.                                        */
    
    struct {
      __I  uint32_t  Detect_Ready_1:  1;            /*!< Ready to read CH1 voltage                                             */
      __I  uint32_t  Detect_Ready_2:  1;            /*!< Ready to read CH2 voltage                                             */
      __I  uint32_t  Detect_Ready_3:  1;            /*!< Ready to read CH3 voltage                                             */
      __I  uint32_t  Detect_Ready_4:  1;            /*!< Ready to read CH4 voltage                                             */
      __I  uint32_t  Detect_Ready_5:  1;            /*!< Ready to read CH5 voltage                                             */
    };
  };
  
  union {
    __IO uint32_t  CH_RPT;                          /*!< 10 bit value converted from channel voltage.                          */
    
    struct {
      __I  uint32_t  CH1_RPT    : 10;               /*!< 10 bit value converted from CH1 voltage;CH1_RPT =(Vin/3.3)*400h       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG 0x0010                                                            */
    
    struct {
      __I  uint32_t  CH2_RPT    : 10;               /*!< 10 bit value converted from CH2 voltage;CH2_RPT =(Vin/3.3)*400h       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG 0x0014                                                            */
    
    struct {
      __I  uint32_t  CH3_RPT    : 10;               /*!< 10 bit value converted from CH3 voltage;CH3_RPT =(Vin/3.3)*400h       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG 0x0018                                                            */
    
    struct {
      __I  uint32_t  CH4_RPT    : 10;               /*!< 10 bit value converted from CH4 voltage;CH4_RPT =(Vin/3.3)*400h       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG 0x001C                                                            */
    
    struct {
      __I  uint32_t  CH5_RPT    : 10;               /*!< 10 bit value converted from CH5 voltage;CH5_RPT =(Vin/3.3)*400h       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG 0x0020                                                            */
    
    struct {
      __IO uint32_t  SAR_GPIO_EN:  5;               /*!< SAR GPIO mode selection                                               */
      __IO uint32_t  SAR_OSC_EN :  1;               /*!< Enable input-offset calibration                                       */
      __IO uint32_t  SAR_DCMP   :  1;               /*!< Delay line control bit of internal comparing
                                                         0:5ns
                                                         1:10ns                                                                */
      __IO uint32_t  SAR_CH_CTRL:  1;               /*!< SAR Channel control mode                                              */
      __IO uint32_t  SAR_IOS    :  2;               /*!< Control bit of OOS bias current
                                                         0:4u
                                                         1:5u
                                                         2:6u
                                                         3:7u                                                                  */
      __IO uint32_t  SAR_ICM    :  2;               /*!< Control bit of VCM bias current
                                                         0:4u
                                                         1:5u
                                                         2:6u
                                                         3:7u                                                                  */
      __IO uint32_t  SAR_CH5P   :  3;               /*!< Clock signal of input channel selection                               */
      __IO uint32_t  SAR_IVDDQ_ADC:  1;             /*!< SAR_IVDDQ_ADC                                                         */
    };
  };
} SARAD_Type;


/* ================================================================================ */
/* ================                       RTC                      ================ */
/* ================================================================================ */


/**
  * @brief Real time clock
Note 1: The max time between CPU read or write register is 1MHz.
Note 2: CPU should read one register(9003_0000~9003_0034) twice. (RTC)
  */

typedef struct {                                    /*!< RTC Structure                                                         */
  __IO uint32_t  RTC_TIMER0;                        /*!< 0x9003_0000
                                                         RTC_TIMER[7:0] (unit: 1 sec)                                          */
  __IO uint32_t  RTC_TIMER1;                        /*!< 0x9003_0004
                                                         RTC_TIMER[15:8] (unit: 1 sec)                                         */
  __IO uint32_t  RTC_TIMER2;                        /*!< 0x9003_0008
                                                         RTC_TIMER[23:16] (unit: 1 sec)                                        */
  __IO uint32_t  RTC_TIMER3;                        /*!< 0x9003_000C
                                                         RTC_TIMER[29:24] (unit: 1 sec)                                        */
  __IO uint32_t  ALARM_TIME0;                       /*!< 0x9003_0010
                                                         ALARM_TIME[7:0] (unit: 1 sec)                                         */
  __IO uint32_t  ALARM_TIME1;                       /*!< 0x9003_0014
                                                         ALARM_TIME[15:8] (unit: 1 sec)                                        */
  __IO uint32_t  ALARM_TIME2;                       /*!< 0x9003_0018
                                                         ALARM_TIME[23:16] (unit: 1 sec)                                       */
  __IO uint32_t  ALARM_TIME3;                       /*!< 0x9003_001C
                                                         ALARM_TIME[29:24] (unit: 1 sec)                                       */
  __IO uint32_t  WAKEUP_TIMER0;                     /*!< 0x9003_0020
                                                         WAKEUP_TIMER[7:0] (unit: 1 sec)                                       */
  __IO uint32_t  WAKEUP_TIMER1;                     /*!< 0x9003_0024
                                                         WAKEUP_TIMER[15:8] (unit: 1 sec)                                      */
  __IO uint32_t  WAKEUP_TIMER2;                     /*!< 0x9003_0028
                                                         WAKEUP_TIMER[23:16] (unit: 1 sec)                                     */
  __IO uint32_t  RTC_CONTROL;                       /*!< RTC Control Register                                                  */
  __IO uint32_t  RTC_GPIO;                          /*!< RTC GPIO Control Register                                             */
  __IO uint32_t  RTC_GPIO_CTL_EN;                   /*!< RTC GPIO Control Enable                                               */
  __O  uint8_t   PASSWORD1;                         /*!< 0x9003_0038
                                                         PASSWORD1 0X56h must be written before writing register
                                                         9003_0000h ~ 9003_0034h                                               */
  __I  uint8_t   RESERVED[3];
  __O  uint8_t   PASSWORD2;                         /*!< 0x9003_003C
                                                         PASSWORD2 0xA9h must be written before writing register
                                                         9003_0000h ~ 9003_0034h                                               */
  __I  uint8_t   RESERVED1[3];
  __IO uint8_t   DATA_BUF_0;                        /*!< 0x9003_0040
                                                         Data_0 buffer                                                         */
  __I  uint8_t   RESERVED2[3];
  __IO uint8_t   DATA_BUF_1;                        /*!< 0x9003_0044
                                                         Data_1 buffer                                                         */
  __I  uint8_t   RESERVED3[3];
  __IO uint8_t   DATA_BUF_2;                        /*!< 0x9003_0048
                                                         Data_2 buffer                                                         */
  __I  uint8_t   RESERVED4[3];
  __IO uint8_t   DATA_BUF_3;                        /*!< 0x9003_004C
                                                         Data_3 buffer                                                         */
  __I  uint8_t   RESERVED5[3];
  __IO uint8_t   DATA_BUF_4;                        /*!< 0x9003_0050
                                                         Data_4 buffer                                                         */
  __I  uint8_t   RESERVED6[3];
  __IO uint8_t   DATA_BUF_5;                        /*!< 0x9003_0054
                                                         Data_5 buffer                                                         */
  __I  uint8_t   RESERVED7[3];
  __IO uint8_t   DATA_BUF_6;                        /*!< 0x9003_0058
                                                         Data_6 buffer                                                         */
  __I  uint8_t   RESERVED8[3];
  __IO uint8_t   DATA_BUF_7;                        /*!< 0x9003_005C
                                                         Data_7 buffer                                                         */
  __I  uint8_t   RESERVED9[3];
  __IO uint8_t   DATA_BUF_8;                        /*!< 0x9003_0060
                                                         Data_8 buffer                                                         */
  __I  uint8_t   RESERVED10[3];
  __IO uint8_t   DATA_BUF_9;                        /*!< 0x9003_0064
                                                         Data_9 buffer                                                         */
  __I  uint8_t   RESERVED11[155];
  
  union {
    __IO uint8_t   REG_0x9003_0100;                 /*!< 0x9003_0100                                                           */
    
    struct {
      __I  uint8_t   RTC_RD_RDY :  1;               /*!< 1: Ready to read RTC timerNote: Before reading RTC timer, must
                                                         wait until RTC_RD_RDY is high                                         */
      __I  uint8_t   RTC_WR_RDY :  1;               /*!< 1: Writing to RTC timer is OK.                                        */
      __IO uint8_t   RTC_CTL    :  1;               /*!< 1: Set RTC CLT signal to high. power control                          */
      __IO uint8_t   RTC_PG_RST :  1;               /*!< 1: Reset RTC pulse generator.                                         */
      __I  uint8_t   KEY        :  1;               /*!< Read external push-button KEY.                                        */
    };
  };
} RTC_Type;


/* ================================================================================ */
/* ================                       MC                       ================ */
/* ================================================================================ */


/**
  * @brief Motor Controller (MC)
  */

typedef struct {                                    /*!< MC Structure                                                          */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< 90004_0000                                                            */
    
    struct {
      __IO uint32_t  MT0_MODE   :  4;               /*!< MT0 MODE[3:0]                                                         */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< 9004_0008                                                             */
    
    struct {
      __IO uint32_t  MT0_INV    :  1;               /*!< MT0_INV                                                               */
      __IO uint32_t  MT0_CCW    :  1;               /*!< MT0 CCW                                                               */
      __IO uint32_t  MT0_EN     :  1;               /*!< MT0 EN                                                                */
      __I  uint32_t  MT0_RDY    :  1;               /*!< MT0 RDY                                                               */
      __IO uint32_t  MT0_CONTI  :  1;               /*!< MT0 CONTI                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< 9004_000C                                                             */
    
    struct {
      __IO uint32_t  MT0_CNT    :  8;               /*!< MT0 CNT                                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< 9004_0010                                                             */
    
    struct {
      __IO uint32_t  MT0_BASE   :  8;               /*!< Base timer for motor0 controller                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< 9004_0014                                                             */
    
    struct {
      __IO uint32_t  MT0_PERIOD :  8;               /*!< Period for one full step of motor0 controller                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< 9004_0018                                                             */
    
    struct {
      __IO uint32_t  MT0_HIGH   :  8;               /*!< High pulse time for motor0 controller                                 */
    };
  };
  __I  uint32_t  RESERVED1;
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< 9004_0020                                                             */
    
    struct {
      __IO uint32_t  MT1_MODE   :  4;               /*!< MT1 MODE                                                              */
    };
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< 9004_0028                                                             */
    
    struct {
      __IO uint32_t  MT1_INV    :  1;               /*!< MT1 INV                                                               */
      __IO uint32_t  MT1_CCW    :  1;               /*!< MT1 CCW                                                               */
      __IO uint32_t  MT1_EN     :  1;               /*!< MT1 EN                                                                */
      __I  uint32_t  MT1_RDY    :  1;               /*!< MT1 RDY                                                               */
      __IO uint32_t  MT1_CONTI  :  1;               /*!< MT1 CONTI                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x002C;                      /*!< 9004_002C                                                             */
    
    struct {
      __IO uint32_t  MT1_CNT    :  8;               /*!< MT1 CNT                                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< 9004_0030                                                             */
    
    struct {
      __IO uint32_t  MT1_BASE   :  8;               /*!< Base timer for motor1 controller                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< 9004_0034                                                             */
    
    struct {
      __IO uint32_t  MT1_PERIOD :  8;               /*!< Period for one full step of motor1 controller                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0038;                      /*!< 9004_0038                                                             */
    
    struct {
      __IO uint32_t  MT1_HIGH   :  8;               /*!< High pulse time for motor1 controller                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x003C;                      /*!< 9004_003C                                                             */
    
    struct {
      __IO uint32_t  MT0_CK_BASE:  4;               /*!< Clock base = MT0_CK_BASE / 12MHz                                      */
      __IO uint32_t  MT1_CK_BASE:  4;               /*!< Clock base = MT1_CK_BASE / 12MHz                                      */
    };
  };
} MC_Type;


/* ================================================================================ */
/* ================                    USB_PHY1                    ================ */
/* ================================================================================ */


/**
  * @brief USB PHY1 Register(USB Host only) (USB_PHY1)
  */

typedef struct {                                    /*!< USB_PHY1 Structure                                                    */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x0000                                                            */
    
    struct {
      __IO uint32_t  I_TEST_MODE_SEL:  1;           /*!< Selection CP/FT test mode.                                            */
      __IO uint32_t  CLK_TEST_EN:  1;               /*!< CLK 240MHz output from DP/DM test mode.                               */
      __IO uint32_t  I_BIST_LB_TEST_MODE1_0:  2;    /*!< Select Loop back test mode for UTMI BIST mode.                        */
      __IO uint32_t  I_SEL_TX_TURNOFF_TEST:  1;     /*!< Select TX gating test mode.
                                                         (It need to act with FW_CTL_SEL =1b1 using)
                                                         Default setting value: 1b0
                                                         When I_SEL_TX_TURNOFF_TEST = 1b1 and FW_CTL_SEL =1b1,
                                                         will entry HS TX gating test mode, it can measured TX gating
                                                         current.
                                                         When I_SEL_TX_TURNOFF_TEST = 1b1 and FW_CTL_SEL =1b0,
                                                         will entry HS RX Idle mode, it can measured HS termination 45ohm
                                                                                                                               */
      __IO uint32_t  I_DB_MODE_SEL:  1;             /*!< Selection Debug Mode.                                                 */
      __IO uint32_t  HOST_DISC_TEST:  1;            /*!< HOST Disconnect test mode.                                            */
      __IO uint32_t  PDN_TEST   :  1;               /*!< Power Down test mode.                                                 */
      __IO uint32_t  FS_R1P5K_TEST:  1;             /*!< FS Pull-up resistor test mode.                                        */
      __IO uint32_t  DCDR_SEL   :  1;               /*!< DIGITAL CDR selector.                                                 */
      __IO uint32_t  SQU_SEL    :  1;               /*!< SQU Generate selection.                                               */
           uint32_t             : 20;
      __IO uint32_t  HOST_PHY_SEL:  1;              /*!< PHY selection                                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
      __IO uint32_t  TX_OPT_SEL :  1;               /*!< It is a control pin. 
                                                         Select the TX_BIT_EN and TX_DATA either delay
                                                         CLK60M 1T or not.                                                     */
      __IO uint32_t  FW_CTL_TX  :  1;               /*!< It is a control pin.
                                                         Switch the original function or use turn-off TX issue function.       */
      __IO uint32_t  TXACTEN_GEN_SEL:  1;           /*!< It is a control pin. Select the turn-off TX issue option.             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< REG_0x0008                                                            */
    
    struct {
      __IO uint32_t  I_TEST_KEY : 16;               /*!< Test key for random LFSR data. Default setting: 16'h0000.             */
      __IO uint32_t  I_TEST_STOP:  1;               /*!< Control signal. Stop BIST mode generate random data.                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG_0x000C                                                            */
    
    struct {
      __IO uint32_t  EN_SE0     :  1;               /*!< Enable SE0 detect.                                                    */
      __IO uint32_t  IFC        :  1;               /*!< Enable Fast Charge.                                                   */
      __IO uint32_t  TXIPADD    :  1;               /*!< Tx impedance RP add option.                                           */
      __IO uint32_t  TXINADD    :  1;               /*!< Tx impedance RN add option.                                           */
      __IO uint32_t  IC_ADD     :  1;               /*!< FS Icap add.                                                          */
      __IO uint32_t  RPU_DP2    :  1;               /*!< Enable 1K ohm pull up resistor on D+.                                 */
      __IO uint32_t  RPU_DM2    :  1;               /*!< Enable 1K ohm pull up resistor on D-.                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG_0x0010                                                            */
    
    struct {
      __IO uint32_t  TX_SW3_0   :  4;               /*!< Output swing control (200mV~575mV).
                                                         Default = 1010 (400mV).
                                                         TRIM used.                                                            */
      __IO uint32_t  TX_SR1_0   :  2;               /*!< Output slew rate control (660 V/us ~1130V/us).
                                                         Default = 10 (800V/us)                                                */
           uint32_t             :  2;
      __IO uint32_t  TX_TERM2_0 :  3;               /*!< Output termination resistor control (39 ohm ~45ohm)
                                                         Default = 100 (42ohm)
                                                         TRIM used.                                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_0x0014                                                            */
    
    struct {
      __IO uint32_t  I_SEL      :  1;               /*!< Current option inside circuit for jitter reduction.
                                                         Default = 1.                                                          */
      __IO uint32_t  NO_OFFSET  :  1;               /*!< No offset option between DPRX-DMRX.
                                                         Default = 0.                                                          */
      __IO uint32_t  I_SQLVL    :  2;               /*!< 2-bit squelch level setting from 100mV to 150mV.
                                                         Default = 01
                                                         TRIM used.                                                            */
      __IO uint32_t  I_DISTLVL  :  2;               /*!< 2-bit disconnection level setting from 590mV to 680mV.
                                                         Default = 00
                                                         TRIM used.                                                            */
      __IO uint32_t  DYN_OS_EN  :  1;               /*!< Enable USB2.0 Rx dynamic input stage offset.
                                                         Default setting value: 1'b0                                           */
      __IO uint32_t  HALF_OS_EN :  1;               /*!< Enable USB2.0 Rx half input stage offset
                                                         Default setting value: 1'b1                                           */
      __IO uint32_t  CDR_SQU_EN :  1;               /*!< 1: CDR output gating (Default value)
                                                         0: Original                                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG_0x0018                                                            */
    
    struct {
      __IO uint32_t  LDO_EN     :  1;               /*!< Enable internal LDO for PLL.
                                                         Default setting value: 1'b1                                           */
      __IO uint32_t  SW         :  2;               /*!< PLL locking range control bit. Default= 01                            */
           uint32_t             :  2;
      __IO uint32_t  KVCO_SW    :  3;               /*!< PLL KVCO range options. Default = 100
                                                         TRIM used.                                                            */
      __IO uint32_t  BW_SW      :  3;               /*!< PLL bandwidth options. Default = 110
                                                         (For XTAL reference application. Default = 110)
                                                         (For LC reference application. Default = 001)
                                                         TRIM used.                                                            */
           uint32_t             : 13;
      __IO uint32_t  CKEN       :  1;               /*!< Add by SA3 for testing                                                */
      __IO uint32_t  PLL_EN     :  1;               /*!< PLL enable signal.                                                    */
      __IO uint32_t  PDN12B_192M:  1;               /*!< 192MHz clock function disable (CK_DIV2P5 = L).                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG_0x001C                                                            */
    
    struct {
      __IO uint32_t  SEL_PD     :  1;               /*!< Low Power flow selection signal. Default setting value: 1b0.          */
      __IO uint32_t  FW_SUSPENDM:  1;               /*!< add Control low power flow from FW register.
                                                         Default setting value: 1b1
                                                         (See the PHY Design Report has descript about Power sequence
                                                         flow)
                                                         0: control PCU sequence from FW control
                                                                                                                               */
      __IO uint32_t  ISOLATION  :  1;               /*!< FW control isolation cell control.
                                                         (See the PHY Design Report has descript about Power sequence
                                                         flow)
                                                         1: Enable Isolation cell.
                                                         0: Disable Isolation control
                                                                                                                               */
      __IO uint32_t  PHY_PWR    :  1;               /*!< USB PHY is Active indication for system wakeup event.                 */
      __IO uint32_t  RETEN_CTL  :  1;               /*!< FW control retension cell control. Low Active.
                                                         (See the PHY Design Report has descript about Power sequence
                                                         flow)
                                                         1: Normal.
                                                         0: Reset                                                              */
      __IO uint32_t  DPPULLDOWN :  1;               /*!< 1: Pulldown the PHYs DP register.                                     */
      __IO uint32_t  DMPULLDOWN :  1;               /*!< 1: Pulldown the PHYs DM register.                                     */
      __IO uint32_t  VBUS_VALID :  1;               /*!< 1: Indicate the vbus is active, only active for Device PHY.           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG_0x0020                                                            */
    
    struct {
      __IO uint32_t  FRA_IN     : 22;               /*!< 192MHz clock function disable (CK_DIV2P5 = L) 22h0
                                                         1 = Enable
                                                         0 = Disable
                                                         If host                                                               */
      __IO uint32_t  I_UPD_IN   :  1;               /*!< Toggle for INT or FRA update.                                         */
      __IO uint32_t  I_SEL_DIV  :  1;               /*!< Control PLL divide number from SDM control or FW control
                                                         1: FW control DIV value from INT_IN[5:0].
                                                         0: DIV value from SDM generation
                                                                                                                               */
      __IO uint32_t  INT_IN     :  6;               /*!< DM control signal.
                                                         From Firmware. Coarse tune bit. Default value: 6h28(if X'tal
                                                         12 Mhz)                                                               */
           uint32_t             :  1;
      __IO uint32_t  SDM_EN_IN  :  1;               /*!< SDM control signal.
                                                         From Firmware:
                                                          1: enable
                                                         0: use Default value                                                  */
    };
  };
} USB_PHY1_Type;


/* ================================================================================ */
/* ================                    USB_PHY2                    ================ */
/* ================================================================================ */


/**
  * @brief USB PHY2 Register(USB Host/Device) (USB_PHY2)
  */

typedef struct {                                    /*!< USB_PHY2 Structure                                                    */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x0000                                                            */
    
    struct {
      __IO uint32_t  I_TEST_MODE_SEL:  1;           /*!< Selection CP/FT test mode.                                            */
      __IO uint32_t  CLK_TEST_EN:  1;               /*!< CLK 240MHz output from DP/DM test mode.                               */
      __IO uint32_t  I_BIST_LB_TEST_MODE1_0:  2;    /*!< Select Loop back test mode for UTMI BIST mode.                        */
      __IO uint32_t  I_SEL_TX_TURNOFF_TEST:  1;     /*!< Select TX gating test mode.
                                                         (It need to act with FW_CTL_SEL =1b1 using)
                                                         Default setting value: 1b0
                                                         When I_SEL_TX_TURNOFF_TEST = 1b1 and FW_CTL_SEL =1b1,
                                                         will entry HS TX gating test mode, it can measured TX gating
                                                         current.
                                                         When I_SEL_TX_TURNOFF_TEST = 1b1 and FW_CTL_SEL =1b0,
                                                         will entry HS RX Idle mode, it can measured HS termination 45ohm
                                                                                                                               */
      __IO uint32_t  I_DB_MODE_SEL:  1;             /*!< Selection Debug Mode.                                                 */
      __IO uint32_t  HOST_DISC_TEST:  1;            /*!< HOST Disconnect test mode.                                            */
      __IO uint32_t  PDN_TEST   :  1;               /*!< Power Down test mode.                                                 */
      __IO uint32_t  FS_R1P5K_TEST:  1;             /*!< FS Pull-up resistor test mode.                                        */
      __IO uint32_t  DCDR_SEL   :  1;               /*!< DIGITAL CDR selector.                                                 */
      __IO uint32_t  SQU_SEL    :  1;               /*!< SQU Generate selection.                                               */
           uint32_t             : 20;
      __IO uint32_t  HOST_PHY_SEL:  1;              /*!< PHY selection                                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
      __IO uint32_t  TX_OPT_SEL :  1;               /*!< It is a control pin. 
                                                         Select the TX_BIT_EN and TX_DATA either delay
                                                         CLK60M 1T or not.                                                     */
      __IO uint32_t  FW_CTL_TX  :  1;               /*!< It is a control pin.
                                                         Switch the original function or use turn-off TX issue function.       */
      __IO uint32_t  TXACTEN_GEN_SEL:  1;           /*!< It is a control pin. Select the turn-off TX issue option.             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< REG_0x0008                                                            */
    
    struct {
      __IO uint32_t  I_TEST_KEY : 16;               /*!< Test key for random LFSR data. Default setting: 16'h0000.             */
      __IO uint32_t  I_TEST_STOP:  1;               /*!< Control signal. Stop BIST mode generate random data.                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG_0x000C                                                            */
    
    struct {
      __IO uint32_t  EN_SE0     :  1;               /*!< Enable SE0 detect.                                                    */
      __IO uint32_t  IFC        :  1;               /*!< Enable Fast Charge.                                                   */
      __IO uint32_t  TXIPADD    :  1;               /*!< Tx impedance RP add option.                                           */
      __IO uint32_t  TXINADD    :  1;               /*!< Tx impedance RN add option.                                           */
      __IO uint32_t  IC_ADD     :  1;               /*!< FS Icap add.                                                          */
      __IO uint32_t  RPU_DP2    :  1;               /*!< Enable 1K ohm pull up resistor on D+.                                 */
      __IO uint32_t  RPU_DM2    :  1;               /*!< Enable 1K ohm pull up resistor on D-.                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG_0x0010                                                            */
    
    struct {
      __IO uint32_t  TX_SW3_0   :  4;               /*!< Output swing control (200mV~575mV).
                                                         Default = 1010 (400mV).
                                                         TRIM used.                                                            */
      __IO uint32_t  TX_SR1_0   :  2;               /*!< Output slew rate control (660 V/us ~1130V/us).
                                                         Default = 10 (800V/us)                                                */
           uint32_t             :  2;
      __IO uint32_t  TX_TERM2_0 :  3;               /*!< Output termination resistor control (39 ohm ~45 ohm)
                                                         Default = 100 (42 ohm)
                                                         TRIM used.                                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_0x0014                                                            */
    
    struct {
      __IO uint32_t  I_SEL      :  1;               /*!< Current option inside circuit for jitter reduction.
                                                         Default = 1.                                                          */
      __IO uint32_t  NO_OFFSET  :  1;               /*!< No offset option between DPRX-DMRX.
                                                         Default = 0.                                                          */
      __IO uint32_t  I_SQLVL    :  2;               /*!< 2-bit squelch level setting from 100mV to 150mV.
                                                         Default = 01
                                                         TRIM used.                                                            */
      __IO uint32_t  I_DISTLVL  :  2;               /*!< 2-bit disconnection level setting from 590mV to 680mV.
                                                         Default = 00
                                                         TRIM used.                                                            */
      __IO uint32_t  DYN_OS_EN  :  1;               /*!< Enable USB2.0 Rx dynamic input stage offset.
                                                         Default setting value: 1'b0                                           */
      __IO uint32_t  HALF_OS_EN :  1;               /*!< Enable USB2.0 Rx half input stage offset
                                                         Default setting value: 1'b1                                           */
      __IO uint32_t  CDR_SQU_EN :  1;               /*!< 1: CDR output gating (Default value)
                                                         0: Original                                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG_0x0018                                                            */
    
    struct {
      __IO uint32_t  LDO_EN     :  1;               /*!< Enable internal LDO for PLL.
                                                         Default setting value: 1'b1                                           */
      __IO uint32_t  SW         :  2;               /*!< PLL locking range control bit. Default= 01                            */
           uint32_t             :  2;
      __IO uint32_t  KVCO_SW    :  3;               /*!< PLL KVCO range options. Default = 100
                                                         TRIM used.                                                            */
      __IO uint32_t  BW_SW      :  3;               /*!< PLL bandwidth options. Default = 110
                                                         (For XTAL reference application. Default = 110)
                                                         (For LC reference application. Default = 001)
                                                         TRIM used.                                                            */
           uint32_t             : 13;
      __IO uint32_t  CKEN       :  1;               /*!< Add by SA3 for testing                                                */
      __IO uint32_t  PLL_EN     :  1;               /*!< PLL enable signal.                                                    */
      __IO uint32_t  PDN12B_192M:  1;               /*!< 192MHz clock function disable (CK_DIV2P5 = L).                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG_0x001C                                                            */
    
    struct {
      __IO uint32_t  SEL_PD     :  1;               /*!< Low Power flow selection signal. Default setting value: 1b0.          */
      __IO uint32_t  FW_SUSPENDM:  1;               /*!< add Control low power flow from FW register.
                                                         Default setting value: 1b1
                                                         (See the PHY Design Report has descript about Power sequence
                                                         flow)
                                                         0: control PCU sequence from FW control
                                                                                                                               */
      __IO uint32_t  ISOLATION  :  1;               /*!< FW control isolation cell control.
                                                         (See the PHY Design Report has descript about Power sequence
                                                         flow)
                                                         1: Enable Isolation cell.
                                                         0: Disable Isolation control
                                                                                                                               */
      __IO uint32_t  PHY_PWR    :  1;               /*!< USB PHY is Active indication for system wakeup event.                 */
      __IO uint32_t  RETEN_CTL  :  1;               /*!< FW control retension cell control. Low Active.
                                                         (See the PHY Design Report has descript about Power sequence
                                                         flow)
                                                         1: Normal.
                                                         0: Reset                                                              */
      __IO uint32_t  DPPULLDOWN :  1;               /*!< 1: Pulldown the PHYs DP register.                                     */
      __IO uint32_t  DMPULLDOWN :  1;               /*!< 1: Pulldown the PHYs DM register.                                     */
      __IO uint32_t  VBUS_VALID :  1;               /*!< 1: Indicate the vbus is active, only active for Device PHY.           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG_0x0020                                                            */
    
    struct {
      __IO uint32_t  FRA_IN     : 22;               /*!< 192MHz clock function disable (CK_DIV2P5 = L) 22h0
                                                         1 = Enable
                                                         0 = Disable
                                                         If host                                                               */
      __IO uint32_t  I_UPD_IN   :  1;               /*!< Toggle for INT or FRA update.                                         */
      __IO uint32_t  I_SEL_DIV  :  1;               /*!< Control PLL divide number from SDM control or FW control
                                                         1: FW control DIV value from INT_IN[5:0].
                                                         0: DIV value from SDM generation
                                                                                                                               */
      __IO uint32_t  INT_IN     :  6;               /*!< DM control signal.
                                                         From Firmware. Coarse tune bit. Default value: 6h28(if X'tal
                                                         12 Mhz)                                                               */
           uint32_t             :  1;
      __IO uint32_t  SDM_EN_IN  :  1;               /*!< SDM control signal.
                                                         From Firmware:
                                                          1: enable
                                                         0: use Default value                                                  */
    };
  };
} USB_PHY2_Type;


/* ================================================================================ */
/* ================                      EFUSE                     ================ */
/* ================================================================================ */


/**
  * @brief e-Fuse Control Register (EFUSE)
  */

typedef struct {                                    /*!< EFUSE Structure                                                       */
  __I  uint32_t  EFUSE_DO0;                         /*!< E-fuse data[31:0]                                                     */
  __I  uint32_t  EFUSE_DO1;                         /*!< E-fuse data[63:32]                                                    */
  __I  uint32_t  EFUSE_DO2;                         /*!< E-fuse data[95:64]                                                    */
  __I  uint32_t  EFUSE_DO3;                         /*!< E-fuse data[127:96]                                                   */
  __I  uint32_t  EFUSE_DO4;                         /*!< E-fuse data[159:128]                                                  */
  __I  uint32_t  EFUSE_DO5;                         /*!< E-fuse data[191:160]                                                  */
  __I  uint32_t  EFUSE_DO6;                         /*!< E-fuse data[223:192]                                                  */
  __I  uint32_t  EFUSE_DO7;                         /*!< E-fuse data[255:224]                                                  */
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< 9010_0020                                                             */
    
    struct {
      __IO uint32_t  EFUSE_FUNC_DIS:  1;            /*!< e-Fuse function disadble                                              */
      __IO uint32_t  EFUSE_EXT_MODE:  1;            /*!< e-Fuse CP test mode                                                   */
      __IO uint32_t  EFUSE_PGM_MODE:  1;            /*!< e-Fuse program mode                                                   */
      __O  uint32_t  EFUSE_RST  :  1;               /*!< High active, auto clear
                                                         When reset is active, the EFUSE_DO will be reloaded from EFUSE
                                                         IP.                                                                   */
           uint32_t             : 12;
      __O  uint32_t  EFUSE_PASSWD: 16;              /*!< e-Fuse read password                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< 9010_0024                                                             */
    
    struct {
      __IO uint32_t  EFUSE_CSB  :  1;               /*!< E-fuse control pin, Please refer to E-Fuse user guide.                */
      __IO uint32_t  EFUSE_PGM  :  1;               /*!< e-Fuse control pin, please refer to e-Fuse user guide                 */
      __IO uint32_t  EFUSE_SCLK :  1;               /*!< e-Fuse control pin, please refer to e-Fuse user guide                 */
      __IO uint32_t  EFUSE_WPROT:  1;               /*!< e-Fuse control pin, please refer to e-Fuse user guide                 */
    };
  };
} EFUSE_Type;


/* ================================================================================ */
/* ================                    RF_CTRL1                    ================ */
/* ================================================================================ */


/**
  * @brief RF SPI Control Register (RF_CTRL1)
  */

typedef struct {                                    /*!< RF_CTRL1 Structure                                                    */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SPI_MODE   :  1;               /*!< RF SPI mode                                                           */
      __IO uint32_t  OP_MODE    :  1;               /*!< OP Mode                                                               */
      __IO uint32_t  SPI_RX_PHASE:  1;              /*!< RF SPI Rx Edge                                                        */
           uint32_t             :  1;
      __IO uint32_t  SCLK_PO_PH :  2;               /*!< SCLK polarity and SCLK phase                                          */
           uint32_t             :  2;
      __IO uint32_t  SPI_SPEED  :  8;               /*!< RF SPI Speed                                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< 9011_0000                                                             */
    
    struct {
      __O  uint32_t  SPI_WR_TRG :  1;               /*!< RF SPI Wirte Trigger                                                  */
      __O  uint32_t  SPI_RD_TRG :  1;               /*!< RF SPI Read Trigger                                                   */
           uint32_t             :  2;
      __I  uint32_t  SPI_RW_RDY :  1;               /*!< Ready when read/wiret SPI                                             */
           uint32_t             :  3;
      __IO uint32_t  SPI_CS     :  1;               /*!< CS for SPI interface                                                  */
      __IO uint32_t  SPI_EXPIN  :  4;               /*!< External control pin for RF IC                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< 9011_0000                                                             */
    
    struct {
      __O  uint32_t  SPI_WR_DATA:  8;               /*!< Data for write to SPI interface                                       */
           uint32_t             :  8;
      __I  uint32_t  SPI_RD_DATA:  8;               /*!< Data read from SPI interface                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  RF_DMA_EN  :  1;               /*!< Enable RF DMA fuction in command queue mode                           */
      __IO uint32_t  CRC_EN     :  1;               /*!< Enable CRC16 check with each sub-packet                               */
           uint32_t             :  2;
      __IO uint32_t  SPI_CMD_NUM:  4;               /*!< The number of SPI command component                                   */
      __IO uint32_t  EXPIN_INI  :  4;               /*!< The initial value of external pin                                     */
           uint32_t             :  4;
      __IO uint32_t  CRC_POLY   : 16;               /*!< CRC16 polynomial                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< 9011_0000                                                             */
    
    struct {
      __O  uint32_t  CMD_TRG    :  1;               /*!< Write 1 to start the command queue's components                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< 9011_0000                                                             */
    
    struct {
      __I  uint32_t  RF_CMD_DWN :  1;               /*!< Command is run down                                                   */
      __O  uint32_t  RF_CMD_DWN_CLR:  1;            /*!< Write 1 to clear RF_CMD_DWN                                           */
           uint32_t             :  6;
      __I  uint32_t  SHD_CRC_RPT:  8;               /*!< Sonix header CRC report                                               */
      __I  uint32_t  SPKT_CRC_RPT0: 16;             /*!< Sub-packet CRC16 report                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< 9011_0000                                                             */
    
    struct {
      __I  uint32_t  SPKT_CRC_RPT1: 16;             /*!< Sonix header CRC report                                               */
      __I  uint32_t  SPKT_CRC_RPT2: 16;             /*!< Sub-packet CRC16 report                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< 9011_0000                                                             */
    
    struct {
      __I  uint32_t  SPKT_CRC_RPT3: 16;             /*!< Sonix header CRC report                                               */
      __I  uint32_t  SPKT_CRC_RPT4: 16;             /*!< Sub-packet CRC16 report                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< 9011_0000                                                             */
    
    struct {
      __I  uint32_t  SPKT_CRC_RPT5: 16;             /*!< Sonix header CRC report                                               */
      __I  uint32_t  SPKT_CRC_RPT6: 16;             /*!< Sub-packet CRC16 report                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< 9011_0000                                                             */
    
    struct {
      __I  uint32_t  SPKT_CRC_RPT7: 16;             /*!< Sonix header CRC report                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  TIME_UNIT  : 24;               /*!< Time tick unit                                                        */
    };
  };
  __I  uint32_t  RESERVED[5];
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP0   : 32;               /*!< Command component 0                                                   */
    };
  };
  __I  uint32_t  RESERVED1[3];
  
  union {
    __IO uint32_t  REG_0x0050;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP1   : 32;               /*!< Command component 1                                                   */
    };
  };
  __I  uint32_t  RESERVED2[3];
  
  union {
    __IO uint32_t  REG_0x0060;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP2   : 32;               /*!< Command component 2                                                   */
    };
  };
  __I  uint32_t  RESERVED3[3];
  
  union {
    __IO uint32_t  REG_0x0070;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP3   : 32;               /*!< Command component 3                                                   */
    };
  };
  __I  uint32_t  RESERVED4[3];
  
  union {
    __IO uint32_t  REG_0x0080;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP4   : 32;               /*!< Command component 4                                                   */
    };
  };
  __I  uint32_t  RESERVED5[3];
  
  union {
    __IO uint32_t  REG_0x0090;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP5   : 32;               /*!< Command component 5                                                   */
    };
  };
  __I  uint32_t  RESERVED6[3];
  
  union {
    __IO uint32_t  REG_0x00A0;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP6   : 32;               /*!< Command component 6                                                   */
    };
  };
  __I  uint32_t  RESERVED7[3];
  
  union {
    __IO uint32_t  REG_0x00B0;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  CMD_CMP7   : 32;               /*!< Command component 7                                                   */
    };
  };
  __I  uint32_t  RESERVED8[3];
  
  union {
    __IO uint32_t  REG_0x00C0;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD0  : 32;               /*!< Sonix Header data 0                                                   */
    };
  };
  __I  uint32_t  RESERVED9[7];
  
  union {
    __IO uint32_t  REG_0x00E0;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD1  : 32;               /*!< Sonix Header data 1                                                   */
    };
  };
  __I  uint32_t  RESERVED10[7];
  
  union {
    __IO uint32_t  REG_0x0100;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD2  : 32;               /*!< Sonix Header data 2                                                   */
    };
  };
  __I  uint32_t  RESERVED11[7];
  
  union {
    __IO uint32_t  REG_0x0120;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD3  : 32;               /*!< Sonix Header data 3                                                   */
    };
  };
  __I  uint32_t  RESERVED12[7];
  
  union {
    __IO uint32_t  REG_0x0140;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD4  : 32;               /*!< Sonix Header data 4                                                   */
    };
  };
  __I  uint32_t  RESERVED13[7];
  
  union {
    __IO uint32_t  REG_0x0160;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD5  : 32;               /*!< Sonix Header data 5                                                   */
    };
  };
  __I  uint32_t  RESERVED14[7];
  
  union {
    __IO uint32_t  REG_0x0180;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD6  : 32;               /*!< Sonix Header data 6                                                   */
    };
  };
  __I  uint32_t  RESERVED15[7];
  
  union {
    __IO uint32_t  REG_0x01A0;                      /*!< 9011_0000                                                             */
    
    struct {
      __IO uint32_t  SONIX_HD7  : 32;               /*!< Sonix Header data 7                                                   */
    };
  };
} RF_CTRL1_Type;


/* ================================================================================ */
/* ================                       SF                       ================ */
/* ================================================================================ */


/**
  * @brief Serial Flash (SF)
  */

typedef struct {                                    /*!< SF Structure                                                          */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG 0x0000                                                            */
    
    struct {
      __IO uint32_t  MS_MODE    :  3;               /*!< Mass storage mode select                                              */
      __IO uint32_t  MS_REG_RW  :  1;               /*!< Select CPU mode.(Read or Write)                                       */
      __IO uint32_t  MS_DMA_EN  :  1;               /*!< Enable DMA transfer                                                   */
      __IO uint32_t  MS_DMA_RW  :  1;               /*!< DMA mode select                                                       */
      __IO uint32_t  SF_PRAM_DMA:  1;               /*!< Serial Flash DMA switch to Program RAM                                */
      __IO uint32_t  ECC_EN     :  1;               /*!< CRC32 Enable for SF read/write data
                                                         Note: When ECC_EN=0, the CRC32 report will be clear.                  */
      __I  uint32_t  MS_RDY     :  1;               /*!< Mass storage ready flag                                               */
      __IO uint32_t  SF_CRC_CAL :  1;               /*!< 0: Means the CRC32 Code are not Calculated when MS_MODE=3b011.
                                                         1: Means the CRC32 Code are Calculated when MS_MODE=3b011.
                                                         Note: This value must be set to 0, when MS_DMA_EN=1.                  */
           uint32_t             :  1;
      __O  uint32_t  CMD_NIB_TRG:  1;               /*!< 1: Trigger to start the command nibble.                               */
           uint32_t             : 12;
      __IO uint32_t  MS_SPEED   :  8;               /*!< Speed selection for SF_CK. (Range:0~255)
                                                         Note:clock speed is SF_CLK/(SPEED+2) for SF_CK.                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG 0x0004                                                            */
    
    struct {
      __IO uint32_t  MS_DMA_SIZE: 17;               /*!< DMA transfer size. Transfer Length=(DMA_SIZE + 1) bytes.              */
      __IO uint32_t  SF_W_MODE  :  2;               /*!< Serial Flash Write Mode.
                                                         Note : When SF is in AA_W Mode, DMA_SIZE must be multiple of
                                                         2.                                                                    */
           uint32_t             :  5;
      __IO uint32_t  SF_CACHE_W_CMD:  8;            /*!< The Serial Flash Write data to page Command.                          */
    };
  };
  __I  uint32_t  CRC32;                             /*!< CRC32 for Serial Flash Data R/W CRC32 code.                           */
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG 0x000C                                                            */
    
    struct {
      __IO uint32_t  RC4_ACTIVE :  1;               /*!< Enable the RC4 HW Encode Engine.                                      */
      __IO uint32_t  RC4_S_SIZE :  2;               /*!< The RC4_S_SIZE.                                                       */
           uint32_t             :  5;
      __I  uint32_t  RC4_KEY    :  8;               /*!< The RC4 Encode Result.                                                */
    };
  };
  __IO uint32_t  RC4_SBOX0;                         /*!< RC4 SBox[31:0]                                                        */
  __IO uint32_t  RC4_SBOX1;                         /*!< RC4 SBox[63:32]                                                       */
  __IO uint32_t  RC4_SBOX2;                         /*!< RC4 SBox[95:64]                                                       */
  __IO uint32_t  RC4_SBOX3;                         /*!< RC4 SBox[127:96]                                                      */
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG 0x0020                                                            */
    
    struct {
      __IO uint32_t  SF_READ_DUMMY_BYTE:  4;        /*!< The Serial Flash/SPI Mode Nandflash DMA Read dummy byte.
                                                         Note: 0 means no dummy byte.                                          */
      __IO uint32_t  SF_WRITE_DUMMY_BYTE:  4;       /*!< The Serial Flash/SPI Mode Nandflash DMA Write dummy byte.
                                                         Note: 0 means no dummy byte.                                          */
      __IO uint32_t  SF_ADDR_CYC:  1;               /*!< Serial Flash address cycle.                                           */
           uint32_t             :  3;
      __IO uint32_t  SF_CMD_NIBBLE:  3;             /*!< Serial Flash command nibble.                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< REG 0x0024                                                            */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  SF_CACHE_R_CMD:  8;            /*!< The Serial Flash Read data from page command.                         */
           uint32_t             :  8;
      __IO uint32_t  SF_ERASE_CMD:  8;              /*!< The Serial Flash Erase Command.                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< REG 00028                                                             */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  SF_W_DIS_CMD:  8;              /*!< The Serial Flash Write disable Command.                               */
      __IO uint32_t  SF_W_EN_CMD:  8;               /*!< The Serial Flash Write enable Command.                                */
      __IO uint32_t  SF_STATUS_CMD:  8;             /*!< The Serial Flash Read Status Command.                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x002C;                      /*!< REG 0x002C                                                            */
    
    struct {
      __IO uint32_t  SCK_PHS_SEL:  3;               /*!< SCK phase delay for SF read.                                          */
           uint32_t             :  6;
      __IO uint32_t  SF_QPI_MODE:  1;               /*!< Enable Serial Flash QPI mode                                          */
      __IO uint32_t  NF_SF_4BITS:  1;               /*!< 0: Means the data transfer mode is 1bit mode.
                                                         1: Means the data transfer mode is 4bits mode.
                                                         Note : IF SF_W_MODE!=0, the NF_SF_4BITS should be 0 when perform
                                                         DMA Write Function.                                                   */
      __IO uint32_t  SF_DT_EN   :  1;               /*!< 0: Means the SF is in Single data Rate mode.
                                                         1: Means the SF is in Double data Rate mode.
                                                         Note : IF SF_W_MODE!=0, the SF_DT_EN should be 0 when perform
                                                         DMA Write Function.                                                   */
      __IO uint32_t  SF_DUMMY_EN:  1;               /*!< Enable SF dummy cycle (SF_DUMMY_CYC[2:0])                             */
           uint32_t             :  3;
      __IO uint32_t  SF_DUMMY_CYC:  3;              /*!< The SF Dummy Clock Cycle
                                                         Means the number of dummy clock Cycle.
                                                         Note: the number of dummy clock cycles is SF_DUMMY_CYC+1.             */
           uint32_t             :  5;
      __IO uint32_t  SF_WIP_ADDR:  3;               /*!< 0: Means the SF WIP (Write In Progress) Bit is in bit0 of one
                                                         byte.
                                                         1: Means the SF WIP (Write In Progress) Bit is in bit1 of one
                                                          byte.
                                                         ...etc...                                                             */
      __IO uint32_t  SF_WIP_INV :  1;               /*!< 1 means when SF WIP is 1, the SF is in Write in Progress.
                                                         0 means when SF WIP is 0, the SF is in Write in Progress.             */
    };
  };
  
  union {
    __I  uint32_t  MS_IO_I;                         /*!< Input data when MS_IO[5:0] is GPIO input mode.                        */
    
    struct {
      __I  uint32_t  MS_IO_I0   :  1;               /*!< MS_IO input 0                                                         */
      __I  uint32_t  MS_IO_I1   :  1;               /*!< MS_IO input 1                                                         */
      __I  uint32_t  MS_IO_I2   :  1;               /*!< MS_IO input 2                                                         */
      __I  uint32_t  MS_IO_I3   :  1;               /*!< MS_IO input 3                                                         */
      __I  uint32_t  MS_IO_I4   :  1;               /*!< MS_IO input 4                                                         */
      __I  uint32_t  MS_IO_I5   :  1;               /*!< MS_IO input 5                                                         */
    };
  };
  
  union {
    __IO uint32_t  MS_IO_O;                         /*!< Output data when MS_IO[5:0] is GPIO output mode                       */
    
    struct {
      __IO uint32_t  MS_IO_O0   :  1;               /*!< MS_IO output 0                                                        */
      __IO uint32_t  MS_IO_O1   :  1;               /*!< MS_IO output 1                                                        */
      __IO uint32_t  MS_IO_O2   :  1;               /*!< MS_IO output 2                                                        */
      __IO uint32_t  MS_IO_O3   :  1;               /*!< MS_IO output 3                                                        */
      __IO uint32_t  MS_IO_O4   :  1;               /*!< MS_IO output 4                                                        */
      __IO uint32_t  MS_IO_O5   :  1;               /*!< MS_IO output 5                                                        */
    };
  };
  
  union {
    __IO uint32_t  MS_IO_OE;                        /*!< Output Enable when MS_IO[5:0] is GPIO output mode                     */
    
    struct {
      __IO uint32_t  MS_IO_OE0  :  1;               /*!< MS_IO Output enable 0                                                 */
      __IO uint32_t  MS_IO_OE1  :  1;               /*!< MS_IO Output enable 1                                                 */
      __IO uint32_t  MS_IO_OE2  :  1;               /*!< MS_IO Output enable 2                                                 */
      __IO uint32_t  MS_IO_OE3  :  1;               /*!< MS_IO Output enable 3                                                 */
      __IO uint32_t  MS_IO_OE4  :  1;               /*!< MS_IO Output enable 4                                                 */
      __IO uint32_t  MS_IO_OE5  :  1;               /*!< MS_IO Output enable 5                                                 */
    };
  };
  __IO uint32_t  SPI_CMD;                           /*!< For Serial Flash Mode:
                                                         Serial Flash M_DMA start address.
                                                         If SF_ADDR_CYC = 0, Valid bits is SPI_CMD[23:0].
                                                         SF_ADDR_CYC = 1, Valid bits is SPI_CMD[31:0].                         */
  __IO uint32_t  CRC_POLY;                          /*!< The CRC32 Polynomial Parameter
                                                         Default CRC32 Polynomial is
                                                         x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0   */
  __IO uint8_t   CRC_ORDER;                         /*!< The CRC Order.
                                                         d31 means 32 order CRC Code
                                                         d15 means 16 order CRC Code.                                          */
  __I  uint8_t   RESERVED[3];
  
  union {
    __IO uint32_t  REG_0x0048;                      /*!< REG 0x0048                                                            */
    
    struct {
      __IO uint32_t  MS_DMA_BLOCK: 16;              /*!< DMA Block number at every Multiple DMA
                                                         DMA Block number = DMA_BLOCK + 1                                      */
      __I  uint32_t  MS_SU_DMA_BLOCK: 16;           /*!< Succeed DMA Block transfer number at every DMA.                       */
    };
  };
  __IO uint32_t  TIME_CNT;                          /*!< Time out counter up limit when M_DMA_EN=1:
                                                         Time is = clk_cycle * (TIME_CNT*4)                                    */
  
  union {
    __IO uint32_t  REG_0x0050;                      /*!< REG 0x0050                                                            */
    
    struct {
      __IO uint32_t  MS_M_DMA_EN:  1;               /*!< Enable Multiple DMA mode
                                                         Note:MS_M_DMA_EN will be effective only when MS_DMA_EN set to
                                                         1.                                                                    */
      __I  uint32_t  MS_M_DMA_OK:  1;               /*!< DMA finish without error                                              */
      __IO uint32_t  MS_M_DMA_TIME_OUT:  1;         /*!< Multiple DMA exit with time out
                                                         Note:Writing '1' to clear this flag                                   */
           uint32_t             :  5;
      __IO uint32_t  MS_RDY_INTR_EN:  1;            /*!< Enable MS RDY interrput. (For AHB)                                    */
      __IO uint32_t  MS_ERR_INTR_EN:  1;            /*!< Enable MS Error interrput. (For AHB)                                  */
           uint32_t             :  6;
      __I  uint32_t  MS_RDY_FLAG:  1;               /*!< Indicates that MS DMA is complete. (For AHB)                          */
      __I  uint32_t  MS_ERR_FLAG:  1;               /*!< Indicates that error occurs on AHB bus. (For AHB)                     */
           uint32_t             :  6;
      __O  uint32_t  CLR_MS_RDY :  1;               /*!< Clear MS_RDY_FLAG.
                                                         Note:Writing '1' to clear this flag.                                  */
      __O  uint32_t  CLR_MS_ERR :  1;               /*!< Clear MS_ERR_FLAG.
                                                         Note:Writing '1' to clear this flag.                                  */
    };
  };
  __I  uint32_t  RESERVED1[2];
  __IO uint32_t  MS_DMA_ADDR;                       /*!< MS DMA start address.
                                                         Note: Please set MS_DMA_ADDR[1:0]=0 to meet 4 byte alignment.         */
  __I  uint32_t  RESERVED2[4];
  __IO uint8_t   MS_REG0;                           /*!< Register%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SF:
                                                         9030_0074h: Data                                                      */
  __I  uint8_t   RESERVED3[3];
  __IO uint8_t   MS_REG1;                           /*!< Register%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SF:
                                                         9030_0074h: Data                                                      */
  __I  uint8_t   RESERVED4[3];
  __IO uint8_t   MS_REG2;                           /*!< Register%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SF:
                                                         9030_0074h: Data                                                      */
  __I  uint8_t   RESERVED5[3];
  __IO uint8_t   MS_REG3;                           /*!< Register%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SF:
                                                         9030_0074h: Data                                                      */
  __I  uint8_t   RESERVED6[3];
  __I  uint32_t  SF_FPGA_VERSION;                   /*!< Serial Flash FPGA Version
                                                         0xYYYYMMNN                                                            */
} SF_Type;


/* ================================================================================ */
/* ================                    SDIO_WIFI                   ================ */
/* ================================================================================ */


/**
  * @brief SDIO WIFI (SDIO_WIFI)
  */

typedef struct {                                    /*!< SDIO_WIFI Structure                                                   */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG:9031_0000                                                         */
    
    struct {
      __IO uint32_t  MS_MODE2   :  3;               /*!< Mass storage mode select                                              */
      __IO uint32_t  MS_REG_RW2 :  1;               /*!< Select CPU mode.(Read or Write)                                       */
      __IO uint32_t  MS_DMA_EN2 :  1;               /*!< Enable DMA transfer                                                   */
      __IO uint32_t  MS_DMA_RW2 :  1;               /*!< DMA mode select                                                       */
      __IO uint32_t  EXTRA_EN2  :  1;               /*!< Extral ECC DATA Enable when DMA transfer for NF.                      */
      __IO uint32_t  ECC_EN2    :  1;               /*!< CRC Enable for SD/SPI read/write data
                                                         Note:When SD/SPI mode, ECC_EN must be set '1'. When ECC_EN=0,
                                                         the ECC/CRC report will be clear.                                     */
      __I  uint32_t  MS_RDY2    :  1;               /*!< Mass storage ready flag                                               */
           uint32_t             :  3;
      __O  uint32_t  SPI_BUSY_TRG2:  1;             /*!< Trigger to polling the and of Busy for SD Card                        */
      __O  uint32_t  SPI_CMD_TRG2:  1;              /*!< Trigger to send command block                                         */
           uint32_t             :  8;
      __IO uint32_t  SD_READ_DATA_CMD2:  1;         /*!< Auto wait for SD read card status data ready.
                                                         Note:Used along with ACMD13,ACMD51, etc.                              */
           uint32_t             :  1;
      __IO uint32_t  MS_SPEED2  :  8;               /*!< Speed selection for SPI/SD(Range:0~255)
                                                         Note:clock speed is SF_CLK/(SPEED+2) for SPI/SD.                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG:9031_0004                                                         */
    
    struct {
      __IO uint32_t  MS_DMA_SIZE2: 12;              /*!< DMA_transfer size. Transfer Length=(DMA_SIZE + 1) bytes.Note:
                                                         Transfer length must be multiple of 16 bytes for 32bits AHB.          */
    };
  };
  
  union {
    __I  uint32_t  REG_0x0008;                      /*!< REG:9031_0008                                                         */
    
    struct {
      __I  uint32_t  CRC16_0    : 16;               /*!< For SD Card :
                                                         CRC16_0[15:0] for SPI/SD data.
                                                         CRC7[6:0] for SPI/SD command.
                                                         CRC7[6:0] for SPI/SD Response.
                                                         For Serial Flash :
                                                         CRC16_0[15:0] for Serial Flash Data R/W CRC16 Code.                   */
      __I  uint32_t  CMD_CRC7   :  7;               /*!< Command CRC                                                           */
    };
  };
  __I  uint32_t  REG_0x000C;                        /*!< CRC16_1[15:0] for SPI/SD data.                                        */
  
  union {
    __I  uint32_t  REG_0x0010;                      /*!< REG:9031_0010                                                         */
    
    struct {
      __I  uint32_t  CRC16_2    : 16;               /*!< CRC16_2[15:0] for Serial Flash Data R/W CRC16 Code.                   */
      __I  uint32_t  CRC16_3    : 16;               /*!< CRC16_3[15:0] for Serial Flash Data R/W CRC16 Code.                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG:9031_0014                                                         */
    
    struct {
      __IO uint32_t  SDIO_EN    :  1;               /*!< Enable SDIO function
                                                         Note:SPI_Mode or SD_MODE is Decided by MS_MODE2[1:0]                  */
      __IO uint32_t  SDIO_RD_WAIT_EN:  1;           /*!< Enable SDIO Read Wait function                                        */
      __IO uint32_t  SDIO_INT_EN:  1;               /*!< Enable SDIO Interrupt function                                        */
      __I  uint32_t  SDIO_INT_FLAG:  1;             /*!< SDIO interrupt flag                                                   */
      __O  uint32_t  SDIO_INT_CLR:  1;              /*!< Clear SDIO interrupt flag
                                                         Note:Writing '1' to clear SDIO_INT_FLAG                               */
      __I  uint32_t  SDIO_RD_WAIT_MS_RDY:  1;       /*!< When You use SDIO RD_WAIT_EN Fucntion,
                                                         You must detect this flag to check if the MS_RDY is ready to
                                                         Trigger CMD or not.                                                   */
           uint32_t             :  2;
      __IO uint32_t  SDIO_FUNC  :  3;               /*!< The SDIO Function Number, used in SDIO CMD53,
                                                         Note:Used in CMD53, I/O_RW_Extended Command Argument.
                                                          When SDIO host want to use Multi-DMA Function to transfer
                                                          data to SDIO Card.                                                   */
           uint32_t             :  1;
      __IO uint32_t  SDIO_OP_CODE:  1;              /*!< The SDIO OP_CODE, used in SDIO CMD53,
                                                         Note:Used in CMD53, I/O_RW_Extended Command Argument.
                                                          When SDIO host want to use Multi-DMA Function to transfer
                                                          data to SDIO Card.                                                   */
      __IO uint32_t  SDIO_BLK_CODE:  1;             /*!< The SDIO_BLK_MODE, used in SDIO CMD53,
                                                         Note:Used in CMD53, I/O_RW_Extended Command Argument.
                                                          When SDIO host want to use Multi-DMA Function to transfer
                                                          data to SDIO Card.                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG:9031_0018                                                         */
    
    struct {
      __IO uint32_t  SDIO_REG_ADDR: 17;             /*!< The SDIO Register Address, used in SDIO CMD53,
                                                         Note:Used in CMD53, I/O_RW_Extended Command Argument.
                                                          When SDIO host want to use Multi-DMA Function to transfer
                                                          data to SDIO Card.                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG:9031_001C                                                         */
    
    struct {
      __IO uint32_t  RC4_ACTIVE :  1;               /*!< Enable the RC4 HW Encode Engine.                                      */
      __IO uint32_t  RC4_S_SIZE :  2;               /*!< The RC4_S_SIZE.                                                       */
           uint32_t             :  5;
      __I  uint32_t  RC4_KEY    :  8;               /*!< The RC4 Encode Result.                                                */
    };
  };
  __IO uint32_t  RC4_SBOX0;                         /*!< RC4 SBox[31:0]                                                        */
  __IO uint32_t  RC4_SBOX1;                         /*!< RC4 SBox[63:32]                                                       */
  __IO uint32_t  RC4_SBOX2;                         /*!< RC4 SBox[95:64]                                                       */
  __IO uint32_t  RC4_SBOX3;                         /*!< RC4 SBox[127:96]                                                      */
  
  union {
    __I  uint32_t  MS_IO_I2;                        /*!< Input data when MS_IO[7:0] is GPIO input mode.                        */
    
    struct {
      __I  uint32_t  MS_IO_I2_0 :  1;               /*!< MS_IO input 0                                                         */
      __I  uint32_t  MS_IO_I2_1 :  1;               /*!< MS_IO input 1                                                         */
      __I  uint32_t  MS_IO_I2_2 :  1;               /*!< MS_IO input 2                                                         */
      __I  uint32_t  MS_IO_I2_3 :  1;               /*!< MS_IO input 3                                                         */
      __I  uint32_t  MS_IO_I2_4 :  1;               /*!< MS_IO input 4                                                         */
      __I  uint32_t  MS_IO_I2_5 :  1;               /*!< MS_IO input 5                                                         */
      __I  uint32_t  MS_IO_I2_6 :  1;               /*!< MS_IO input 6                                                         */
      __I  uint32_t  MS_IO_I2_7 :  1;               /*!< MS_IO input 7                                                         */
    };
  };
  
  union {
    __IO uint32_t  MS_IO_O2;                        /*!< Output data when MS_IO[7:0] is GPIO output mode                       */
    
    struct {
      __IO uint32_t  MS_IO_O2_0 :  1;               /*!< MS_IO output 0                                                        */
      __IO uint32_t  MS_IO_O2_1 :  1;               /*!< MS_IO output 1                                                        */
      __IO uint32_t  MS_IO_O2_2 :  1;               /*!< MS_IO output 2                                                        */
      __IO uint32_t  MS_IO_O2_3 :  1;               /*!< MS_IO output 3                                                        */
      __IO uint32_t  MS_IO_O2_4 :  1;               /*!< MS_IO output 4                                                        */
      __IO uint32_t  MS_IO_O2_5 :  1;               /*!< MS_IO output 5                                                        */
      __IO uint32_t  MS_IO_O2_6 :  1;               /*!< MS_IO output 6                                                        */
      __IO uint32_t  MS_IO_O2_7 :  1;               /*!< MS_IO output 7                                                        */
    };
  };
  
  union {
    __IO uint32_t  MS_IO_OE2;                       /*!< Output Enable when MS_IO[7:0] is GPIO output mode                     */
    
    struct {
      __IO uint32_t  MS_IO_OE2_0:  1;               /*!< MS_IO Output enable 0                                                 */
      __IO uint32_t  MS_IO_OE2_1:  1;               /*!< MS_IO Output enable 1                                                 */
      __IO uint32_t  MS_IO_OE2_2:  1;               /*!< MS_IO Output enable 2                                                 */
      __IO uint32_t  MS_IO_OE2_3:  1;               /*!< MS_IO Output enable 3                                                 */
      __IO uint32_t  MS_IO_OE2_4:  1;               /*!< MS_IO Output enable 4                                                 */
      __IO uint32_t  MS_IO_OE2_5:  1;               /*!< MS_IO Output enable 5                                                 */
      __IO uint32_t  MS_IO_OE2_6:  1;               /*!< MS_IO Output enable 6                                                 */
      __IO uint32_t  MS_IO_OE2_7:  1;               /*!< MS_IO Output enable 7                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x003C;                      /*!< REG:9031_003C                                                         */
    
    struct {
      __IO uint32_t  SPI_CMD2   : 32;               /*!< * SPI or SD Mode:
                                                         Write -> Write COMMAND[31:0] for SPI/SD command token.
                                                         Read -> Read Response 1~4 for SPI/SD command token.
                                                                                                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< REG:9031_0040                                                         */
    
    struct {
      __IO uint32_t  SPI_INDEX2 :  8;               /*!< * SPI or SD Mode:
                                                         Write -> Write Index[7:0] for SPI/SD command token.
                                                         Read -> Read Response 0 for SPI/SD command token.                     */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  REG_0x0048;                      /*!< REG:9031_0048                                                         */
    
    struct {
      __IO uint32_t  MS_DMA_BLOCK2: 16;             /*!< DMA Block number at every Multiple DMA
                                                         DMA Block number = DMA_BLOCK + 1                                      */
      __I  uint32_t  MS_SU_DMA_BLOCK2: 16;          /*!< Succeed DMA Block transfer number at every DMA.                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x004C;                      /*!< REG:9031_004C                                                         */
    
    struct {
      __IO uint32_t  TIME_CNT2  : 30;               /*!< Time out counter up limit when M_DMA_EN=1:
                                                         Time is = clk_cycle * (TIME_CNT*4)                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0050;                      /*!< REG:9031_0050                                                         */
    
    struct {
      __IO uint32_t  MS_M_DMA_EN2:  1;              /*!< Enable Multiple DMA mode
                                                         Note:MS_M_DMA_EN will be effective only when MS_DMA_EN set to
                                                         1.                                                                    */
      __I  uint32_t  MS_M_DMA_OK2:  1;              /*!< DMA finish without error                                              */
      __I  uint32_t  MS_M_DMA_TIME_OUT2:  1;        /*!< Multiple DMA exit with time out
                                                         Note:Writing CLR_MS_M_DMA_TIME_OUT2='1' to clear this flag            */
           uint32_t             :  3;
      __I  uint32_t  CRC_W_ERR2 :  1;               /*!< For SD Card:
                                                         Write data block response error.
                                                         Note:Writing CLR_CRC_W_ERR2='1' to clear this flag                    */
      __I  uint32_t  ECC_ERR2   :  1;               /*!< 1:ECC error correct has error after DMA transfer or CRC16 error
                                                         in SPI/SD.                                                            */
      __IO uint32_t  MS_RDY_INTR_EN2:  1;           /*!< Enable MS RDY interrput                                               */
      __IO uint32_t  MS_ERR_INTR_EN2:  1;           /*!< Enable MS Error interrput                                             */
      __IO uint32_t  MS_ECC_ERR_INTR_EN2:  1;       /*!< Enable MS ECC Error interrput                                         */
      __IO uint32_t  SD_DETECT_INTR_EN:  1;         /*!< Enable SD_DETECT interrupt                                            */
           uint32_t             :  4;
      __I  uint32_t  MS_RDY_FLAG2:  1;              /*!< Indicates that MS DMA is complete. (For AHB)                          */
      __I  uint32_t  MS_ERR_FLAG2:  1;              /*!< Indicates that error occurs on AHB bus. (For AHB)                     */
      __I  uint32_t  MS_ECC_ERR_FLAG2:  1;          /*!< Indicates that ECC error occurs on SD Card.                           */
      __I  uint32_t  SD_DETECT_FLAG:  1;            /*!< Indicates that SD Card Detect Signal occurs on SD Card.               */
           uint32_t             :  4;
      __O  uint32_t  CLR_MS_RDY2:  1;               /*!< Clear MS_RDY_FLAG.
                                                         Note:Writing '1' to clear this flag.                                  */
      __O  uint32_t  CLR_MS_ERR2:  1;               /*!< Clear MS_ERR_FLAG.
                                                         Note:Writing '1' to clear this flag.                                  */
      __O  uint32_t  CLR_MS_ECC_ERR2:  1;           /*!< Clear MS_ERR_ECC_FLAG.
                                                         Note:Writing '1' to clear this flag.                                  */
      __O  uint32_t  CLR_SD_DETECT:  1;             /*!< Clear SD Detect.
                                                         Note:Writing '1' to clear this flag.                                  */
      __O  uint32_t  CLR_MS_M_DMA_TIME_OUT2:  1;    /*!< Clear MS_M_DMA_TIME_OUT2.
                                                         Note: Writing '1' to clear this flag.                                 */
      __O  uint32_t  CLR_CRC_W_ERR2:  1;            /*!< Clear CRC_W_ERR2.
                                                         Note: Writing '1' to clear this flag.                                 */
    };
  };
  
  union {
    __IO uint32_t  LBA_W;                           /*!< For SD Card:Response byte number mode                                 */
    
    struct {
           uint32_t             :  9;
      __IO uint32_t  LBA_W_NUM  :  4;               /*!< Response byte number when manual mode for SPI/SD.(Range: 1~5)         */
      __IO uint32_t  LBA_W_MODE :  1;               /*!< Response byte number mode for SPI/SD                                  */
    };
  };
  __I  uint32_t  RESERVED1;
  
  union {
    __IO uint32_t  REG_0x005C;                      /*!< REG:9031_005C                                                         */
    
    struct {
      __IO uint32_t  MS_DMA_ADDR2: 32;              /*!< MS DMA start address.
                                                         Note:Please set MS_DMA_ADDR[1:0]=0 to meet 4 byte alignment           */
    };
  };
  __I  uint32_t  RESERVED2[4];
  __IO uint32_t  MS_REG2_0;                         /*!< Register2%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SPI/SD:
                                                         4000_9070h : 1 byte Command (MS REG write mode)
                                                         1 byte Response (MS REG read mode)
                                                         (dummy write before read response)
                                                         4000_9074h : Data
                                                         4000_9078h : 8 dummy clock (MS REG write mode)
                                                          80 dummy clock (MS REG read mode)
                                                         SD:
                                                         4000_907ch : 5 byte read response to SPI_CMD(MS REG write mode)
                                                          Trigger to read CRC Status(MS REG                                    */
  __IO uint32_t  MS_REG2_1;                         /*!< Register2%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SPI/SD:
                                                         4000_9070h : 1 byte Command (MS REG write mode)
                                                         1 byte Response (MS REG read mode)
                                                         (dummy write before read response)
                                                         4000_9074h : Data
                                                         4000_9078h : 8 dummy clock (MS REG write mode)
                                                          80 dummy clock (MS REG read mode)
                                                         SD:
                                                         4000_907ch : 5 byte read response to SPI_CMD(MS REG write mode)
                                                          Trigger to read CRC Status(MS REG                                    */
  __IO uint32_t  MS_REG2_2;                         /*!< Register2%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SPI/SD:
                                                         4000_9070h : 1 byte Command (MS REG write mode)
                                                         1 byte Response (MS REG read mode)
                                                         (dummy write before read response)
                                                         4000_9074h : Data
                                                         4000_9078h : 8 dummy clock (MS REG write mode)
                                                          80 dummy clock (MS REG read mode)
                                                         SD:
                                                         4000_907ch : 5 byte read response to SPI_CMD(MS REG write mode)
                                                          Trigger to read CRC Status(MS REG                                    */
  __IO uint32_t  MS_REG2_3;                         /*!< Register2%s for Mass storage
                                                         Write: Trigger to read/write data for mass-storage.
                                                         Read: Read the data which come from mass-storage.
                                                         Note: Address for F/W access mass-storage register.
                                                         SPI/SD:
                                                         4000_9070h : 1 byte Command (MS REG write mode)
                                                         1 byte Response (MS REG read mode)
                                                         (dummy write before read response)
                                                         4000_9074h : Data
                                                         4000_9078h : 8 dummy clock (MS REG write mode)
                                                          80 dummy clock (MS REG read mode)
                                                         SD:
                                                         4000_907ch : 5 byte read response to SPI_CMD(MS REG write mode)
                                                          Trigger to read CRC Status(MS REG                                    */
  __I  uint32_t  MS2_VERSION;                       /*!< REG:MS2_FPGA_VERSION                                                  */
} SDIO_WIFI_Type;


/* ================================================================================ */
/* ================                       CRC                      ================ */
/* ================================================================================ */


/**
  * @brief CRC function. (CRC)
  */

typedef struct {                                    /*!< CRC Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x90210000                                                        */
    
    struct {
      __IO uint32_t  CRC_MODE   :  1;               /*!< CRC mode select                                                       */
           uint32_t             :  3;
      __IO uint32_t  CRC_EN     :  1;               /*!< CRC enable                                                            */
           uint32_t             :  3;
      __I  uint32_t  CRC_EN_RDY :  1;               /*!< Ready for enable CRC check.
                                                         Note: Before enable CRC please must check this bit.                   */
      __I  uint32_t  CRC_OK     :  1;               /*!< CRC is finish.                                                        */
    };
  };
  __IO uint32_t  CRC_STR_RA;                        /*!< Read start address for CRC read DRAM (Unit: 1 byte)                   */
  __IO uint32_t  CRC_R_LINE_SIZE;                   /*!< Line size for DRAM CRC read (Unit: 1 byte)                            */
  __IO uint32_t  CRC_R_LINE_NUM;                    /*!< Line number for DRAM CRC read (Unit: 1 line)                          */
  __IO uint32_t  CRC_R_LINE_GAP;                    /*!< Line gap for DRAM CRC read (Unit: 1 byte)                             */
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_0x90210014                                                        */
    
    struct {
      __IO uint32_t  CRC_INIT   :  1;               /*!< CRC initial value                                                     */
      __IO uint32_t  CRC_XOR    :  1;               /*!< CRC output XOR value                                                  */
           uint32_t             :  2;
      __IO uint32_t  CRC_ORDER  :  5;               /*!< CRC order.
                                                         0: CRC order = 1.
                                                         1: CRC order = 2.
                                                         ...
                                                         31: CRC order = 32.                                                   */
    };
  };
  __IO uint32_t  CRC_POLY;                          /*!< CRC polynomial                                                        */
  __I  uint32_t  CRC_CHK_SUM;                       /*!< CRC and check sum.
                                                         ENC_MODE = 2, CRC_CHECK_SUM[31:0] = CRC.
                                                         ENC_MODE = 3, CRC_CHECK_SUM[31:0] = check sum.                        */
} CRC_Type;


/* ================================================================================ */
/* ================                     ENC_DMA                    ================ */
/* ================================================================================ */


/**
  * @brief Encryption/Decryption and DMA (ENC_DMA)
  */

typedef struct {                                    /*!< ENC_DMA Structure                                                     */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x0000                                                            */
    
    struct {
      __IO uint32_t  DMA_MODE   :  3;               /*!< DMA mode select                                                       */
           uint32_t             :  1;
      __IO uint32_t  DMA_EN     :  1;               /*!< DMA access DRAM                                                       */
           uint32_t             :  3;
      __I  uint32_t  DMA_EN_RDY :  1;               /*!< Ready for enable DMA transfer Note: Before enable DMA, please
                                                         must check this bit                                                   */
      __I  uint32_t  DMA_R_OK   :  1;               /*!< OK for SRAM DMA /DRAM DMA read DRAM                                   */
      __I  uint32_t  DMA_W_OK   :  1;               /*!< OK for SRAM DMA /DRAM DMA write DRAM Note : When DRAM DMA mode,
                                                         DMA_R_OK equals DMA_W_OK                                              */
    };
  };
  __IO uint32_t  DMA_STR_RA;                        /*!< 9020_0004 (Read start address for DMA read DRAM (Unit: 1 byte))       */
  __IO uint32_t  DMA_STR_WA;                        /*!< 9020_0008 (Write start address for DMA write DRAM (Unit: 1 byte))     */
  __I  uint32_t  RESERVED;
  __IO uint32_t  DMA_R_LINE_SIZE;                   /*!< 9020_0010 (Line size for DRAM DMA read (Unit: 1 byte)
                                                          Note: Please set DMA_R_LINE_SIZE[12:0] to '1FFF' when read
                                                         source is sequence to get better performance)                         */
  __IO uint32_t  DMA_R_LINE_NUM;                    /*!< 9020_0014 (Line number for DRAM DMA (Unit: 1 line))                   */
  __IO uint32_t  DMA_R_LINE_GAP;                    /*!< 9020_0018 (Line gap for DRAM DMA read(Unit: 1 byte))                  */
  __IO uint32_t  DMA_W_LINE_SIZE;                   /*!< 9020_001C (DRAM DMA mode ~ Line size for DRAM DMA write SRAM
                                                         DMA mode ~ Total transfer size for SRAM DMA,this value must
                                                          be multiple of 4. AES DMA mode ~ Total transfer size write to
                                                          DRAM (Unit: 1 byte))                                                 */
  __IO uint32_t  DMA_W_LINE_NUM;                    /*!< 9020_0020 (Line number for DRAM DMA (Unit: 1 line))                   */
  __IO uint32_t  DMA_W_LINE_GAP;                    /*!< 9020_0024 (Line gap for DRAM DMA write (Unit: 1 byte))                */
  __I  uint32_t  RESERVED1[6];
  
  union {
    __IO uint16_t  REG_0x0040;                      /*!< REG_0x0040                                                            */
    
    struct {
      __IO uint16_t  AES_DES_FUNC:  4;              /*!< Encryption/Decryption AES/DES/3DES function                           */
      __IO uint16_t  AES_DES_MODE:  2;              /*!< Encryption/Decryption AES/DES/3DES mode                               */
      __IO uint16_t  AES_DES_BIT:  2;               /*!< Encryption/Decryption AES /DES/3DES bit number.
                                                         AES CFB/OFB mode bit number.
                                                         0: 128 bit operation.
                                                         1: 8 bit operation.
                                                         2: 1 bit operation.
                                                         DES/3DES CFB/OFB mode bit number.
                                                         0: 64 bit operation.
                                                         1: 8 bit operation.
                                                         2: 1 bit operation.
                                                                                                                               */
      __IO uint16_t  KEY_LEN    :  2;               /*!< AES key length select                                                 */
      __IO uint16_t  KEY_GEN    :  1;               /*!< The key generation process costs 13 CPU cycles.
                                                         After set, this bit is auto-cleared when the key generation
                                                         is finished.
                                                         Note:Key_GEN must in encoder mode.                                    */
      __IO uint16_t  UPDATE_IV  :  1;               /*!< Update initial vector control.
                                                         'UPDATE_IV' must be set high when new IV input.                       */
      __IO uint16_t  ENC_MODE   :  2;               /*!< Encryption/Decryption mode                                            */
      __IO uint16_t  PLAIN_BR   :  1;               /*!< Plaintext byte reverse                                                */
      __IO uint16_t  CIPHER_BR  :  1;               /*!< Ciphertext byte reverse                                               */
    };
  };
  __I  uint16_t  RESERVED2;
  __IO uint32_t  IV0;                               /*!< AES/DES/3DES initial vector 0                                         */
  __IO uint32_t  IV1;                               /*!< AES/DES/3DES initial vector 1                                         */
  __IO uint32_t  IV2;                               /*!< AES initial vector 2                                                  */
  __IO uint32_t  IV3;                               /*!< AES initial vector 3                                                  */
  __IO uint32_t  KEY_IN0;                           /*!< AES key input [31:0] or DES key in0[31:0]                             */
  __IO uint32_t  KEY_IN1;                           /*!< AES key input [63:32] or DES key in0[63:32]                           */
  __IO uint32_t  KEY_IN2;                           /*!< REG_0x005C                                                            */
  __IO uint32_t  KEY_IN3;                           /*!< AES key input [127:96] or DES key in1[63:32]                          */
  __IO uint32_t  KEY_IN4;                           /*!< AES key input [159:128] or DES key in2[31:0]                          */
  __IO uint32_t  KEY_IN5;                           /*!< AES key input [191:160] or DES key in2[63:32]                         */
  __IO uint32_t  KEY_IN6;                           /*!< AES key input [223:192]                                               */
  __IO uint32_t  KEY_IN7;                           /*!< AES key input [255:224]                                               */
  __I  uint32_t  KEY_OUT0;                          /*!< AES key output [31:0]                                                 */
  __I  uint32_t  KEY_OUT1;                          /*!< AES key output [63:32]                                                */
  __I  uint32_t  KEY_OUT2;                          /*!< AES key output [95:64]                                                */
  __I  uint32_t  KEY_OUT3;                          /*!< AES key output [127:96]                                               */
  __I  uint32_t  KEY_OUT4;                          /*!< AES key output [159:128]                                              */
  __I  uint32_t  KEY_OUT5;                          /*!< AES key output [191:160]                                              */
  __I  uint32_t  KEY_OUT6;                          /*!< AES key output [223:192]                                              */
  __I  uint32_t  KEY_OUT7;                          /*!< AES key output [255:224]                                              */
  
  union {
    __IO uint8_t   REG_0x0094;                      /*!< REG_0x0094                                                            */
    
    struct {
      __IO uint8_t   RC4_S_SIZE :  2;               /*!< RC4 SBOX size                                                         */
    };
  };
  __I  uint8_t   RESERVED3[3];
  
  union {
    __IO uint32_t  REG_0x0098;                      /*!< REG_0x0098                                                            */
    
    struct {
      __IO uint32_t  RC4_SBOX0  :  8;               /*!< RC4 SBOX0 initial value                                               */
      __IO uint32_t  RC4_SBOX1  :  8;               /*!< RC4 SBOX1 initial value                                               */
      __IO uint32_t  RC4_SBOX2  :  8;               /*!< RC4 SBOX2 initial value                                               */
      __IO uint32_t  RC4_SBOX3  :  8;               /*!< RC4 SBOX3 initial value                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x009C;                      /*!< REG_0x009C                                                            */
    
    struct {
      __IO uint32_t  RC4_SBOX4  :  8;               /*!< RC4 SBOX4 initial value                                               */
      __IO uint32_t  RC4_SBOX5  :  8;               /*!< RC4 SBOX5 initial value                                               */
      __IO uint32_t  RC4_SBOX6  :  8;               /*!< RC4 SBOX6 initial value                                               */
      __IO uint32_t  RC4_SBOX7  :  8;               /*!< RC4 SBOX7 initial value                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A0;                      /*!< REG_0x00A0                                                            */
    
    struct {
      __IO uint32_t  RC4_SBOX8  :  8;               /*!< RC4 SBOX8 initial value                                               */
      __IO uint32_t  RC4_SBOX9  :  8;               /*!< RC4 SBOX9 initial value                                               */
      __IO uint32_t  RC4_SBOX10 :  8;               /*!< RC4 SBOX10 initial value                                              */
      __IO uint32_t  RC4_SBOX11 :  8;               /*!< RC4 SBOX11 initial value                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A4;                      /*!< REG_0x00A4                                                            */
    
    struct {
      __IO uint32_t  RC4_SBOX12 :  8;               /*!< RC4 SBOX12 initial value                                              */
      __IO uint32_t  RC4_SBOX13 :  8;               /*!< RC4 SBOX13 initial value                                              */
      __IO uint32_t  RC4_SBOX14 :  8;               /*!< RC4 SBOX14 initial value                                              */
      __IO uint32_t  RC4_SBOX15 :  8;               /*!< RC4 SBOX15 initial value                                              */
    };
  };
  
  union {
    __IO uint16_t  REG_0x00A8;                      /*!< REG_0x00A8                                                            */
    
    struct {
      __IO uint16_t  CRC_INIT   :  1;               /*!< CRC initial value                                                     */
      __IO uint16_t  CRC_XOR    :  1;               /*!< CRC output XOR value                                                  */
           uint16_t             :  2;
      __IO uint16_t  CRC_ORDER  :  5;               /*!< CRC ORDER
                                                         CRC ORDER = CRC ORDER[4:0] + 1                                        */
    };
  };
  __I  uint16_t  RESERVED4;
  __IO uint32_t  CRC_POLY;                          /*!< CRC polynomial
                                                         Ex :P(x)=1+X^5+X^12+X^16 and CRC_POLY= 16'h8408                       */
  __I  uint32_t  CRC_CHK_SUM;                       /*!< CRC and check sum
                                                         ENC_MODE = 2, CRC_CHK_SUM[31:0] = CRC
                                                         ENC_MODE = 3, CRC_CHK_SUM[15:0] = check sum                           */
} ENC_DMA_Type;


/* ================================================================================ */
/* ================                       PWM                      ================ */
/* ================================================================================ */


/**
  * @brief PWM Controller (PWM)
  */

typedef struct {                                    /*!< PWM Structure                                                         */
  
  union {
    __IO uint32_t  PWM_EN;                          /*!< PWM EN[15:0]                                                          */
    
    struct {
      __IO uint32_t  PWM_EN0    :  1;               /*!< PWM_EN0                                                               */
      __IO uint32_t  PWM_EN1    :  1;               /*!< PWM EN1                                                               */
      __IO uint32_t  PWM_EN2    :  1;               /*!< PWM EN2                                                               */
      __IO uint32_t  PWM_EN3    :  1;               /*!< PWM EN3                                                               */
      __IO uint32_t  PWM_EN4    :  1;               /*!< PWM EN4                                                               */
      __IO uint32_t  PWM_EN5    :  1;               /*!< PWM EN5                                                               */
      __IO uint32_t  PWM_EN6    :  1;               /*!< PWM EN6                                                               */
      __IO uint32_t  PWM_EN7    :  1;               /*!< PWM EN7                                                               */
      __IO uint32_t  PWM_EN8    :  1;               /*!< PWM EN8                                                               */
      __IO uint32_t  PWM_EN9    :  1;               /*!< PWM EN9                                                               */
      __IO uint32_t  PWM_EN10   :  1;               /*!< PWM EN10                                                              */
      __IO uint32_t  PWM_EN11   :  1;               /*!< PWM EN11                                                              */
      __IO uint32_t  PWM_EN12   :  1;               /*!< PWM EN12                                                              */
      __IO uint32_t  PWM_EN13   :  1;               /*!< PWM EN13                                                              */
      __IO uint32_t  PWM_EN14   :  1;               /*!< PWM EN14                                                              */
      __IO uint32_t  PWM_EN15   :  1;               /*!< PWM EN15                                                              */
      __I  uint32_t  PWM_RDY    : 16;               /*!< PWM_RDY[15:0]                                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0004                                                              */
    
    struct {
      __IO uint32_t  PWM0_PERIOD: 13;               /*!< PWM0 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM0_HIGH_CNT: 13;             /*!< PWM0 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< REG_0008                                                              */
    
    struct {
      __IO uint32_t  PWM1_PERIOD: 13;               /*!< PWM1 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM1_HIGH_CNT: 13;             /*!< PWM1 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG_000C                                                              */
    
    struct {
      __IO uint32_t  PWM2_PERIOD: 13;               /*!< PWM2 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM2_HIGH_CNT: 13;             /*!< PWM2 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG_0010                                                              */
    
    struct {
      __IO uint32_t  PWM3_PERIOD: 13;               /*!< PWM3 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM3_HIGH_CNT: 13;             /*!< PWM3 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_0014                                                              */
    
    struct {
      __IO uint32_t  PWM4_PERIOD: 13;               /*!< PWM4 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM4_HIGH_CNT: 13;             /*!< PWM4 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG_0018                                                              */
    
    struct {
      __IO uint32_t  PWM5_PERIOD: 13;               /*!< PWM5 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM5_HIGH_CNT: 13;             /*!< PWM5 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG_001C                                                              */
    
    struct {
      __IO uint32_t  PWM6_PERIOD: 13;               /*!< PWM6 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM6_HIGH_CNT: 13;             /*!< PWM6 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG_0020                                                              */
    
    struct {
      __IO uint32_t  PWM7_PERIOD: 13;               /*!< PWM7 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM7_HIGH_CNT: 13;             /*!< PWM7 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< REG_0024                                                              */
    
    struct {
      __IO uint32_t  PWM8_PERIOD: 13;               /*!< PWM8 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM8_HIGH_CNT: 13;             /*!< PWM8 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< REG_0028                                                              */
    
    struct {
      __IO uint32_t  PWM9_PERIOD: 13;               /*!< PWM9 PERIOD [12:0]                                                    */
           uint32_t             :  3;
      __IO uint32_t  PWM9_HIGH_CNT: 13;             /*!< PWM9 HIGH CNT [12:0]                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x002C;                      /*!< REG_002C                                                              */
    
    struct {
      __IO uint32_t  PWM10_PERIOD: 13;              /*!< PWM10 PERIOD [12:0]                                                   */
           uint32_t             :  3;
      __IO uint32_t  PWM10_HIGH_CNT: 13;            /*!< PWM10 HIGH CNT [12:0]                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< REG_0030                                                              */
    
    struct {
      __IO uint32_t  PWM11_PERIOD: 13;              /*!< PWM11 PERIOD [12:0]                                                   */
           uint32_t             :  3;
      __IO uint32_t  PWM11_HIGH_CNT: 13;            /*!< PWM11 HIGH CNT [12:0]                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< REG_0034                                                              */
    
    struct {
      __IO uint32_t  PWM12_PERIOD: 13;              /*!< PWM12 PERIOD [12:0]                                                   */
           uint32_t             :  3;
      __IO uint32_t  PWM12_HIGH_CNT: 13;            /*!< PWM12 HIGH CNT [12:0]                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0038;                      /*!< REG_0038                                                              */
    
    struct {
      __IO uint32_t  PWM13_PERIOD: 13;              /*!< PWM13 PERIOD [12:0]                                                   */
           uint32_t             :  3;
      __IO uint32_t  PWM13_HIGH_CNT: 13;            /*!< PWM13 HIGH CNT [12:0]                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x003C;                      /*!< REG_003C                                                              */
    
    struct {
      __IO uint32_t  PWM14_PERIOD: 13;              /*!< PWM14 PERIOD [12:0]                                                   */
           uint32_t             :  3;
      __IO uint32_t  PWM14_HIGH_CNT: 13;            /*!< PWM14 HIGH CNT [12:0]                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< REG_0040                                                              */
    
    struct {
      __IO uint32_t  PWM15_PERIOD: 13;              /*!< PWM15 PERIOD [12:0]                                                   */
           uint32_t             :  3;
      __IO uint32_t  PWM15_HIGH_CNT: 13;            /*!< PWM15 HIGH CNT [12:0]                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0044;                      /*!< REG_0044                                                              */
    
    struct {
      __IO uint32_t  PWM0_RATE  :  7;               /*!< PWM 0 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM1_RATE  :  7;               /*!< PWM 1 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM2_RATE  :  7;               /*!< PWM 2 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM3_RATE  :  7;               /*!< PWM3 pre-scaler rate (96MHz/n, n = 1 ~127)                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0048;                      /*!< REG_0048                                                              */
    
    struct {
      __IO uint32_t  PWM4_RATE  :  7;               /*!< PWM 4 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM5_RATE  :  7;               /*!< PWM 5 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM6_RATE  :  7;               /*!< PWM 6 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM7_RATE  :  7;               /*!< PWM 7 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x004C;                      /*!< REG_004C                                                              */
    
    struct {
      __IO uint32_t  PWM8_RATE  :  7;               /*!< PWM 8 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM9_RATE  :  7;               /*!< PWM 9 pre-scaler rate (96MHz/n, n = 1 ~127)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM10_RATE :  7;               /*!< PWM 10 pre-scaler rate (96MHz/n, n = 1 ~127)                          */
           uint32_t             :  1;
      __IO uint32_t  PWM11_RATE :  7;               /*!< PWM 11 pre-scaler rate (96MHz/n, n = 1 ~127)                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0050;                      /*!< REG_0050                                                              */
    
    struct {
      __IO uint32_t  PWM12_RATE :  7;               /*!< PWM 12 pre-scaler rate (96MHz/n, n = 1 ~127)                          */
           uint32_t             :  1;
      __IO uint32_t  PWM13_RATE :  7;               /*!< PWM 13 pre-scaler rate (96MHz/n, n = 1 ~127)                          */
           uint32_t             :  1;
      __IO uint32_t  PWM14_RATE :  7;               /*!< PWM 14 pre-scaler rate (96MHz/n, n = 1 ~127)                          */
           uint32_t             :  1;
      __IO uint32_t  PWM15_RATE :  7;               /*!< PWM 15 pre-scaler rate (96MHz/n, n = 1 ~127)                          */
    };
  };
} PWM_Type;


/* ================================================================================ */
/* ================                      AHB1                      ================ */
/* ================================================================================ */


/**
  * @brief AHB1 Controller (Arbiter / Decoder / Multiplexer) (AHB1)
  */

typedef struct {                                    /*!< AHB1 Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x0000                                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  HS0_SIZE   :  4;               /*!< AHB slave0 space size(DDR 32MB RAM)                                   */
      __IO uint32_t  HS0_BASE   : 12;               /*!< AHB slave0 base address of [31:20](unit:1MB)
                                                         Note:Base address must be multiple of space size.                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  HS2_SIZE   :  4;               /*!< AHB slave2 space size(AHB0 Bridge Slaver)                             */
      __IO uint32_t  HS2_BASE   : 12;               /*!< AHB slave2 base address of [31:20](unit:1MB)
                                                         Note:Base address must be multiple of space size.                     */
    };
  };
  __I  uint32_t  RESERVED[30];
  
  union {
    __IO uint32_t  REG_0x0080;                      /*!< REG_0x0080                                                            */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  PLEVEL     : 15;               /*!< Bit n represents the priority level of master n(n=1~15)
                                                         Note:bit1:APBC DMA,bit2: ARM926-D, bit3:DMAC, bit4:MAC,
                                                         bit5:USB20, bit6:MS, bit7:AUDIO, bit8:reserved,
                                                         bit9:reserved, bit10: ARM926-I                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0084;                      /*!< REG_0x0084                                                            */
    
    struct {
      __IO uint32_t  IDLE_COUNT :  6;               /*!< The arbiter will re-arbitrate if a granted master dosen't issue
                                                         a
                                                         NON-SEN command within the idle count period.                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0088;                      /*!< REG_0x0088                                                            */
    
    struct {
      __IO uint32_t  REMAP      :  1;               /*!< Note:After applying the remap function,
                                                         (1).base address of slave 6 = original base address of slave
                                                         4
                                                         (2).base address of slave 4 = original base address of slave
                                                          4 + the space size of slave 6.
                                                         Note that the base address should be the boundary of the space
                                                          size.                                                                */
           uint32_t             :  7;
      __IO uint32_t  INCR_LENGTH:  8;               /*!< When a master issues an INCR command, the arbiter will grant
                                                         the
                                                         master to transfer a total amount of (INCR_LENGTH+1) bursts.(range
                                                          1~255)                                                               */
      __IO uint32_t  AHBC_INTR_EN:  1;              /*!< Enable or disable the interrupt when receiving a non-existing
                                                         address.                                                              */
           uint32_t             :  3;
      __IO uint32_t  AHBC_RESPONSE:  2;             /*!< Response status, when receiving a non-existing address, the
                                                         decoder responds to the master.                                       */
           uint32_t             :  2;
      __IO uint32_t  AHBC_INTR_FLAG:  1;            /*!< Interrupt status, set when receiving a non-existing address.
                                                         Note:Writing a '0' to this bit clears the interrupt.                  */
    };
  };
  
  union {
    __I  uint32_t  REG_0x008C;                      /*!< REG_0x008C                                                            */
    
    struct {
      __I  uint32_t  AHBC_REVISION: 32;             /*!< AHBC revision register.                                               */
    };
  };
} AHB1_Type;


/* ================================================================================ */
/* ================                       ADO                      ================ */
/* ================================================================================ */


/**
  * @brief Audio function (ADO)
  */

typedef struct {                                    /*!< ADO Structure                                                         */
  __I  uint32_t  AUD_IP_VERSION;                    /*!< A 8-digit hex number formatted in YYYYMMDD indicating the
                                                         release date that each literal is ranged in 0~9                       */
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
      __IO uint32_t  AUDIO_MODE :  4;               /*!< Audio mode select :
                                                         XX1X: ADC sigma-delta mode (higher priority than i2s mode)
                                                         XXX1: ADC I2S mode
                                                         10XX: DAC R2R mode
                                                         01XX: DAC I2S mode
                                                         XXX0: ADC GPIO mode
                                                         00XX, 10XX, 11XX: DAC GPIO mode                                       */
      __IO uint32_t  ADC_EN     :  1;               /*!< 1: Enable ADC digital circuit                                         */
      __IO uint32_t  ADC_SIGN   :  1;               /*!< 1: ADC I2S input signed data                                          */
      __IO uint32_t  ADC_MONO   :  1;               /*!< ADC Mono control signal.
                                                         0: Stereo, 1: Mono                                                    */
      __IO uint32_t  ADC_PCM8   :  1;               /*!< 0: ADC I2S input 16-bit PCM
                                                         1: ADC I2S input 8-bit PCM                                            */
           uint32_t             :  8;
      __IO uint32_t  ADC_WB_OUT_PCM8:  1;           /*!< 0: 16-bit PCM of audio record (write) buffer
                                                         1: 8-bit PCM of audio record (write) buffer                           */
      __IO uint32_t  ADC_WB_OUT_SIGN:  1;           /*!< 1: ADC signed data of audio record (write) buffer                     */
      __IO uint32_t  DAC_EN     :  1;               /*!< 1: Enable DAC digital circuit                                         */
      __IO uint32_t  DAC_SIGN   :  1;               /*!< 1: DAC I2S output signed data                                         */
      __IO uint32_t  DAC_MONO   :  1;               /*!< DAC Mono control signal.
                                                         0: Stereo, 1: Mono                                                    */
      __IO uint32_t  DAC_PCM8   :  1;               /*!< 0: DAC I2S output 16-bit PCM
                                                         1: DAC I2S output 8-bit PCM                                           */
      __IO uint32_t  DAC_RB_OUT_PCM8:  1;           /*!< 0: 16-bit PCM of audio play (read) buffer
                                                         1: 8-bit PCM of audio play (read) buffer                              */
      __IO uint32_t  DAC_RB_OUT_SIGN:  1;           /*!< 1: DAC signed data of audio play (read) buffer                        */
      __IO uint32_t  TEST_MODE  :  1;               /*!< 1: Enable triangle wave to debug CH0
                                                         Note: You can only select i2s input or triangle wave input in
                                                         CH0
                                                         (Left channel only, the audio data is signed and is from -7f
                                                          to 7f.
                                                         If PCM16, the data is from -7f00 to 7f00)                             */
      __IO uint32_t  DAC_M2SO   :  1;               /*!< The left channel audio data will be copied to right channel
                                                         in I2S DAC MONO mode when this bit is enabled. (Mono to Stereo
                                                          out)                                                                 */
      __IO uint32_t  TST_WAVFORM:  1;               /*!< 0: Triangle Wave, 1: Sine Wave, for Test mode Waveform.               */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint8_t   REG_0x000C;                      /*!< REG_0x000C                                                            */
    
    struct {
      __IO uint8_t   ADC_ALAW_EN:  1;               /*!< 1: Enable ADC A-Law function                                          */
      __IO uint8_t   DAC_ALAW_EN:  1;               /*!< 1: Enable DAC A-Law function                                          */
    };
  };
  __I  uint8_t   RESERVED1[3];
  
  union {
    __IO uint8_t   REG_0x0010;                      /*!< REG_0x0010                                                            */
    
    struct {
      __IO uint8_t   ADPCM_ENC_EN:  1;              /*!< 1: Enable ADPCM Encode function for I2S.
                                                         0: PCM function.                                                      */
      __IO uint8_t   ADPCM_DEC_EN:  1;              /*!< 1: Enable ADPCM Decode function for I2S.
                                                         0: PCM function.                                                      */
           uint8_t              :  3;
      __IO uint8_t   ADPCM_EXTRAHDR:  1;            /*!< Extra ADPCM Header.                                                   */
      __IO uint8_t   ADPCM_STEP_SIZE:  1;           /*!< 0: Step=16;
                                                         1: Step=1.                                                            */
    };
  };
  __I  uint8_t   RESERVED2[3];
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_0x0014                                                            */
    
    struct {
      __IO uint32_t  ENC_SMPL_NUM: 16;              /*!< ADPCM encode input sample number per frame(frame size)
                                                         Note:
                                                         1. ENC_SMPL_NUM should be a multiple of 4, and be greater than
                                                         32
                                                          2. ADPCM encode output byte number per packet:
                                                         ENC_BYTE_NUM = [(1+2+4)+((ENC_SMPL_NUM-2)/2)]*N
                                                         -> ENC_SMPL_NUM = 2*((ENC_BYTE_NUM/N)-6)
                                                         (N=1 when mono, and N=2 when stereo, and the default value is
                                                          for mono mode)                                                       */
      __IO uint32_t  DEC_BYTE_NUM: 16;              /*!< ADPCM decode input byte number per packet
                                                         DEC_BYTE_NUM = ENC_BYTE_NUM/2                                         */
    };
  };
  
  union {
    __I  uint32_t  REG_0x0018;                      /*!< REG_0x0018                                                            */
    
    struct {
      __I  uint32_t  AUD_W_BUF_INTR_FLAG:  1;       /*!< Interrupt flag of audio record (write) buffer                         */
           uint32_t             :  7;
      __I  uint32_t  AUD_W_BUF_OV_INTR_FLAG:  1;    /*!< Overflow interrupt flag of audio record (write) buffer                */
           uint32_t             :  7;
      __I  uint32_t  AUD_R_BUF_INTR_FLAG:  1;       /*!< Audio play (read) buffer interrupt flag                               */
           uint32_t             :  1;
      __I  uint32_t  AUD_R_BUF_OV_INTR_FLAG:  1;    /*!< Overflow interrupt flag of audio play (read) buffer.                  */
           uint32_t             :  1;
      __I  uint32_t  AUD_W_BUF_FIFO_FULL_FLAG:  1;  /*!< FIFO full flag of audio record (write) buffer                         */
           uint32_t             :  2;
      __I  uint32_t  AUD_R_BUF_FIFO_FULL_FLAG:  1;  /*!< FIFO full flag of audio play (read) buffer                            */
    };
  };
  
  union {
    __O  uint32_t  REG_0x001C;                      /*!< REG_0x001C                                                            */
    
    struct {
           uint32_t             :  8;
      __O  uint32_t  AUD_W_BUF_OV_INTR_FLAG_CLR:  1;/*!< 1: Clear AUD_W_BUF_OV_INTR_FLAG                                       */
           uint32_t             :  9;
      __O  uint32_t  AUD_R_BUF_OV_INTR_FLAG_CLR:  1;/*!< 1: Clear AUD_R_BUF_OV_INTR_FLAG                                       */
           uint32_t             :  1;
      __O  uint32_t  AUD_W_BUF_FIFO_FULL_FLAG_CLR:  1;/*!< 1: Clear AUD_W_BUF_FIFO_FULL_FLAG                                   */
           uint32_t             :  1;
      __O  uint32_t  AUD_R_BUF_FIFO_FULL_FLAG_CLR:  1;/*!< 1: Clear AUD_R_BUF_FIFO_FULL_FLAG                                   */
    };
  };
  
  union {
    __IO uint32_t  AUD_W_BUF_ADDR_CTR;              /*!< The start address of audio record (write) buffer (unit: byte)
                                                         Note:Align Buffer start address to 16 * 32-bit-word                   */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  AUD_W_BUF_ADDR: 30;            /*!< The start address of audio record (write) buffer (unit: byte)
                                                         Note:Align Buffer start address to 16 * 32-bit-word                   */
    };
  };
  __I  uint32_t  RESERVED3[7];
  __IO uint32_t  AUD_W_BUF_DEC_SIZE;                /*!< Size of decreasing audio record (write) buffer.
                                                         Trigger the AUD_W_BUF_DEC_TRG to decrease counts from AUD_W_BUF_CNT.(unit:
                                                         byte)
                                                         (Range: 1byte ~ 64k byte)
                                                         Note:
                                                         The size should be a multiple of 4.                                   */
  __I  uint32_t  RESERVED4[7];
  __I  uint32_t  AUD_W_BUF_CNT;                     /*!< Max. size (in byte) for pop audio data up from record buffer.
                                                         (This register indicates the total bytes of samples in the write
                                                         buffer.)                                                              */
  __I  uint32_t  RESERVED5[7];
  
  union {
    __IO uint16_t  REG_0x0080;                      /*!< REG_0x0080                                                            */
    
    struct {
      __IO uint16_t  AUD_W_BUF_SIZE:  2;            /*!< Size of audio record (write) buffer.
                                                         0: 8Kbyte1: 16Kbyte2: 32Kbyte3: 64Kbyte
                                                         This register is also controlled by the AUD_W_BUF_SIZE_DOWN.
                                                         When AUD_W_BUF_SIZE_DOWN=1, the buffer size will be:
                                                         0: 512byte 1: 1Kbyte2: 2Kbyte3: 4Kbyte                                */
      __IO uint16_t  AUD_W_BUF_TH:  3;              /*!< Threshold of audio record (write) buffer.
                                                         0: 256byte 1: 512byte 2: 1Kbyte 3: 2Kbyte
                                                         4: 4Kbyte 5: 8Kbyte 6: 16Kbyte 7: 32Kbyte
                                                         Note:
                                                         Just interrupt once when the period
                                                         (AUD_W_BUF_CNT>=AUD_W_BUF_TH && AUD_W_BUF_INTR_EN==1).                */
           uint16_t             :  1;
      __O  uint16_t  AUD_W_BUF_DEC_TRG:  1;         /*!< 1: Trigger to decrease audio record buffer by the value defined
                                                         in AUD_W_BUF_DEC_SIZE.                                                */
      __IO uint16_t  AUD_W_BUF_INTR_EN:  1;         /*!< 1: Enable interrupt of audio record (write) buffer.                   */
           uint16_t             :  2;
      __IO uint16_t  AUD_W_BUF_OV_INTR_EN:  1;      /*!< 1: Enable overflow interrupt of audio record (write) buffer.          */
      __IO uint16_t  AUD_W_BUF_SIZE_DOWN:  1;       /*!< 1: Enable to down scale the write buffer size.                        */
    };
  };
  __I  uint16_t  RESERVED6[7];
  
  union {
    __IO uint32_t  AUD_R_BUF_ADDR_CTR;              /*!< The start address of audio play (read) buffer. (unit: byte)
                                                         Note: keep [1:0]=0 to obey the word (4 bytes) alignment.              */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  AUD_R_BUF_ADDR: 30;            /*!< The start address of audio play (read) buffer. (unit: byte)
                                                         Note: keep [1:0]=0 to obey the word (4 bytes) alignment.              */
    };
  };
  __IO uint32_t  AUD_R_BUF_DEC_SIZE;                /*!< Size of decreasing audio play (read) buffer.
                                                         Trigger the AUD_R_BUF_DEC_TRG to decrease counts from AUD_R_BUF_CNT.
                                                         (unit: byte) (Range: 1byte ~ 64k byte)
                                                         Note: The size should be a multiple of 4.                             */
  __I  uint32_t  AUD_R_BUF_CNT;                     /*!< Max. size (in byte) for push audio data into play (read) buffer.
                                                         (This register indicates the total bytes of remaining spaces
                                                         in the read buffer.)                                                  */
  
  union {
    __IO uint16_t  REG_0x009C;                      /*!< REG_0x009C                                                            */
    
    struct {
      __IO uint16_t  AUD_R_BUF_SIZE:  2;            /*!< Audio play (read) buffer size.
                                                         0: 8Kbyte1: 16Kbyte2: 32Kbyte3: 64Kbyte
                                                         This register is also controlled by the AUD_R_BUF_SIZE_DOWN.
                                                         When AUD_R_BUF_SIZE_DOWN=1, the buffer size will be:
                                                         0: 512byte 1: 1Kbyte2: 2Kbyte3: 4Kbyte                                */
      __IO uint16_t  AUD_R_BUF_TH:  3;              /*!< Audio play (read) buffer threshold.
                                                         0: 256byte 1: 512byte 2: 1Kbyte 3: 2Kbyte
                                                         4: 4Kbyte 5: 8Kbyte 6: 16Kbyte 7: 32Kbyte
                                                         Note: Just interrupt once when the period(AUD_R_BUF_CNT <= (AUD_R_BUF_SIZE
                                                         -AUD_R_BUF_TH)
                                                         && AUD_R_BUF_INTR_EN==1).                                             */
           uint16_t             :  1;
      __O  uint16_t  AUD_R_BUF_DEC_TRG:  1;         /*!< 1: Trigger to decrease audio play buffer by the value defined
                                                         in AUD_R_BUF_DEC_SIZE.                                                */
      __IO uint16_t  AUD_R_BUF_INTR_EN:  1;         /*!< 1: Enable interrupt of audio play (read) buffer.                      */
           uint16_t             :  2;
      __IO uint16_t  AUD_R_BUF_OV_INTR_EN:  1;      /*!< 1: Enable overflow interrupt of audio play (read) buffer.             */
      __IO uint16_t  AUD_R_BUF_SIZE_DOWN:  1;       /*!< 1: Enable to down scale the read buffer size.                         */
    };
  };
  __I  uint16_t  RESERVED7[9];
  
  union {
    __IO uint8_t   REG_0x00B0;                      /*!< REG_0x00B0                                                            */
    
    struct {
      __IO uint8_t   MCLK_FREQ_SEL:  1;             /*!< Base freq. for Audio ADC_MCLK/DAC_MCLK:
                                                         0: 24.576 MHz; 1: 22.579 MHz                                          */
      __IO uint8_t   MCLK_EN    :  1;               /*!< 1: Enable ADC_MCLK/DAC_MCLK                                           */
      __IO uint8_t   MCLK_SEL_EXT:  1;              /*!< 1: Select external master clock for audio input.                      */
      __IO uint8_t   I2S_SEL_SLA:  1;               /*!< 1: I2S input interface is in slave mode.                              */
    };
  };
  __I  uint8_t   RESERVED8[3];
  
  union {
    __IO uint32_t  REG_0x00B4;                      /*!< REG_0x00B4                                                            */
    
    struct {
      __IO uint32_t  ADC_MCLK_DIV:  8;              /*!< ADC/DAC Master Clock(DAC clock = ADC clock)
                                                         ADC_MCLK = PLL_ADC_MCLK(24.576/22.579MHz)
                                                         or EXT_ADC_MCLK / ADC_MCLK_DIV
                                                         Note: min value 2                                                     */
      __IO uint32_t  ADC_BCLK_DIV:  8;              /*!< I2S Bit Clock for ADC/DAC
                                                         ADC_BCLK = PLL_ADC_MCLK(24.576/22.579MHz)
                                                         or EXT_ADC_MCLK / ADC_BCLK_DIV
                                                         Note: min value 2                                                     */
      __IO uint32_t  ADC_LRCK_DIV:  9;              /*!< I2S Data Left/Right alignment clock for ADC
                                                         ADC_LRCK = ADC_BCLK/ADC_LRCK_DIV                                      */
      __IO uint32_t  SIG_MCLK_DIV:  7;              /*!< Sigma-Delta ADC Master Clock
                                                         SIG_MCLK = PLL_ADC_MCLK(24.576/22.579MHz)
                                                         or EXT_ADC_MCLK / SIG_MCLK_DIV
                                                         Note: min value 2
                                                         SIG_BCLK = SIG_MCLK/4,
                                                         SIG_LRCK = SIG_BCLK/64.                                               */
    };
  };
  __I  uint32_t  RESERVED9;
  
  union {
    __IO uint32_t  REG_0x00BC;                      /*!< REG_0x00BC                                                            */
    
    struct {
      __I  uint32_t  AUD_IO_I   :  5;               /*!< Audio GPIO input
                                                         Note:
                                                         AUD_IO_I[0] for ADC_DATA/GPIO[0],
                                                         AUD_IO_I[1] for ADC_BCLK/GPIO[1],
                                                         AUD_IO_I[2] for DAC_DATA/GPIO[2],
                                                         AUD_IO_I[3] for ADC_LRCK/GPIO[3],
                                                         AUD_IO_I[4] for ADC_MCLK/GPIO[4]                                      */
           uint32_t             :  3;
      __IO uint32_t  AUD_IO_O   :  5;               /*!< Audio GPIO output                                                     */
           uint32_t             :  3;
      __IO uint32_t  AUD_IO_OE  :  5;               /*!< Audio GPIO output enable.
                                                         1: enable(output), 0:disable(input)                                   */
    };
  };
  
  union {
    __IO uint16_t  REG_0x00C0;                      /*!< REG_0x00C0                                                            */
    
    struct {
      __IO uint16_t  ADC_RPT_EN :  1;               /*!< 1: Enable ADC_SUM_H and ADC_SUM_L for ADC.
                                                         (The ADC report function is affected by ADC_GAIN_EN. If ADC_GAIN_EN
                                                         is 0, the
                                                         ADC report function will not act.)                                    */
      __IO uint16_t  ADC_GAIN_EN:  1;               /*!< 1: Enable AGC for ADC                                                 */
      __IO uint16_t  ADC_GAIN   :  5;               /*!< Digital gain for ADC (Range: 0-20)
                                                         00000: 0dB,00111: 3.5dB,01110: 7dB,
                                                         00001: 0.5dB,01000: 4dB,01111: 7.5dB,
                                                         00010: 1dB,01001: 4.5dB,10000: 8dB,
                                                         00011: 1.5dB,01010: 5dB,10001: 8.5dB,
                                                         00100: 2dB,01011: 5.5dB,10010: 9dB,
                                                         00101: 2.5dB,01100: 6dB,10011: 9.5dB,
                                                         00110: 3dB,01101: 6.5dB,10100: 10dB                                   */
      __IO uint16_t  ADC_GAINRMP_RATE:  4;          /*!< Amplitude +0.5dB every (GAINRMP_RATE*512) sample                      */
      __IO uint16_t  ADC_MUTE_SPEED:  2;            /*!< 00 : Amplitude -3dB every 4 sample
                                                         01 : Amplitude -3dB every 8 sample
                                                         10 : Amplitude -3dB every 16 sample
                                                         11 : Amplitude -3dB every 32 sample                                   */
      __IO uint16_t  ADC_MUTE   :  1;               /*!< 1: Mute ADC to 0                                                      */
    };
  };
  __I  uint16_t  RESERVED10;
  
  union {
    __IO uint32_t  REG_0x00C4;                      /*!< REG_0x00C4                                                            */
    
    struct {
      __IO uint32_t  ADC_TH_L   : 15;               /*!< ADC low level peak detection for 16-bit pcm                           */
           uint32_t             :  1;
      __IO uint32_t  ADC_TH_H   : 15;               /*!< ADC high level peak detection for 16-bit pcm                          */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00C8;                      /*!< REG_0x00C8                                                            */
    
    struct {
      __I  uint32_t  ADC_SUM_L  : 16;               /*!< Summation of 16-bit PCM for ADC
                                                         when the value>Arch-band ADC_TH_L                                     */
      __I  uint32_t  ADC_SUM_H  : 16;               /*!< Summation of 16-bit PCM for ADC
                                                         when the value>Arch-band ADC_TH_H                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00CC;                      /*!< REG_0x00CC                                                            */
    
    struct {
      __IO uint32_t  ADC_DC_STEP_TH1:  8;           /*!< ADC DC compensation STEP Threshold 1                                  */
      __IO uint32_t  ADC_DC_STEP_TH2:  8;           /*!< ADC DC compensation STEP Threshold 2                                  */
      __IO uint32_t  ADC_DC_STEP_TH3:  8;           /*!< ADC DC compensation STEP Threshold 3
                                                         *Threshold 3 > Threshold 2 > Threshold 1                              */
      __IO uint32_t  ADC_DC_COMP_EN:  1;            /*!< 1: Enable DC compensation for ADC                                     */
    };
  };
  
  union {
    __IO uint16_t  REG_0x00D0;                      /*!< REG_0x00D0                                                            */
    
    struct {
      __IO uint16_t  BUZ_EN     :  1;               /*!< 1: Enable buzzer mixing function                                      */
      __IO uint16_t  AUD_WEIGHT :  4;               /*!< Weight of original audio for mixing with dual tones (Buzzer).
                                                         Mix = AUDIO*AUD_WEIGHT/8 + BUZ*BUZ_WEIGHT1/8                          */
      __IO uint16_t  BUZ_WEIGHT :  4;               /*!< Weight of dual tones (Buzzer) for mixing with original audio.
                                                         Mix = AUDIO*AUD_WEIGHT/8 + BUZ*BUZ_WEIGHT1/8                          */
    };
  };
  __I  uint16_t  RESERVED11;
  
  union {
    __IO uint32_t  REG_0x00D4;                      /*!< REG_0x00D4                                                            */
    
    struct {
      __IO uint32_t  BUZ0_LEVEL :  6;               /*!< The level of buzzer 0 volume.                                         */
      __IO uint32_t  BUZ1_LEVEL :  6;               /*!< The level of buzzer 1 volume.                                         */
      __IO uint32_t  BUZ2_LEVEL :  6;               /*!< The level of buzzer 2 volume.                                         */
      __IO uint32_t  BUZ3_LEVEL :  6;               /*!< The level of buzzer 3 volume.                                         */
    };
  };
  
  union {
    __O  uint8_t   REG_0x00D8;                      /*!< REG_0x00D8                                                            */
    
    struct {
      __O  uint8_t   BUZ0_LEV_TRG:  1;              /*!< 1: Trigger to modify the mix audio data level of buzzer 0.            */
      __O  uint8_t   BUZ1_LEV_TRG:  1;              /*!< 1: Trigger to modify the mix audio data level of buzzer 1.            */
      __O  uint8_t   BUZ2_LEV_TRG:  1;              /*!< 1: Trigger to modify the mix audio data level of buzzer 2.            */
      __O  uint8_t   BUZ3_LEV_TRG:  1;              /*!< 1: Trigger to modify the mix audio data level of buzzer 3.            */
    };
  };
  __I  uint8_t   RESERVED12[11];
  
  union {
    __IO uint32_t  REG_0x00E4;                      /*!< REG_0x00E4                                                            */
    
    struct {
      __IO uint32_t  BUZ0_CNT   : 10;               /*!< Buzzer count for checking up the Table. Sine wave sample clock.
                                                         ps : fo = fs*BUZ0_CNT/(32*128)                                        */
      __IO uint32_t  BUZ1_CNT   : 10;               /*!< Buzzer count for checking up the Table. Sine wave sample clock.
                                                         ps : fo = fs*BUZ1_CNT/(32*128)                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00E8;                      /*!< REG_0x00E8                                                            */
    
    struct {
      __IO uint32_t  BUZ2_CNT   : 10;               /*!< Buzzer count for checking up the Table. Sine wave sample clock.
                                                         ps : fo = fs*BUZ2_CNT/(32*128)                                        */
      __IO uint32_t  BUZ3_CNT   : 10;               /*!< Buzzer count for checking up the Table. Sine wave sample clock.
                                                         ps : fo = fs*BUZ3_CNT/(32*128)                                        */
    };
  };
  
  union {
    __IO uint8_t   REG_0x00EC;                      /*!< REG_0x00EC                                                            */
    
    struct {
      __IO uint8_t   BUZ0_TAB_SEL:  2;              /*!< Select BUZ0 sine wave table.
                                                         00: sin(x), 01: sin(x)+sin(2x)+sin(3x)+sin(4x)+sin(5x)
                                                         10: sin(x)+sin(2x)+sin(4x), 11: sin(x)+sin(3x)+sin(5x)                */
      __IO uint8_t   BUZ1_TAB_SEL:  2;              /*!< Select BUZ1 sine wave table.
                                                         00: sin(x), 01: sin(x)+sin(2x)+sin(3x)+sin(4x)+sin(5x)
                                                         10: sin(x)+sin(2x)+sin(4x), 11: sin(x)+sin(3x)+sin(5x)                */
      __IO uint8_t   BUZ2_TAB_SEL:  2;              /*!< Select BUZ2 sine wave table.
                                                         00: sin(x), 01: sin(x)+sin(2x)+sin(3x)+sin(4x)+sin(5x)
                                                         10: sin(x)+sin(2x)+sin(4x), 11: sin(x)+sin(3x)+sin(5x)                */
      __IO uint8_t   BUZ3_TAB_SEL:  2;              /*!< Select BUZ3 sine wave table.
                                                         00: sin(x), 01: sin(x)+sin(2x)+sin(3x)+sin(4x)+sin(5x)
                                                         10: sin(x)+sin(2x)+sin(4x), 11: sin(x)+sin(3x)+sin(5x)                */
    };
  };
  __I  uint8_t   RESERVED13[3];
  
  union {
    __IO uint16_t  REG_0x00F0;                      /*!< REG_0x00F0                                                            */
    
    struct {
      __IO uint16_t  BUZ0_LEV_INDEX:  4;            /*!< BUZ0 LEVEL index, indicate decrease or increase value during
                                                         one period.
                                                         Ps: BUZ0_LEV_INDEX [3] indicate decrease or increase bit, (1:
                                                          decrease level value, 0: increase level value)                       */
      __IO uint16_t  BUZ1_LEV_INDEX:  4;            /*!< BUZ1 LEVEL index, indicate decrease or increase value during
                                                         one period.
                                                         Ps: BUZ1_LEV_INDEX [3] indicate decrease or increase bit, (1:
                                                          decrease level value, 0: increase level value)                       */
      __IO uint16_t  BUZ2_LEV_INDEX:  4;            /*!< BUZ2 LEVEL index, indicate decrease or increase value during
                                                         one period.
                                                         Ps: BUZ2_LEV_INDEX [3] indicate decrease or increase bit, (1:
                                                          decrease level value, 0: increase level value)                       */
      __IO uint16_t  BUZ3_LEV_INDEX:  4;            /*!< BUZ3 LEVEL index, indicate decrease or increase value during
                                                         one period.
                                                         Ps: BUZ3_LEV_INDEX [3] indicate decrease or increase bit, (1:
                                                          decrease level value, 0: increase level value)                       */
    };
  };
  __I  uint16_t  RESERVED14;
  
  union {
    __O  uint8_t   REG_0x00F4;                      /*!< REG_0x00F4                                                            */
    
    struct {
      __O  uint8_t   BUZ0_INDEX_TRG:  1;            /*!< 1: Trigger to modify the mix audio data index of buzzer 0.            */
      __O  uint8_t   BUZ1_INDEX_TRG:  1;            /*!< 1: Trigger to modify the mix audio data index of buzzer 1.            */
      __O  uint8_t   BUZ2_INDEX_TRG:  1;            /*!< 1: Trigger to modify the mix audio data index of buzzer 2.            */
      __O  uint8_t   BUZ3_INDEX_TRG:  1;            /*!< 1: Trigger to modify the mix audio data index of buzzer 3.            */
    };
  };
  __I  uint8_t   RESERVED15[11];
  
  union {
    __IO uint16_t  REG_0x0100;                      /*!< REG_0x0100                                                            */
    
    struct {
      __IO uint16_t  ADPCM_WRITE_BACK:  1;          /*!< 1: Enable MS-ADPCM encoded data without extra header write back
                                                         to Memory function when DAC_EN and ADPCM_DEC_EN are enabled.
                                                         (EN = DAC_EN & ADPCM_WRITE_BACK & ADPCM_DEC_EN)                       */
      __IO uint16_t  ADPCM_WB_BUF_SIZE:  2;         /*!< MS-ADPCM encoded data write back buffer size.
                                                         0: 8Kbyte1: 16Kbyte2: 32Kbyte3: 64Kbyte
                                                         This register is also controlled by the ADPCM_WB_BUF_SIZE_DOWN.
                                                         When ADPCM_WB_BUF_SIZE_DOWN = 1, the buffer size will be:
                                                         0: 512byte 1: 1Kbyte2: 2Kbyte3: 4Kbyte                                */
      __IO uint16_t  ADPCM_BUF_TH:  3;              /*!< MS-ADPCM encoded data write back buffer threshold.
                                                         0: 256byte 1: 512byte 2: 1Kbyte 3: 2Kbyte
                                                         4: 4Kbyte 5: 8Kbyte 6: 16Kbyte 7: 32Kbyte
                                                         Note: Just interrupt once when the period
                                                         (AUD_R_BUF_CNT <= (AUD_R_BUF_SIZE-AUD_R_BUF_TH) && AUD_R_BUF_INTR_EN==1). */
      __IO uint16_t  ADPCM_WB_BUF_INTR_EN:  1;      /*!< 1: Enable interrupt of MS-ADPCM encoded data write back buffer.       */
      __IO uint16_t  ADPCM_WB_BUF_OV_INTR_EN:  1;   /*!< 1: Enable overflow interrupt of MS-ADPCM encoded data write
                                                         back buffer.                                                          */
      __O  uint16_t  ADPCM_WB_BUF_DEC_TRG:  1;      /*!< 1: Trigger to decrease MS-ADPCM write back buffer by the value
                                                         defined in ADPCM_WB_BUF_DEC_SIZE.                                     */
      __O  uint16_t  ADPCM_WB_BUF_OV_FLAG_CLR:  1;  /*!< 1: Clear ADPCM_WB_BUF_OV_FLAG                                         */
      __O  uint16_t  ADPCM_WB_BUF_FIFO_FULL_FLAG_CLR:  1;/*!< 1: Clear ADPCM_WB_BUF_FIFO_FULL_FLAG                             */
      __IO uint16_t  ADPCM_WB_BUF_SIZE_DOWN:  1;    /*!< 1: Enable to down scale the write back buffer size.                   */
    };
  };
  __I  uint16_t  RESERVED16;
  
  union {
    __IO uint32_t  ADPCM_WB_BUF_ADDR_CTR;           /*!< The start address of MS-ADPCM encoded data write back buffer
                                                         (unit: byte)
                                                         Note: Align Buffer start address to 16 * 32-bit-word                  */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  ADPCM_WB_BUF_ADDR: 30;         /*!< The start address of MS-ADPCM encoded data write back buffer
                                                         (unit: byte)
                                                         Note: Align Buffer start address to 16 * 32-bit-word                  */
    };
  };
  __IO uint32_t  ADPCM_WB_BUF_DEC_SIZE;             /*!< Size of decreasing MS-ADPCM encoded data write back buffer.
                                                         Trigger the
                                                          ADPCM_WB_BUF_DEC_TRG to decrease counts from ADPCM_WB_BUF_CNT.(unit:
                                                          byte)
                                                         (Range: 1byte ~ 64k byte)
                                                         Note:
                                                         The size should be a multiple of 4.                                   */
  __I  uint32_t  ADPCM_WB_BUF_CNT;                  /*!< Max. size (in byte) for pop audio data into MS-ADPCM encoded
                                                         data write back buffer.
                                                          (This register indicates the total bytes of samples in the
                                                          ADPCM write back buffer.)                                            */
  
  union {
    __I  uint8_t   REG_0x0110;                      /*!< REG_0x0110                                                            */
    
    struct {
      __I  uint8_t   ADPCM_WB_BUF_INTR_FLAG:  1;    /*!< Interrupt flag of MS-ADPCM encoded data write back buffer             */
      __I  uint8_t   ADPCM_WB_BUF_OV_INTR_FLAG:  1; /*!< Overflow interrupt flag of MS-ADPCM encoded data write back
                                                         buffer                                                                */
      __I  uint8_t   ADPCM_WB_BUF_FIFO_FULL_FLAG:  1;/*!< FIFO full interrupt flag of MS-ADPCM encoded data write back
                                                         buffer                                                                */
    };
  };
  __I  uint8_t   RESERVED17[3];
  
  union {
    __IO uint16_t  REG_0x0114;                      /*!< REG_0x0114                                                            */
    
    struct {
      __IO uint16_t  DEC_WB_BUF_EN:  1;             /*!< 1: Enable Decoded Data Write Back Buffer for other using              */
      __IO uint16_t  DEC_WB_BUF_SIZE:  2;           /*!< Decoded Data Write Back buffer size.
                                                         0: 8Kbyte1: 16Kbyte2: 32Kbyte3: 64Kbyte
                                                         This register is also controlled by the DEC_WB_BUF_SIZE_DOWN.
                                                         When DEC_WB_BUF_SIZE_DOWN = 1, the buffer size will be:
                                                         0: 512byte 1: 1Kbyte2: 2Kbyte3: 4Kbyte                                */
      __IO uint16_t  DEC_WB_BUF_TH:  3;             /*!< Decoded Data Write Back buffer threshold.
                                                         0: 256byte 1: 512byte 2: 1Kbyte 3: 2Kbyte
                                                         4: 4Kbyte 5: 8Kbyte 6: 16Kbyte 7: 32Kbyte
                                                         Note: Just interrupt once when the period 
                                                         (DEC_WB_BUF_CNT >= DEC_WB_BUF_TH && DEC_WB _BUF_INTR_EN == 1).        */
      __IO uint16_t  DEC_WB_BUF_INTR_EN:  1;        /*!< 1: Enable interrupt of Decoded Data Write Back buffer.                */
      __IO uint16_t  DEC_WB_BUF_OV_INTR_EN:  1;     /*!< 1: Enable overflow interrupt of Decoded Data Write Back buffer.       */
      __O  uint16_t  DEC_WB_BUF_DEC_TRG:  1;        /*!< 1: Trigger to decrease Decoded Data Write Back buffer by the
                                                         value defined in DEC_WB _BUF_DEC_SIZE.                                */
      __O  uint16_t  DEC_WB_BUF_OV_FLAG_CLR:  1;    /*!< 1: Clear DEC_WB _BUF_OV_FLAG                                          */
      __O  uint16_t  DEC_WB_BUF_FIFO_FULL_FLAG_CLR:  1;/*!< 1: Clear DEC_WB _BUF_FIFO_FULL_FLAG                                */
      __IO uint16_t  DEC_WB_BUF_SIZE_DOWN:  1;      /*!< 1: Enable to down scale the Decoded Data Write Back buffer size.      */
    };
  };
  __I  uint16_t  RESERVED18;
  
  union {
    __IO uint32_t  DEC_WB_BUF_ADDR_CTR;             /*!< The start address of Decoded Data Write Back buffer (unit: byte)
                                                         Note: Align Buffer start address to 16 * 32-bit-word                  */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  DEC_WB_BUF_ADDR: 30;           /*!< The start address of Decoded Data Write Back buffer (unit: byte)
                                                         Note: Align Buffer start address to 16 * 32-bit-word                  */
    };
  };
  __IO uint32_t  DEC_WB_BUF_DEC_SIZE;               /*!< Size of decreasing Decoded Data Write Back buffer. Trigger the
                                                         DEC_WB _BUF_DEC_TRG to decrease counts from DEC_WB _BUF_CNT.
                                                         (unit: byte) (Range: 1byte ~ 64k byte)
                                                         Note: The size should be a multiple of 4.                             */
  __I  uint32_t  DEC_WB_BUF_CNT;                    /*!< Max. size (in byte) for pop audio data into Decoded Data Write
                                                         Back buffer.
                                                         (This register indicates the total bytes of samples in the Decoded
                                                          write buffer.)                                                       */
  
  union {
    __I  uint8_t   REG_0x0124;                      /*!< REG_0x0124                                                            */
    
    struct {
      __I  uint8_t   DEC_WB_BUF_INTR_FLAG:  1;      /*!< Interrupt flag of Decoded Data Write Back buffer                      */
      __I  uint8_t   DEC_WB_BUF_OV_INTR_FLAG:  1;   /*!< Overflow interrupt flag of Decoded Data Write Back buffer             */
      __I  uint8_t   DEC_WB_BUF_FIFO_FULL_FLAG:  1; /*!< FIFO full interrupt flag of Decoded Data Write Back buffer            */
    };
  };
  __I  uint8_t   RESERVED19[3];
  __I  uint32_t  AUD_W_BUF_INDEX;                   /*!< Current address index of AUD_W_BUF writing to memory.                 */
  __I  uint32_t  AUD_R_BUF_INDEX;                   /*!< Current address index of AUD_R_BUF reading from memory.               */
  __I  uint32_t  ADPCM_WB_BUF_INDEX;                /*!< Current address index of ADPCM_WB_BUF writing to memory.              */
  __I  uint32_t  DEC_WB_BUF_INDEX;                  /*!< Current address index of DEC_WB_BUF writing to memory.                */
  __I  uint32_t  RESERVED20[2];
  
  union {
    __IO uint32_t  REG_0x0140;                      /*!< REG_0x0140                                                            */
    
    struct {
      __IO uint32_t  DAC_MUTE   :  1;               /*!< 1: Enable Mute Function for DAC                                       */
      __IO uint32_t  DAC_AUTO_MUTE:  1;             /*!< 1: Enable Auto-Mute function for DAC (For RF audio loss)              */
           uint32_t             : 10;
      __IO uint32_t  DAC_GAIN_EN:  1;               /*!< 1: Enable digital gain control for DAC                                */
      __IO uint32_t  DAC_SUM_EN :  1;               /*!< 1: Enable Summary Report for DAC                                      */
      __IO uint32_t  DAC_RMP    :  2;               /*!< Attenuation ramp rate for DAC
                                                         00: 0.5 dB per 1 sample. 10: 0.5 dB per 4 samples.
                                                         01: 0.5 dB per 2 samples. 11: 0.5 dB per 8 samples.                   */
      __IO uint32_t  DAC_GAIN   :  4;               /*!< Digital gain for left channel for DAC (Range: 0-15)
                                                         0: 0 db 8: -24 db
                                                         1: -2.5 db 9: -26.6 db
                                                         2: -6 db 10: -30.1 db
                                                         3: -8.5 db 11: -32.6 db
                                                         4: -12 db 12: -36.1 db
                                                         5: -14 db 13: -38.6 db
                                                         6: -18 db 14: 42.1 db
                                                         7: -20 db 15: -44.6 db                                                */
      __IO uint32_t  UPSAMPLE_EN:  1;               /*!< 1: Enable up-sampling function for DAC (Play).                        */
      __IO uint32_t  UPSAMPLE_RATE:  2;             /*!< When up-sampling function enabled:
                                                         00: 2x output samples
                                                         01: 3x output samples
                                                         10: 4x output samples
                                                         11: 6x output samples                                                 */
    };
  };
  
  union {
    __I  uint32_t  REG_0x0144;                      /*!< REG_0x0144                                                            */
    
    struct {
      __I  uint32_t  DAC_SUM_RPT_L: 16;             /*!< SUM of DAC left channel output data                                   */
      __I  uint32_t  DAC_SUM_RPT_R: 16;             /*!< SUM of DAC right channel output data                                  */
    };
  };
  __IO uint8_t   DAC_VOLUME;                        /*!< Volume control, VG=
                                                         15:0 dB 7:-23.5 dB
                                                         14:-3 dB 6:-26.2 dB
                                                         13:-5.6 dB5:-29.8 dB
                                                         12:-8.2 dB4:-32.4 dB
                                                         11:-11.9 dB3:-36 dB
                                                         10:-14.6 dB2:-39.1 dB
                                                         9: -18.2 dB1:-42 dB
                                                         8:-21.4 dB0:-45 dB                                                    */
} ADO_Type;


/* ================================================================================ */
/* ================                      SDADC                     ================ */
/* ================================================================================ */


/**
  * @brief Sigma-Delta ADC (SDADC)
  */

typedef struct {                                    /*!< SDADC Structure                                                       */
  __IO uint8_t   LB_H;                              /*!< AGC Control.
                                                         Low bound setting for output amplitude of ADC: High byte              */
  __I  uint8_t   RESERVED[3];
  __IO uint8_t   LB_L;                              /*!< AGC Control.
                                                         Low bound setting for output amplitude of ADC: Low byte               */
  __I  uint8_t   RESERVED1[3];
  __IO uint8_t   HB_H;                              /*!< AGC Control.
                                                         High bound setting for output amplitude of ADC: High byte             */
  __I  uint8_t   RESERVED2[3];
  __IO uint8_t   HB_L;                              /*!< AGC Control.
                                                         High bound setting for output amplitude of ADC: Low byte              */
  __I  uint8_t   RESERVED3[3];
  __IO uint8_t   NOR_POD;                           /*!< AGC Control.
                                                         The period of gain update at normal mode when AGC is on.
                                                          Fs : Sampling rate
                                                         0000: 1/Fs x 2^(0)
                                                         0001: 1/Fs x 2^(1)
                                                         ...
                                                         1110: 1/Fs x 2^(14)
                                                         1111: 1/Fs x 2^(15)                                                   */
  __I  uint8_t   RESERVED4[3];
  __IO uint8_t   MUTE_POD;                          /*!< AGC Control.
                                                         The period of gain update at mute mode when AGC is on.
                                                         Fs : Sampling rate
                                                         0000:1/Fs x 2^(0)
                                                         0001: 1/Fs x 2^(1)
                                                         ......
                                                         1110: 1/Fs x 2^(14)
                                                         1111: 1/Fs x 2^(15)                                                   */
  __I  uint8_t   RESERVED5[3];
  __IO uint8_t   SEARCH_TH_H;                       /*!< AGC Control.
                                                         Threshold for activating AGC. High byte.                              */
  __I  uint8_t   RESERVED6[3];
  __IO uint8_t   SEARCH_TH_L;                       /*!< AGC Control.
                                                         Threshold for activating AGC. Low byte.                               */
  __I  uint8_t   RESERVED7[3];
  __IO uint8_t   MUTE_TH_H;                         /*!< AGC Control.
                                                         Threshold for inactivating AGC. High byte.                            */
  __I  uint8_t   RESERVED8[3];
  __IO uint8_t   MUTE_TH_L;                         /*!< AGC Control.
                                                         Threshold for inactivating AGC. Low byte.                             */
  __I  uint8_t   RESERVED9[3];
  __IO uint8_t   MUTE_CAL_POD;                      /*!< AGC Control.
                                                         The calculating period for inactivating AGC.
                                                          Fs : Sampling rate
                                                         0000:256/Fs x 2^(0)
                                                         0001: 256/Fs x 2^(1)
                                                         ......
                                                         1110: 256/Fs x 2^(14)
                                                         1111: 256/Fs x 2^(15)                                                 */
  __I  uint8_t   RESERVED10[3];
  __IO uint8_t   SAT_TH;                            /*!< AGC Control.
                                                         Threshold for ADC saturation condition                                */
  __I  uint8_t   RESERVED11[3];
  __IO uint8_t   SAT_POD;                           /*!< AGC Control.
                                                         The detection period for ADC saturation condition.
                                                         Fs : Sampling rate
                                                         0000:1/Fs x 2^(0)
                                                         0001: 1/Fs x 2^(1)
                                                         ......
                                                         1110: 1/Fs x 2^(14)
                                                         1111: 1/Fs x 2^(15)                                                   */
  __I  uint8_t   RESERVED12[3];
  
  union {
    __IO uint8_t   REG_0x0384;                      /*!< REG_0x0384                                                            */
    
    struct {
      __IO uint8_t   PGA_SET_VAL:  5;               /*!< AGC Control.
                                                         PGA setting value at normal mode when AGC is on.(1.5dB/step)
                                                         00000:Mute
                                                         00001:-12dB
                                                         ......
                                                         01001 : 0dB
                                                         ......
                                                         11110 : +31.5dB
                                                          1111 1: +33dB                                                        */
      __IO uint8_t   BOOST_SET_VAL:  2;             /*!< AGC Control.
                                                         Boost setting value at normal mode when AGC is on.
                                                         00: +0dB , 01: +20dB
                                                         10: +30dB, 11: +37dB.                                                 */
      __IO uint8_t   AGC_OFF    :  1;               /*!< AGC Control.
                                                         AGC function control.
                                                         1 : Disable
                                                         0 : Enable.                                                           */
    };
  };
  __I  uint8_t   RESERVED13[3];
  
  union {
    __IO uint8_t   REG_0x0388;                      /*!< REG_0x0388                                                            */
    
    struct {
      __IO uint8_t   IWL        :  2;               /*!< Word length of DAI
                                                         00:16-bits
                                                         01:18-bits
                                                         10:20-bits
                                                         11:24-bits                                                            */
      __IO uint8_t   ACTIVE     :  1;               /*!< Digital Audio Interface Control.
                                                         1: Enable
                                                         0: Disable.                                                           */
    };
  };
  __I  uint8_t   RESERVED14[3];
  
  union {
    __IO uint8_t   REG_0x038C;                      /*!< REG_0x038C                                                            */
    
    struct {
      __IO uint8_t   PGA        :  5;               /*!< PGA setting value when AGC is off. (1.5dB/step)
                                                         00000:Mute
                                                         00001:-12dB
                                                         ......
                                                         01001 : 0dB
                                                         ......
                                                         11110 : +31.5dB
                                                          1111 1: +33dB                                                        */
      __IO uint8_t   BOOST      :  2;               /*!< Boost setting value when AGC is off.
                                                         00: +0dB , 01: +20dB
                                                         10: +30dB, 11: +37dB.                                                 */
    };
  };
  __I  uint8_t   RESERVED15[3];
  
  union {
    __IO uint8_t   REG_0x0390;                      /*!< REG_0x0390                                                            */
    
    struct {
      __IO uint8_t   HPGAIN     :  4;               /*!< HPF GAIN.                                                             */
      __IO uint8_t   ADCHPD     :  1;               /*!< HPF function for DC offset cancellation.
                                                         1: Disable
                                                         0: Enable                                                             */
      __IO uint8_t   FILTER_OFF :  1;               /*!< Filter function for noise suppression.
                                                         1: Disable
                                                         0: Enable                                                             */
    };
  };
  __I  uint8_t   RESERVED16[3];
  
  union {
    __IO uint8_t   REG_0x0394;                      /*!< REG_0x0394                                                            */
    
    struct {
      __IO uint8_t   MUTE_CTRL  :  4;               /*!< Digital Volume attenuation control. At the mute mode when AGC
                                                         is on:
                                                         0000 : 0dB ,0001: -3dB
                                                         0010 : -6dB ,0011:-9dB
                                                          0100:-12dB ,0101:-15dB
                                                         0110:-18dB ,0111:-21dB
                                                          1000:-24dB ,1001:-27dB
                                                          1010:-30dB ,1011:-36dB
                                                         1100:-42dB ,1101:-48dB
                                                          1110:-54dB ,1111:-78dB                                               */
      __IO uint8_t   VOL_CTRL   :  4;               /*!< Digital Volume attenuation control. At the normal mode when
                                                         AGC is on or AGC is off:
                                                         0000 : 0dB ,0001: -3dB
                                                         0010 : -6dB ,0011:-9dB
                                                         0100:-12dB ,0101:-15dB
                                                         0110:-18dB ,0111:-21dB
                                                          1000:-24dB ,1001:-27dB
                                                          1010:-30dB ,1011:-36dB
                                                         1100:-42dB ,1101:-48dB
                                                          1110:-54dB ,1111:-78dB                                               */
    };
  };
  __I  uint8_t   RESERVED17[3];
  
  union {
    __IO uint8_t   REG_0x0398;                      /*!< REG_0x0398                                                            */
    
    struct {
      __IO uint8_t   PGA_MUTE_VAL:  5;              /*!< AGC Control.
                                                         PGA setting value at mute mode when AGC is on.(1.5dB/step)
                                                         00000:Mute
                                                         00001:-12dB
                                                         ......
                                                         01001 : 0dB
                                                         ......
                                                         11110 : +31.5dB
                                                          1111 1: +33dB                                                        */
      __IO uint8_t   BOOST_MUTE_VAL:  2;            /*!< AGC Control.
                                                         Boost setting value at mute mode when AGC is on.
                                                         00: +0dB , 01: +20dB
                                                         10: +30dB, 11: +37dB.                                                 */
    };
  };
  __I  uint8_t   RESERVED18[3];
  __IO uint8_t   VOL_MUTE_POD;                      /*!< The updating period for Digital Volume
                                                         attenuation at the normal/mute mode when AGC is on.
                                                         Bit[7:4]: for normal mode.
                                                         Bit[3:0]: for mute mode.
                                                         Fs : Sampling rate
                                                         0000:1/Fs x 2^(0)
                                                         0001: 1/Fs x 2^(1)
                                                         ......
                                                         1110: 1/Fs x 2^(14)
                                                         1111: 1/Fs x 2^(15)                                                   */
  __I  uint8_t   RESERVED19[15];
  
  union {
    __IO uint8_t   REG_0x03AC;                      /*!< REG_0x03AC                                                            */
    
    struct {
           uint8_t              :  3;
      __IO uint8_t   DEMPD      :  1;               /*!< DEM disable, active High                                              */
      __IO uint8_t   PGA_EN     :  1;               /*!< PGA power-up enable, active High                                      */
      __IO uint8_t   MICBT_EN   :  1;               /*!< MICBOOST power-up enable, active High                                 */
           uint8_t              :  1;
      __IO uint8_t   ADC_EN     :  1;               /*!< ADC power-up enable, active High                                      */
    };
  };
  __I  uint8_t   RESERVED20[3];
  
  union {
    __IO uint8_t   REG_0x03B0;                      /*!< REG_0x03B0                                                            */
    
    struct {
      __IO uint8_t   CK_EN      :  1;               /*!< CKGEN enable, active High                                             */
      __IO uint8_t   MICB_EN    :  1;               /*!< Microphone bias enable, active High                                   */
      __IO uint8_t   VREF_EN    :  1;               /*!< VREF circuit enable, active High                                      */
      __IO uint8_t   IREF_EN    :  1;               /*!< IREF circuit enable, active High                                      */
      __IO uint8_t   DX_EN      :  1;               /*!< SDM data to IC external enable, active High                           */
      __IO uint8_t   CS         :  2;               /*!< Chopper frequency select                                              */
    };
  };
  __I  uint8_t   RESERVED21[3];
  
  union {
    __IO uint8_t   REG_0x03B4;                      /*!< REG_0x03B4                                                            */
    
    struct {
      __IO uint8_t   SEL_MIX_MIC:  1;               /*!< Microphone input path to mixer enable
                                                         0=Disable
                                                         1=Enable                                                              */
           uint8_t              :  1;
      __IO uint8_t   SEL_MIC    :  1;               /*!< Microphone input structure select
                                                         0=differential
                                                         1=Single-ended                                                        */
           uint8_t              :  1;
      __IO uint8_t   SEL_MICB   :  1;               /*!< Microphone bias output select
                                                         0=0.8*VA
                                                         1=0.9*VA                                                              */
      __IO uint8_t   SEL_IB     :  2;               /*!< Internal Bias current select
                                                         11=50uA, 10=40uA
                                                         01=40uA, 00=30uA.                                                     */
    };
  };
  __I  uint8_t   RESERVED22[3];
  
  union {
    __I  uint8_t   REG_0x03B8;                      /*!< REG_0x03B8                                                            */
    
    struct {
      __I  uint8_t   PGA_AGC    :  5;               /*!< PGA setting value when AGC is ON.
                                                         Read Only.                                                            */
      __I  uint8_t   BOOST_AGC  :  2;               /*!< Boost setting value when AGC is ON.
                                                         Read Only.                                                            */
    };
  };
} SDADC_Type;


/* ================================================================================ */
/* ================                       DMA                      ================ */
/* ================================================================================ */


/**
  * @brief DMA Controller (DMA)
  */

typedef struct {                                    /*!< DMA Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_9120_0000                                                         */
    
    struct {
      __I  uint32_t  DMA_INTR   :  8;               /*!< The result of DMA_INTR_ABT[7:0] | DMA_INTR_ERR[7:0] |
                                                          DMA_INTR_TC[7:0].                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_9120_0004                                                         */
    
    struct {
      __I  uint32_t  DMA_INTR_TC:  8;               /*!< Status of the DMA terminal count interrupts after masking.
                                                         0: Channel n has no pending interrupt (n=0~7)
                                                         1: Channel n has a pending interrupt                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< REG_9120_0008                                                         */
    
    struct {
      __O  uint32_t  CLR_DMA_INTR_TC:  8;           /*!< Write 1 to clear the DMA_INT_TC[7:0] and DMA_TC[7:0] status.          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG_9120_000C                                                         */
    
    struct {
      __I  uint32_t  DMA_INTR_ERR:  8;              /*!< Status of the DMA error interrupts after masking.
                                                         0: Channel n has no pending interrupt (n=0~7)
                                                         1: Channel n has a pending interrupt                                  */
           uint32_t             :  8;
      __I  uint32_t  DMA_INTR_ABT:  8;              /*!< Status of the DMA abort interrupts after masking.
                                                         0: Channel n has no pending interrupt (n=0~7)
                                                         1: Channel n has a pending interrupt                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG_9120_0010                                                         */
    
    struct {
      __O  uint32_t  CLR_DMA_INTR_ERR:  8;          /*!< Write 1 to clear the DMA_INTR_ERR[7:0] and DMA_ERR[7:0] status.       */
           uint32_t             :  8;
      __O  uint32_t  CLR_DMA_INTR_ABT:  8;          /*!< Write 1 to clear the DMA_INTR_ABT[7:0] and DMA_ABT[7:0] status.       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG_9120_0014                                                         */
    
    struct {
      __I  uint32_t  DMA_TC     :  8;               /*!< Status of the DMA terminal count.
                                                         0: Channel n has no terminal count status (n=0~7)
                                                         1: Channel n has a terminal count status                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG_9120_0018                                                         */
    
    struct {
      __I  uint32_t  DMA_ERR    :  8;               /*!< Status of the DMA error.
                                                         0: Channel n has no error status (n=0~7)
                                                         1: Channel n has an error status                                      */
           uint32_t             :  8;
      __I  uint32_t  DMA_ABT    :  8;               /*!< Status of the DMA abort.
                                                         0: Channel n has no abort status (n=0~7)
                                                         1: Channel n has an abort status                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REG_9120_001C                                                         */
    
    struct {
      __I  uint32_t  DMA_CH_EN  :  8;               /*!< Channel n enable status. (n=0~7)
                                                         0: Channel n is enable
                                                         1: Channel n is disable                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG_9120_0020                                                         */
    
    struct {
      __I  uint32_t  DMA_CH_BUSY:  8;               /*!< Channel n busy status. (n=0~7)
                                                         0: Channel n is not busy
                                                         1: Channel n is busy                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< REG_9120_0024                                                         */
    
    struct {
      __IO uint32_t  DMA_EN     :  1;               /*!< DMA controller enable.                                                */
      __IO uint32_t  M0ENDIAN   :  1;               /*!< AHB Master 0 endian configuration.                                    */
      __IO uint32_t  M1ENDIAN   :  1;               /*!< AHB Master 1 endian configuration.                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< REG_9120_0028                                                         */
    
    struct {
      __IO uint32_t  DMA_SYNC   :  8;               /*!< DMA synchronization logic enable for channel n request. (n=0~7)0:
                                                         Disable
                                                         1: Enable
                                                                                                                               */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< REG_9120_0030                                                         */
    
    struct {
      __I  uint32_t  DMA_REL_REV:  8;               /*!< Release number.                                                       */
      __I  uint32_t  DMA_MINOR_REV:  8;             /*!< Minor revision number.                                                */
      __I  uint32_t  DMA_MAJOR_REV:  8;             /*!< Major revision number.                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< REG_9120_0034                                                         */
    
    struct {
      __I  uint32_t  DMA_ADDR_WIDTH:  4;            /*!< FIFO ram address width.                                               */
           uint32_t             :  4;
      __I  uint32_t  DMA_HAVE_LINKLIST:  1;         /*!< DMA supports link list                                                */
      __I  uint32_t  DMA_HAVE_AHB1:  1;             /*!< DMA has AHB 0 and AHB 1                                               */
      __I  uint32_t  DMA_HAVE_BRIDGE:  1;           /*!< DMA has built in a simple bridge                                      */
           uint32_t             :  1;
      __I  uint32_t  DMA_MAX_CHNO:  4;              /*!< DMA maximum channel number.                                           */
    };
  };
  __I  uint32_t  RESERVED1[50];
  
  union {
    __IO uint32_t  REG_0x0100;                      /*!< REG_9120_0100                                                         */
    
    struct {
      __IO uint32_t  CH0_EN     :  1;               /*!< CH0 enable bit                                                        */
      __IO uint32_t  CH0_DST_SEL:  1;               /*!< CH0 destination select.                                               */
      __IO uint32_t  CH0_SRC_SEL:  1;               /*!< CH0 source select.                                                    */
      __IO uint32_t  CH0_DST_INC:  2;               /*!< CH0 destination address incremental.                                  */
      __IO uint32_t  CH0_SRC_INC:  2;               /*!< CH0 source address incremental.                                       */
      __IO uint32_t  CH0_MODE   :  1;               /*!< CH0 mode                                                              */
      __IO uint32_t  CH0_DST_WIDTH:  3;             /*!< CH0 destination transfer width.                                       */
      __IO uint32_t  CH0_SRC_WIDTH:  3;             /*!< CH0 source transfer width.                                            */
           uint32_t             :  1;
      __O  uint32_t  CH0_ABT    :  1;               /*!< CH0 transaction abort.
                                                         Writing 1 to this bit will cause the DMA to stop the current
                                                         transfer
                                                         Note: If you write 1 to this bit, all other bits of this register
                                                          will remain
                                                         the same. That is, you can't program this bit and the other
                                                          bits of
                                                         this register simultaneously.                                         */
      __IO uint32_t  CH0_SRC_SIZE:  3;              /*!< CH0 source burst size selection. (the number of transfers before
                                                         the
                                                         DMA re-arbitrates among the enabled channel)
                                                         000: Burst size = 1 100: Burst size = 32
                                                         001: Burst size = 4 101: Burst size = 64
                                                         010: Burst size = 8 110: Burst size = 128
                                                         011: Burst size = 16 111: Burst size = 256
                                                         Note: The number of bytes to be transferred for one burst depends
                                                          on
                                                         the source burst size and the source transfer width                   */
      __IO uint32_t  CH0_PROT   :  3;               /*!< These bits control the AHB HPROT[3:1]                                 */
      __IO uint32_t  CH0_PRI    :  2;               /*!< CH0 priority level.                                                   */
      __IO uint32_t  CH0_FF_TH  :  3;               /*!< CH0 DMA FIFO threshold value.
                                                         000: Threshold value = 1 011: Threshold value = 8
                                                         001: Threshold value = 2 100: Threshold value = 16
                                                         010: Threshold value = 4 101~111: Reserved
                                                         Note: When DMA FIFO space >= DMA_FF_TH, then DMA controller
                                                         will start to transfer the data from the source to FIFO.
                                                         When the number of valid data in the DMA FIFO is greater than
                                                         DMA_FF_TH, then the DMA controller will start to pop out data
                                                         from FIFO to the destination. Notice that, DMA_FF_TH can not
                                                         be larger than 1/2 DMA FIFO size.                                     */
           uint32_t             :  4;
      __IO uint32_t  CH0_TC_MSK :  1;               /*!< CH0 terminal count status mask for current transaction.
                                                         0: DMA_TC[0] register will be set when terminal count happens
                                                         1: DMA_TC[0] register will not be set when terminal count happens     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0104;                      /*!< REG_9120_0104                                                         */
    
    struct {
      __IO uint32_t  CH0_INTR_TC_MSK:  1;           /*!< CH0 terminal count interrupt mask.                                    */
      __IO uint32_t  CH0_INTR_ERR_MSK:  1;          /*!< CH0 error interrupt mask.                                             */
      __IO uint32_t  CH0_INTR_ABT_MSK:  1;          /*!< CH0 abort interrupt mask.                                             */
      __IO uint32_t  CH0_SRC_REQ:  4;               /*!< CH0 source request select when DMA hardware handshake mode.           */
      __IO uint32_t  CH0_SRC_HE :  1;               /*!< CH0 source hardware handshake mode enable.
                                                         0: Disable
                                                         1: Enable
                                                         Note: The bit is valid only when CH0_MODE=1 (hardware handshake)      */
      __I  uint32_t  CH0_BUSY   :  1;               /*!< The DMA CH0 is busy.                                                  */
      __IO uint32_t  CH0_DST_REQ:  4;               /*!< CH0 destination request select when DMA hardware handshake mode.      */
      __IO uint32_t  CH0_DST_HE :  1;               /*!< CH0 destination hardware handshake mode enable.                       */
           uint32_t             :  2;
      __I  uint32_t  CH0_LLP_CNT:  4;               /*!< CH0 chain transfer counter.
                                                         Note: This counter is reset to 0 when CH_EN changes from 0 to
                                                         1. If
                                                         chain transfer is enabled, after each block data transfer is
                                                          finished,
                                                         LLP_CNT will increase 1.                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0108;                      /*!< REG_9120_0108                                                         */
    
    struct {
      __IO uint32_t  CH0_SRC_A  : 32;               /*!< CH0 source starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x010C;                      /*!< REG_9120_010C                                                         */
    
    struct {
      __IO uint32_t  CH0_DST_A  : 32;               /*!< CH0 destination starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0110;                      /*!< REG_9120_0110                                                         */
    
    struct {
      __IO uint32_t  CH0_LLP_SRC:  1;               /*!< CH0 master for loading the next LLP.                                  */
           uint32_t             :  1;
      __IO uint32_t  CH0_LLP_ADDR: 30;              /*!< CH0 linked list descriptor pointer address. (unit: 4 byte)            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0114;                      /*!< REG_9120_0114                                                         */
    
    struct {
      __IO uint32_t  CH0_TOT_SIZE: 22;              /*!< CH0 total transfer size, unit depends on the source width.
                                                         When SRC_WIDTH = 000, unit: 8-bit
                                                         When SRC_WIDTH = 001, unit: 16-bit
                                                         When SRC_WIDTH = 010, unit: 32-bit
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
    };
  };
  __I  uint32_t  RESERVED2[2];
  
  union {
    __IO uint32_t  REG_0x0120;                      /*!< REG_0x0120                                                            */
    
    struct {
      __IO uint32_t  CH1_EN     :  1;               /*!< CH1 enable / disable                                                  */
      __IO uint32_t  CH1_DST_SEL:  1;               /*!< CH1 destination select.                                               */
      __IO uint32_t  CH1_SRC_SEL:  1;               /*!< CH1 source select.                                                    */
      __IO uint32_t  CH1_DST_INC:  2;               /*!< CH1 destination address incremental.
                                                          Note: Do not set as decrement source address when the data
                                                         width are
                                                          not same between source and destination.                             */
      __IO uint32_t  CH1_SRC_INC:  2;               /*!< CH1 source address incremental.                                       */
      __IO uint32_t  CH1_MODE   :  1;               /*!< CH1 mode                                                              */
      __IO uint32_t  CH1_DST_WIDTH:  3;             /*!< CH1 destination transfer width.                                       */
      __IO uint32_t  CH1_SRC_WIDTH:  3;             /*!< CH1 source transfer width.                                            */
           uint32_t             :  1;
      __O  uint32_t  CH1_ABT    :  1;               /*!< CH1 transaction abort.
                                                          Writing 1 to this bit will cause the DMA to stop the current
                                                         transfer
                                                          Note: If you write 1 to this bit, all other bits of this register
                                                          will remain
                                                          the same. That is, you can't program this bit and the other
                                                          bits of
                                                          this register simultaneously.                                        */
      __IO uint32_t  CH1_SRC_SIZE:  3;              /*!< CH1 source burst size selection.
                                                          (the number of transfers before the DMA re-arbitrates among
                                                         the enabled channel)
                                                          000: Burst size = 1 100: Burst size = 32
                                                          001: Burst size = 4 101: Burst size = 64
                                                          010: Burst size = 8 110: Burst size = 128
                                                          011: Burst size = 16 111: Burst size = 256
                                                          Note: The number of bytes to be transferred for one burst depends
                                                          on
                                                          the source burst size and the source transfer width                  */
      __IO uint32_t  CH1_PROT   :  3;               /*!< These bits control the AHB HPROT[3:1]                                 */
      __IO uint32_t  CH1_PRI    :  2;               /*!< CH1 priority level.                                                   */
      __IO uint32_t  CH1_FF_TH  :  3;               /*!< CH1 DMA FIFO threshold value.
                                                          Note: When DMA FIFO space >= DMA_FF_TH, then DMA controller
                                                          will start to transfer the data from the source to FIFO.
                                                          When the number of valid data in the DMA FIFO is greater than
                                                          DMA_FF_TH, then the DMA controller will start to pop out data
                                                          from FIFO to the destination. Notice that, DMA_FF_TH can not
                                                          be larger than 1/2 DMA FIFO size.                                    */
           uint32_t             :  4;
      __IO uint32_t  CH1_TC_MSK :  1;               /*!< CH1 terminal count status mask for current transaction.
                                                          0: DMA_TC[0] register will be set when terminal count happens
                                                          1: DMA_TC[0] register will not be set when terminal count happens
                                                                                                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0124;                      /*!< REG_0x0124                                                            */
    
    struct {
      __IO uint32_t  CH1_INTR_TC_MSK:  1;           /*!< CH1 terminal count interrupt mask.                                    */
      __IO uint32_t  CH1_INTR_ERR_MSK:  1;          /*!< CH1 error interrupt mask.                                             */
      __IO uint32_t  CH1_INTR_ABT_MSK:  1;          /*!< CH1 abort interrupt mask.                                             */
      __IO uint32_t  CH1_SRC_REQ:  4;               /*!< CH1 source request select when DMA hardware handshake mode.           */
      __IO uint32_t  CH1_SRC_HE :  1;               /*!< CH1 source hardware handshake mode enable.
                                                         Note: The bit is valid only when CH1_MODE=1 (hardware handshake)      */
      __I  uint32_t  CH1_BUSY   :  1;               /*!< The DMA CH1 is busy.                                                  */
      __IO uint32_t  CH1_DST_REQ:  4;               /*!< CH1 destination request select when DMA hardware handshake mode.      */
      __IO uint32_t  CH1_DST_HE :  1;               /*!< CH1 destination hardware handshake mode enable.                       */
           uint32_t             :  2;
      __I  uint32_t  CH1_LLP_CNT:  4;               /*!< CH1 chain transfer counter.
                                                         Note: This counter is reset to 0 when CH_EN changes from 0 to
                                                         1. If
                                                         chain transfer is enabled, after each block data transfer is
                                                          finished,
                                                         LLP_CNT will increase 1.                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0128;                      /*!< REG_0x0128                                                            */
    
    struct {
      __IO uint32_t  CH1_SRC_A  : 32;               /*!< CH1 source starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x012C;                      /*!< REG_0x012C                                                            */
    
    struct {
      __IO uint32_t  CH1_DST_A  : 32;               /*!< CH1 destination starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0130;                      /*!< REG_0x0130                                                            */
    
    struct {
      __IO uint32_t  CH1_LLP_SRC:  1;               /*!< CH1 master for loading the next LLP.                                  */
           uint32_t             :  1;
      __IO uint32_t  CH1_LLP_ADDR: 30;              /*!< CH1 linked list descriptor pointer address. (unit: 4 byte)            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0134;                      /*!< REG_0x0134                                                            */
    
    struct {
      __IO uint32_t  CH1_TOT_SIZE: 22;              /*!< CH1 total transfer size, unit depends on the source width.
                                                         When SRC_WIDTH = 000, unit: 8-bit
                                                         When SRC_WIDTH = 001, unit: 16-bit
                                                         When SRC_WIDTH = 010, unit: 32-bit
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
    };
  };
  __I  uint32_t  RESERVED3[2];
  
  union {
    __IO uint32_t  REG_0x0140;                      /*!< REG_0x0140                                                            */
    
    struct {
      __IO uint32_t  CH2_EN     :  1;               /*!< CH2 enable / disable                                                  */
      __IO uint32_t  CH2_DST_SEL:  1;               /*!< CH2 destination select.                                               */
      __IO uint32_t  CH2_SRC_SEL:  1;               /*!< CH2 source select.                                                    */
      __IO uint32_t  CH2_DST_INC:  2;               /*!< CH2 destination address incremental.
                                                         Note: Do not set as decrement source address when the data width
                                                         are
                                                         not same between source and destination.                              */
      __IO uint32_t  CH2_SRC_INC:  2;               /*!< CH2 source address incremental.                                       */
      __IO uint32_t  CH2_MODE   :  1;               /*!< CH2 mode                                                              */
      __IO uint32_t  CH2_DST_WIDTH:  3;             /*!< CH2 destination transfer width.                                       */
      __IO uint32_t  CH2_SRC_WIDTH:  3;             /*!< CH2 source transfer width.                                            */
           uint32_t             :  1;
      __O  uint32_t  CH2_ABT    :  1;               /*!< CH2 transaction abort.
                                                         Writing 1 to this bit will cause the DMA to stop the current
                                                         transfer
                                                         Note: If you write 1 to this bit, all other bits of this register
                                                          will remain
                                                         the same. That is, you can't program this bit and the other
                                                          bits of
                                                         this register simultaneously.                                         */
      __IO uint32_t  CH2_SRC_SIZE:  3;              /*!< CH2 source burst size selection.
                                                         (the number of transfers before the DMA re-arbitrates among
                                                         the enabled channel)
                                                         000: Burst size = 1 100: Burst size = 32
                                                         001: Burst size = 4 101: Burst size = 64
                                                         010: Burst size = 8 110: Burst size = 128
                                                         011: Burst size = 16 111: Burst size = 256
                                                         Note: The number of bytes to be transferred for one burst depends
                                                          on
                                                         the source burst size and the source transfer width                   */
      __IO uint32_t  CH2_PROT   :  3;               /*!< These bits control the AHB HPROT[3:1]                                 */
      __IO uint32_t  CH2_PRI    :  2;               /*!< CH2 priority level.                                                   */
      __IO uint32_t  CH2_FF_TH  :  3;               /*!< CH2 DMA FIFO threshold value.
                                                         Note: When DMA FIFO space >= DMA_FF_TH, the DMA controller
                                                         will start to transfer the data form the source to FIFO.
                                                         When the number of valid data in the DMA FIFO is greater than
                                                         DMA_FF_TH, then the DMA controller will start to pop out data
                                                         from FIFO to the destination. Notice that, DMA_FF_TH cannot]nbe
                                                         larger than 1/2 DMA FIFO size.                                        */
           uint32_t             :  4;
      __IO uint32_t  CH2_TC_MSK :  1;               /*!< CH2 terminal count status mask for current transaction.
                                                         0: DMA_TC[0] register will be set when terminal count happens
                                                         1: DMA_TC[0] register will not be set when terminal count happens     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0144;                      /*!< REG_0x0144                                                            */
    
    struct {
      __IO uint32_t  CH2_INTR_TC_MSK:  1;           /*!< CH2 terminal count interrupt mask.                                    */
      __IO uint32_t  CH2_INTR_ERR_MSK:  1;          /*!< CH2 error interrupt mask.                                             */
      __IO uint32_t  CH2_INTR_ABT_MSK:  1;          /*!< CH2 abort interrupt mask.                                             */
      __IO uint32_t  CH2_SRC_REQ:  4;               /*!< CH2 source request select when DMA hardware handshake mode.           */
      __IO uint32_t  CH2_SRC_HE :  1;               /*!< CH2 source hardware handshake mode enable.                            */
      __I  uint32_t  CH2_BUSY   :  1;               /*!< The DMA CH2 is busy.                                                  */
      __IO uint32_t  CH2_DST_REQ:  4;               /*!< CH2 destination request select when DMA hardware handshake mode.      */
      __IO uint32_t  CH2_DST_HE :  1;               /*!< CH2 destination hardware handshake mode enable.                       */
           uint32_t             :  2;
      __I  uint32_t  CH2_LLP_CNT:  4;               /*!< CH2 chain transfer counter.
                                                         Note: This counter is reset to 0 when CH_EN changes from 0 to
                                                         1. If
                                                         chain transfer is enabled, after each block data transfer is
                                                          finished,
                                                         LLP_CNT will increase 1.                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0148;                      /*!< REG_0x0148                                                            */
    
    struct {
      __IO uint32_t  CH2_SRC_A  : 32;               /*!< CH2 source starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x014C;                      /*!< REG_0x014C                                                            */
    
    struct {
      __IO uint32_t  CH2_DST_A  : 32;               /*!< CH2 destination starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0150;                      /*!< REG_0x0150                                                            */
    
    struct {
      __IO uint32_t  CH2_LLP_SRC:  1;               /*!< CH2 master for loading the next LLP.                                  */
           uint32_t             :  1;
      __IO uint32_t  CH2_LLP_ADDR: 30;              /*!< CH2 linked list descriptor pointer address. (unit: 4 byte)            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0154;                      /*!< REG_0x0154                                                            */
    
    struct {
      __IO uint32_t  CH2_TOT_SIZE: 22;              /*!< CH2 total transfer size, unit depends on the source width.
                                                         When SRC_WIDTH = 000, unit: 8-bit
                                                         When SRC_WIDTH = 001, unit: 16-bit
                                                         When SRC_WIDTH = 010, unit: 32-bit
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
    };
  };
  __I  uint32_t  RESERVED4[2];
  
  union {
    __IO uint32_t  REG_0x0160;                      /*!< REG_0x0160                                                            */
    
    struct {
      __IO uint32_t  CH3_EN     :  1;               /*!< CH3 enable / disable                                                  */
      __IO uint32_t  CH3_DST_SEL:  1;               /*!< CH3 destination select.                                               */
      __IO uint32_t  CH3_SRC_SEL:  1;               /*!< CH3 source select.                                                    */
      __IO uint32_t  CH3_DST_INC:  2;               /*!< CH3 destination address incremental.
                                                         Note: Do not set as decrement source address when the data width
                                                         are
                                                         not same between source and destination.                              */
      __IO uint32_t  CH3_SRC_INC:  2;               /*!< CH3 source address incremental.                                       */
      __IO uint32_t  CH3_MODE   :  1;               /*!< CH3 mode                                                              */
      __IO uint32_t  CH3_DST_WIDTH:  3;             /*!< CH3 destination transfer width.                                       */
      __IO uint32_t  CH3_SRC_WIDTH:  3;             /*!< CH3 source transfer width.                                            */
           uint32_t             :  1;
      __O  uint32_t  CH3_ABT    :  1;               /*!< CH3 transaction abort.
                                                         Writing 1 to this bit will cause the DMA to stop the current
                                                         transfer
                                                         Note: If you write 1 to this bit, all other bits of this register
                                                          will remain
                                                         the same. That is, you can't program this bit and the other
                                                          bits of
                                                         this register simultaneously.                                         */
      __IO uint32_t  CH3_SRC_SIZE:  3;              /*!< CH3 source burst size selection.
                                                         (the number of transfers before the DMA re-arbitrates among
                                                         the enabled channel)
                                                         000: Burst size = 1 100: Burst size = 32
                                                         001: Burst size = 4 101: Burst size = 64
                                                         10: Burst size = 8 110: Burst size = 128
                                                         011: Burst size = 16 111: Burst size = 256
                                                         Note: The number of bytes to be transferred for one burst depends
                                                          on
                                                         the source burst size and the source transfer width                   */
      __IO uint32_t  CH3_PROT   :  3;               /*!< These bits control the AHB HPROT[3:1]                                 */
      __IO uint32_t  CH3_PRI    :  2;               /*!< CH3 priority level.                                                   */
      __IO uint32_t  CH3_FF_TH  :  3;               /*!< CH3 DMA FIFO threshold value.
                                                         Note: When DMA FIFO space >= DMA_FF_TH, then DMA controller
                                                         will start to transfer the data from the source to FIFO.
                                                         When the number of valid data in the DMA FIFO is greater than
                                                         DMA_FF_TH, then the DMA controller will start to pop out data
                                                         from FIFO to the destination. Notice that, DMA_FF_TH can not
                                                         be larger than 1/2 DMA FIFO size.                                     */
           uint32_t             :  4;
      __IO uint32_t  CH3_TC_MSK :  1;               /*!< CH3 terminal count status mask for current transaction.
                                                         0: DMA_TC[0] register will be set when terminal count happens
                                                         1: DMA_TC[0] register will not be set when terminal count happens     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0164;                      /*!< REG_0x0164                                                            */
    
    struct {
      __IO uint32_t  CH3_INTR_TC_MSK:  1;           /*!< CH3 terminal count interrupt mask.                                    */
      __IO uint32_t  CH3_INTR_ERR_MSK:  1;          /*!< CH3 error interrupt mask.                                             */
      __IO uint32_t  CH3_INTR_ABT_MSK:  1;          /*!< CH3 abort interrupt mask.                                             */
      __IO uint32_t  CH3_SRC_REQ:  4;               /*!< CH3 source request select when DMA hardware handshake mode.           */
      __IO uint32_t  CH3_SRC_HE :  1;               /*!< CH3 source hardware handshake mode enable.
                                                         Note: The bit is valid only when CH3_MODE=1 (hardware handshake)      */
      __I  uint32_t  CH3_BUSY   :  1;               /*!< The DMA CH3 is busy.                                                  */
      __IO uint32_t  CH3_DST_REQ:  4;               /*!< CH3 destination request select when DMA hardware handshake mode.      */
      __IO uint32_t  CH3_DST_HE :  1;               /*!< CH3 destination hardware handshake mode enable.                       */
           uint32_t             :  2;
      __I  uint32_t  CH3_LLP_CNT:  4;               /*!< CH3 chain transfer counter.
                                                         Note: This counter is reset to 0 when CH_EN changes from 0 to
                                                         1. If
                                                         chain transfer is enabled, after each block data transfer is
                                                          finished,
                                                         LLP_CNT will increase 1.                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0168;                      /*!< REG_0x0168                                                            */
    
    struct {
      __IO uint32_t  CH3_SRC_A  : 32;               /*!< CH3 source starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x016C;                      /*!< REG_0x016C                                                            */
    
    struct {
      __IO uint32_t  CH3_DST_A  : 32;               /*!< CH3 destination starting address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0170;                      /*!< REG_0x0170                                                            */
    
    struct {
      __IO uint32_t  CH3_LLP_SRC:  1;               /*!< CH3 master for loading the next LLP.                                  */
           uint32_t             :  1;
      __IO uint32_t  CH3_LLP_ADDR: 30;              /*!< CH3 linked list descriptor pointer address. (unit: 4 byte)            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0174;                      /*!< REG_0x0174                                                            */
    
    struct {
      __IO uint32_t  CH3_TOT_SIZE: 22;              /*!< CH3 total transfer size, unit depends on the source width.
                                                         When SRC_WIDTH = 000, unit: 8-bit
                                                         When SRC_WIDTH = 001, unit: 16-bit
                                                         When SRC_WIDTH = 010, unit: 32-bit
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
    };
  };
} DMA_Type;


/* ================================================================================ */
/* ================                      APBC                      ================ */
/* ================================================================================ */


/**
  * @brief APB Controller (APB Bridge / DMA) (APBC)
  */

typedef struct {                                    /*!< APBC Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< APB slave0 setting (SSP)                                              */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS0_SIZE   :  4;               /*!< APB slave0 space size.                                                */
      __IO uint32_t  PS0_BASE   : 10;               /*!< APB slave0 base addresses [29:20]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< APB slave1 setting (UART1)                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS1_SIZE   :  4;               /*!< APB slave1 space size.                                                */
      __IO uint32_t  PS1_BASE   : 10;               /*!< APB slave1 base addresses [29:20]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< APB slave2 setting (UART2)                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS2_SIZE   :  4;               /*!< APB slave2 space size.                                                */
      __IO uint32_t  PS2_BASE   : 10;               /*!< APB slave2 base addresses [29:20]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< APB slave3 setting (INTC)                                             */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS3_SIZE   :  4;               /*!< APB slave3 space size.                                                */
      __IO uint32_t  PS3_BASE   : 10;               /*!< APB slave3 base addresses [29:20]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< APB slave4 setting                                                    */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS4_BASE   : 14;               /*!< APB slave4 base addresses [29:16]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< APB slave5 setting                                                    */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS5_BASE   : 14;               /*!< APB slave5 base addresses [29:16]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< APB slave6 setting                                                    */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS6_BASE   : 14;               /*!< APB slave6 base addresses [29:16]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< APB slave7 setting                                                    */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS7_BASE   : 14;               /*!< APB slave7 base addresses [29:16]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< APB slave8 setting                                                    */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS8_BASE   : 14;               /*!< APB slave8 base addresses [29:16]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< APB slave9 setting                                                    */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS9_BASE   : 14;               /*!< APB slave9 base addresses [29:16]                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< APB slave10 setting                                                   */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS10_BASE  : 14;               /*!< APB slave10 base addresses [29:16]                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x002C;                      /*!< APB slave11 setting                                                   */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS11_BASE  : 14;               /*!< APB slave11 base addresses [29:16]                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< APB slave12 setting                                                   */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS12_BASE  : 14;               /*!< APB slave12 base addresses [29:16]                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< APB slave13 setting                                                   */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS13_BASE  : 14;               /*!< APB slave13 base addresses [29:16]                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0038;                      /*!< APB slave14 setting                                                   */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  PS14_BASE  : 14;               /*!< APB slave14 base addresses [29:16]                                    */
    };
  };
  __I  uint32_t  RESERVED[17];
  __IO uint32_t  CHA_SRC_A;                         /*!< CHA source address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
  __IO uint32_t  CHA_DST_A;                         /*!< CHA destination address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
  __IO uint32_t  CHA_SIZE;                          /*!< CHA transfer cycle.
                                                         Total size = CHA_SIZE x 1 when CHA_BURST_MODE=0 (no burst)
                                                         Total size = CHA_SIZE x 4 when CHA_BURST_MODE=1 (burst)
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
  
  union {
    __IO uint32_t  REG_0x008C;                      /*!< REG_0x008C                                                            */
    
    struct {
      __IO uint32_t  CHA_EN     :  1;               /*!< Enable DMA CHA transfer.
                                                         Note: This bit will be cleared automatically when all the DMA
                                                         cycles are
                                                         finished.                                                             */
      __IO uint32_t  CHA_FIN_FLAG:  1;              /*!< CHA finishing interrupt flag.
                                                         0: No interrupt occurs
                                                         1: Interrupt occurs
                                                         Note: This bit will be cleared by writing '0'                         */
      __IO uint32_t  CHA_FIN_INTR_EN:  1;           /*!< Enable CHA finished interrupt.                                        */
      __IO uint32_t  CHA_BURST_MODE:  1;            /*!< CHA burst mode.                                                       */
      __IO uint32_t  CHA_ERR_FLAG:  1;              /*!< CHA error response interrupt flag.                                    */
      __IO uint32_t  CHA_ERR_INTR_EN:  1;           /*!< Enable CHA error interrupt when the AHB slave returns an error
                                                         response during a DMA channel A transfer.                             */
      __IO uint32_t  CHA_SRC_SEL:  1;               /*!< CHA source select.                                                    */
      __IO uint32_t  CHA_DST_SEL:  1;               /*!< CHA destination select.                                               */
      __IO uint32_t  CHA_SRC_INC:  3;               /*!< CHA source address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         source
                                                         address cannot cross the 1K boundary within one DMA transfer
                                                         period.                                                               */
           uint32_t             :  1;
      __IO uint32_t  CHA_DST_INC:  3;               /*!< CHA destination address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         destination address cannot cross the 1K boundary within one
                                                         DMA
                                                         transfer period.                                                      */
           uint32_t             :  1;
      __IO uint32_t  CHA_DST_REQ:  4;               /*!< CHA request/grant select of destination when hardware handshake
                                                         mode.                                                                 */
      __IO uint32_t  CHA_DATA_WIDTH:  2;            /*!< CHA data width of the transfer.Note: When the DMA source or
                                                         the destination is the APB device, the
                                                         width of the data must be set as word. The APB device supports
                                                         the word transfer only.                                               */
           uint32_t             :  2;
      __IO uint32_t  CHA_SRC_REQ:  4;               /*!< CHA request/grant select of source when hardware handshake mode.      */
    };
  };
  __IO uint32_t  CHB_SRC_A;                         /*!< CHB source address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
  __IO uint32_t  CHB_DST_A;                         /*!< CHB destination address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
  __IO uint32_t  CHB_SIZE;                          /*!< CHB transfer cycle.
                                                         Total size = CHB_SIZE x 1 when CHB_BURST_MODE=0 (no burst)
                                                         Total size = CHB_SIZE x 4 when CHB_BURST_MODE=1 (burst)
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
  
  union {
    __IO uint32_t  REG_0x009C;                      /*!< REG_0x009C                                                            */
    
    struct {
      __IO uint32_t  CHB_EN     :  1;               /*!< Enable DMA CHB transfer.
                                                         Note: This bit will be cleared automatically when all the DMA
                                                         cycles are
                                                         finished.                                                             */
      __IO uint32_t  CHB_FIN_FLAG:  1;              /*!< CHB finishing interrupt flag.
                                                         0: No interrupt occurs
                                                         1: Interrupt occurs
                                                         Note: This bit will be cleared by writing '0'                         */
      __IO uint32_t  CHB_FIN_INTR_EN:  1;           /*!< Enable CHB finished interrupt.                                        */
      __IO uint32_t  CHB_BURST_MODE:  1;            /*!< CHB burst mode.                                                       */
      __IO uint32_t  CHB_ERR_FLAG:  1;              /*!< CHB error response interrupt flag.                                    */
      __IO uint32_t  CHB_ERR_INTR_EN:  1;           /*!< Enable CHB error interrupt when the AHB slave returns an error
                                                         response during a DMA channel A transfer.                             */
      __IO uint32_t  CHB_SRC_SEL:  1;               /*!< CHB source select.                                                    */
      __IO uint32_t  CHB_DST_SEL:  1;               /*!< CHB destination select.                                               */
      __IO uint32_t  CHB_SRC_INC:  3;               /*!< CHB source address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         source
                                                         address cannot cross the 1K boundary within one DMA transfer
                                                         period.                                                               */
           uint32_t             :  1;
      __IO uint32_t  CHB_DST_INC:  3;               /*!< CHB destination address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         destination address cannot cross the 1K boundary within one
                                                         DMA
                                                         transfer period.                                                      */
           uint32_t             :  1;
      __IO uint32_t  CHB_DST_REQ:  4;               /*!< CHB request/grant select of destination when hardware handshake
                                                         mode.                                                                 */
      __IO uint32_t  CHB_DATA_WIDTH:  2;            /*!< CHB data width of the transfer.Note: When the DMA source or
                                                         the destination is the APB device, the
                                                         width of the data must be set as word. The APB device supports
                                                         the word transfer only.                                               */
           uint32_t             :  2;
      __IO uint32_t  CHB_SRC_REQ:  4;               /*!< CHB request/grant select of source when hardware handshake mode.      */
    };
  };
  __IO uint32_t  CHC_SRC_A;                         /*!< CHC source address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
  __IO uint32_t  CHC_DST_A;                         /*!< CHC destination address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
  __IO uint32_t  CHC_SIZE;                          /*!< CHC transfer cycle.
                                                         Total size = CHC_SIZE x 1 when CHC_BURST_MODE=0 (no burst)
                                                         Total size = CHC_SIZE x 4 when CHC_BURST_MODE=1 (burst)
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
  
  union {
    __IO uint32_t  REG_0x00AC;                      /*!< REG_0x00AC                                                            */
    
    struct {
      __IO uint32_t  CHC_EN     :  1;               /*!< Enable DMA CHC transfer.
                                                         Note: This bit will be cleared automatically when all the DMA
                                                         cycles are
                                                         finished.                                                             */
      __IO uint32_t  CHC_FIN_FLAG:  1;              /*!< CHC finishing interrupt flag.
                                                         0: No interrupt occurs
                                                         1: Interrupt occurs
                                                         Note: This bit will be cleared by writing '0'                         */
      __IO uint32_t  CHC_FIN_INTR_EN:  1;           /*!< Enable CHC finished interrupt.                                        */
      __IO uint32_t  CHC_BURST_MODE:  1;            /*!< CHC burst mode.                                                       */
      __IO uint32_t  CHC_ERR_FLAG:  1;              /*!< CHC error response interrupt flag.                                    */
      __IO uint32_t  CHC_ERR_INTR_EN:  1;           /*!< Enable CHC error interrupt when the AHB slave returns an error
                                                         response during a DMA channel A transfer.                             */
      __IO uint32_t  CHC_SRC_SEL:  1;               /*!< CHC source select.                                                    */
      __IO uint32_t  CHC_DST_SEL:  1;               /*!< CHC destination select.                                               */
      __IO uint32_t  CHC_SRC_INC:  3;               /*!< CHC source address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         source
                                                         address cannot cross the 1K boundary within one DMA transfer
                                                         period.                                                               */
           uint32_t             :  1;
      __IO uint32_t  CHC_DST_INC:  3;               /*!< CHC destination address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         destination address cannot cross the 1K boundary within one
                                                         DMA
                                                         transfer period.                                                      */
           uint32_t             :  1;
      __IO uint32_t  CHC_DST_REQ:  4;               /*!< CHC request/grant select of destination when hardware handshake
                                                         mode.                                                                 */
      __IO uint32_t  CHC_DATA_WIDTH:  2;            /*!< CHC data width of the transfer.Note: When the DMA source or
                                                         the destination is the APB device, the
                                                         width of the data must be set as word. The APB device supports
                                                         the word transfer only.                                               */
           uint32_t             :  2;
      __IO uint32_t  CHC_SRC_REQ:  4;               /*!< CHC request/grant select of source when hardware handshake mode.      */
    };
  };
  __IO uint32_t  CHD_SRC_A;                         /*!< CHD source address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         source ending address.                                                */
  __IO uint32_t  CHD_DST_A;                         /*!< CHD destination address.
                                                         Note: When the DMA transaction is done, its value changes to
                                                         the DMA
                                                         destination ending address.                                           */
  __IO uint32_t  CHD_SIZE;                          /*!< CHD transfer cycle.
                                                         Total size = CHD_SIZE x 1 when CHD_BURST_MODE=0 (no burst)
                                                         Total size = CHD_SIZE x 4 when CHD_BURST_MODE=1 (burst)
                                                         Note: When the DMA transaction is done, its value changes to
                                                         0.                                                                    */
  
  union {
    __IO uint32_t  REG_0x00BC;                      /*!< REG_0x00BC                                                            */
    
    struct {
      __IO uint32_t  CHD_EN     :  1;               /*!< Enable DMA CHD transfer.
                                                         Note: This bit will be cleared automatically when all the DMA
                                                         cycles are
                                                         finished.                                                             */
      __IO uint32_t  CHD_FIN_FLAG:  1;              /*!< CHD finishing interrupt flag.
                                                         0: No interrupt occurs
                                                         1: Interrupt occurs
                                                         Note: This bit will be cleared by writing '0'                         */
      __IO uint32_t  CHD_FIN_INTR_EN:  1;           /*!< Enable CHD finished interrupt.                                        */
      __IO uint32_t  CHD_BURST_MODE:  1;            /*!< CHD burst mode.                                                       */
      __IO uint32_t  CHD_ERR_FLAG:  1;              /*!< CHD error response interrupt flag.                                    */
      __IO uint32_t  CHD_ERR_INTR_EN:  1;           /*!< Enable CHD error interrupt when the AHB slave returns an error
                                                         response during a DMA channel A transfer.                             */
      __IO uint32_t  CHD_SRC_SEL:  1;               /*!< CHD source select.                                                    */
      __IO uint32_t  CHD_DST_SEL:  1;               /*!< CHD destination select.                                               */
      __IO uint32_t  CHD_SRC_INC:  3;               /*!< CHD source address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         source
                                                         address cannot cross the 1K boundary within one DMA transfer
                                                         period.                                                               */
           uint32_t             :  1;
      __IO uint32_t  CHD_DST_INC:  3;               /*!< CHD destination address incremental.
                                                         Note: When the DMA is configured in the decreasing mode, the
                                                         destination address cannot cross the 1K boundary within one
                                                         DMA
                                                         transfer period.                                                      */
           uint32_t             :  1;
      __IO uint32_t  CHD_DST_REQ:  4;               /*!< CHD request/grant select of destination when hardware handshake
                                                         mode.                                                                 */
      __IO uint32_t  CHD_DATA_WIDTH:  2;            /*!< CHD data width of the transfer.Note: When the DMA source or
                                                         the destination is the APB device, the
                                                         width of the data must be set as word. The APB device supports
                                                         the word transfer only.                                               */
           uint32_t             :  2;
      __IO uint32_t  CHD_SRC_REQ:  4;               /*!< CHD request/grant select of source when hardware handshake mode.      */
    };
  };
  __I  uint32_t  APBC_REVISION;                     /*!< APBC revision register.                                               */
} APBC_Type;


/* ================================================================================ */
/* ================                       FAT                      ================ */
/* ================================================================================ */


/**
  * @brief FAT Search (FAT)
  */

typedef struct {                                    /*!< FAT Structure                                                         */
  
  union {
    __IO uint32_t  CTRL;                            /*!< Control Register                                                      */
    
    struct {
      __IO uint32_t  EN         :  1;               /*!< Enable FAT                                                            */
      __IO uint32_t  FORMAT     :  1;               /*!< FAT Format                                                            */
      __I  uint32_t  RDY        :  1;               /*!< Ready to Search the FAT Data                                          */
      __I  uint32_t  HMI_ERR    :  1;               /*!< HMI_ERR Flg                                                           */
           uint32_t             :  4;
      __O  uint32_t  CLR_HMI_ERR:  1;               /*!< Clear HMI_ERR Flg                                                     */
    };
  };
  __IO uint32_t  DATA;                              /*!< Search Match Data                                                     */
  __IO uint32_t  SEARCH_ADDR;                       /*!< Search Start Address (Unit:Bytes)                                     */
  __IO uint32_t  SEARCH_LEN;                        /*!< Search Length (Unit:Bytes)                                            */
  __IO uint32_t  RESULT_ADDR;                       /*!< Search Result Address                                                 */
  __I  uint32_t  RESULT_LEN;                        /*!< Search Result Total Length                                            */
  __I  uint32_t  SECTIONS;                          /*!< Number of Matched Sections Searched                                   */
  __I  uint32_t  BLOCKS;                            /*!< Number of Matched Blocks Searched                                     */
  __I  uint32_t  RESERVED[24];
  __I  uint32_t  VERSION;                           /*!< FAT Version for HW Design Data                                        */
} FAT_Type;


/* ================================================================================ */
/* ================                       SSP                      ================ */
/* ================================================================================ */


/**
  * @brief SSP Controller (SSP)
  */

typedef struct {                                    /*!< SSP Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG 0x0000                                                            */
    
    struct {
      __IO uint32_t  SSP_SCLKPH :  1;               /*!< Serial clock (SCLK) phase                                             */
      __IO uint32_t  SSP_SCLKPO :  1;               /*!< Serial clock (SCLK) polarity. (For SPI)                               */
      __IO uint32_t  SSP_OPM    :  2;               /*!< Serial clock (SCLK) polarity. (For SPI)                               */
      __IO uint32_t  SSP_FSJSTFY:  1;               /*!< Data justify. (For I2S)                                               */
      __IO uint32_t  SSP_FSPO   :  1;               /*!< Frame/Sync polarity                                                   */
      __IO uint32_t  SSP_LSB    :  1;               /*!< Bit sequence indicator                                                */
      __IO uint32_t  SSP_LBM    :  1;               /*!< Lookback mode                                                         */
      __IO uint32_t  SSP_FSDIST :  2;               /*!< Frame/Sync and data distance                                          */
           uint32_t             :  2;
      __IO uint32_t  SSP_FFMT   :  3;               /*!< SSP frame format                                                      */
      __IO uint32_t  SSP_GPIO_MODE:  1;             /*!< SSP Mode                                                              */
      __IO uint32_t  SSP_CLK_GPIO_OE:  1;           /*!< Enable SSP_CLK GPIO output                                            */
      __IO uint32_t  SSP_FS_GPIO_OE:  1;            /*!< Enable SSP_FS GPIO output                                             */
      __IO uint32_t  SSP_TX_GPIO_OE:  1;            /*!< Enable SSP_TX GPIO output                                             */
      __IO uint32_t  SSP_RX_GPIO_OE:  1;            /*!< Enable SSP_RX GPIO output                                             */
      __IO uint32_t  SSP_CLK_GPIO_O:  1;            /*!< SSP_CLK GPIO output                                                   */
      __IO uint32_t  SSP_FS_GPIO_O:  1;             /*!< SSP_FS GPIO output                                                    */
      __IO uint32_t  SSP_TX_GPIO_O:  1;             /*!< SSP_TX GPIO output                                                    */
      __IO uint32_t  SSP_RX_GPIO_O:  1;             /*!< SSP_RX GPIO output                                                    */
      __I  uint32_t  SSP_CLK_GPIO_I:  1;            /*!< SSP_CLK GPIO input                                                    */
      __I  uint32_t  SSP_FS_GPIO_I:  1;             /*!< SSP_FS GPIO input                                                     */
      __I  uint32_t  SSP_TX_GPIO_I:  1;             /*!< SSP_TX GPIO input                                                     */
      __I  uint32_t  SSP_RX_GPIO_I:  1;             /*!< SSP_RX GPIO input                                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG 0x0004                                                            */
    
    struct {
      __IO uint32_t  SSP_SCLKDIV: 16;               /*!< Serial clock divider                                                  */
      __IO uint32_t  SSP_SDL    :  5;               /*!< Serial data length                                                    */
           uint32_t             :  3;
      __IO uint32_t  SSP_PDL    :  8;               /*!< Padding data length                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< REG 0x0008                                                            */
    
    struct {
      __IO uint32_t  SSP_EN     :  1;               /*!< Enable SSP                                                            */
      __IO uint32_t  SSP_TXDOE  :  1;               /*!< Transmit data output enable                                           */
      __O  uint32_t  SSP_RXF_CLR:  1;               /*!< Receive FIFO clear                                                    */
      __O  uint32_t  SSP_TXF_CLR:  1;               /*!< Transmit FIFO clear                                                   */
      __IO uint32_t  SSP_ACWRST :  1;               /*!< AC-Link warm reset enable                                             */
      __IO uint32_t  SSP_ACCRST :  1;               /*!< AC-Link cold reset enable                                             */
      __O  uint32_t  SSP_RST    :  1;               /*!< SSP software reset                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< REG 0x000C                                                            */
    
    struct {
      __I  uint32_t  SSP_RXF_FULL:  1;              /*!< Receive FIFO full                                                     */
      __I  uint32_t  SSP_TXF_NFULL:  1;             /*!< Transmit FIFO not full                                                */
      __I  uint32_t  SSP_BUSY   :  1;               /*!< Busy Indicator                                                        */
           uint32_t             :  1;
      __I  uint32_t  SSP_RXF_VE :  5;               /*!< Receive FIFO valid entries                                            */
           uint32_t             :  3;
      __I  uint32_t  SSP_TXF_VE :  5;               /*!< Transmit FIFO valid entries                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG 0x0010                                                            */
    
    struct {
      __IO uint32_t  SSP_RXF_OR_INTR_EN:  1;        /*!< Receive FIFO overrun interrupt enable                                 */
      __IO uint32_t  SSP_TXF_UR_INTR_EN:  1;        /*!< Transmit FIFO underrun interrupt enable                               */
      __IO uint32_t  SSP_RXF_TH_INTR_EN:  1;        /*!< Receive FIFO threshold interrupt enable                               */
      __IO uint32_t  SSP_TXF_TH_INTR_EN:  1;        /*!< Transmit FIFO threshold interrupt enable                              */
      __IO uint32_t  SSP_RXF_DMA_EN:  1;            /*!< Receive DMA request enable                                            */
      __IO uint32_t  SSP_TXF_DMA_EN:  1;            /*!< Transmit DMA request enable                                           */
      __IO uint32_t  AC97_FC_INTR_EN:  1;           /*!< AC97 frame complete interrupt enable                                  */
           uint32_t             :  1;
      __IO uint32_t  SSP_RXF_TH :  4;               /*!< Receive FIFO threshold                                                */
      __IO uint32_t  SSP_TXF_TH :  4;               /*!< Transmit FIFO threshold                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< REG 0x0014                                                            */
    
    struct {
      __I  uint32_t  SSP_RXF_OR_FLAG:  1;           /*!< Receive FIFO overrun interrupt flag                                   */
      __I  uint32_t  SSP_TXF_UR_FLAG:  1;           /*!< Transmit FIFO underrun interrupt flag                                 */
      __I  uint32_t  SSP_RXF_TH_FLAG:  1;           /*!< Receive FIFO threshold interrupt flag                                 */
      __I  uint32_t  SSP_TXF_TH_FLAG:  1;           /*!< Transmit FIFO threshold interrupt flag                                */
      __I  uint32_t  AC97_FC_FLAG:  1;              /*!< AC97 frame complete interrupt flag                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REG 0x0018                                                            */
    
    struct {
      __IO uint32_t  SSP_DATA   : 32;               /*!< Separated transmit/receive FIFO for SSP transmit/receive              */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< REG 0x0020                                                            */
    
    struct {
      __IO uint32_t  CODECID    :  2;               /*!< Codec ID                                                              */
           uint32_t             :  1;
      __IO uint32_t  SLOT12V    :  1;               /*!< The 12th slot is valid                                                */
      __IO uint32_t  SLOT11V    :  1;               /*!< The 11th slot is valid                                                */
      __IO uint32_t  SLOT10V    :  1;               /*!< The 10th slot is valid                                                */
      __IO uint32_t  SLOT9V     :  1;               /*!< The 9th slot is valid                                                 */
      __IO uint32_t  SLOT8V     :  1;               /*!< The 8th slot is valid                                                 */
      __IO uint32_t  SLOT7V     :  1;               /*!< The 7th slot is valid                                                 */
      __IO uint32_t  SLOT6V     :  1;               /*!< The 6th slot is valid                                                 */
      __IO uint32_t  SLOT5V     :  1;               /*!< The 5th slot is valid                                                 */
      __IO uint32_t  SLOT4V     :  1;               /*!< The 4th slot is valid                                                 */
      __IO uint32_t  SLOT3V     :  1;               /*!< The 3th slot is valid                                                 */
      __IO uint32_t  SLOT2V     :  1;               /*!< The 2th slot is valid                                                 */
      __IO uint32_t  SLOT1V     :  1;               /*!< The 1th slot is valid                                                 */
      __I  uint32_t  Res15      :  1;               /*!< Always read as 1                                                      */
    };
  };
  __I  uint32_t  RESERVED1[7];
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< REG 0x0040                                                            */
    
    struct {
      __I  uint32_t  SSP_REL_REV:  8;               /*!< Release number                                                        */
      __I  uint32_t  SSP_MINOR_REV:  8;             /*!< Minor revision number                                                 */
      __I  uint32_t  SSP_MAJOR_REV:  8;             /*!< Major revision number                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0044;                      /*!< REG 0x0044                                                            */
    
    struct {
      __I  uint32_t  FIFO_WIDTH :  8;               /*!< Transmit/receive FIFO width                                           */
      __I  uint32_t  RXFIFO_DEPTH:  8;              /*!< Receive FIFO size configuration                                       */
      __I  uint32_t  TXFIFO_DEPTH:  8;              /*!< Transmit FIFO size configuration                                      */
      __I  uint32_t  AC97_FCFG  :  1;               /*!< Intel AC-Link function configuration                                  */
      __I  uint32_t  I2S_FCFG   :  1;               /*!< Philips I2S function configurations                                   */
      __I  uint32_t  SPIMWR_FCFG:  1;               /*!< Motorola SPI and National Semiconductor Microwire functional
                                                         configurations                                                        */
      __I  uint32_t  SSP_FCFG   :  1;               /*!< TI SSP functional configurations                                      */
    };
  };
} SSP_Type;


/* ================================================================================ */
/* ================                      UART1                     ================ */
/* ================================================================================ */


/**
  * @brief Universal synchronous asynchronous receiver/transmitter
Format:
Start:1, data:8, Parity:0, stop: (1 or 2) (UART1)
  */

typedef struct {                                    /*!< UART1 Structure                                                       */
  
  union {
    __IO uint32_t  UART_CTR;                        /*!< RS232 Control register                                                */
    
    struct {
      __IO uint32_t  TX_MODE    :  1;               /*!< RS232 TX mode                                                         */
      __IO uint32_t  TX_STOP_BIT:  1;               /*!< RS232 stop bit number selection.(0->1bits, 1->2bits)                  */
      __I  uint32_t  TX_RDY     :  1;               /*!< Ready for CPU Write to RS232 TX.                                      */
           uint32_t             :  1;
      __IO uint32_t  RX_MODE    :  1;               /*!< RS232 RX mode                                                         */
      __I  uint32_t  RX_RDY     :  1;               /*!< Ready for CPU read to RS232 RX.                                       */
           uint32_t             :  1;
      __IO uint32_t  RS485_EN   :  1;               /*!< RS485 Mode                                                            */
      __IO uint32_t  RS232_DMA_TX_EN:  1;           /*!< APB DMA Function to Transmit RS232 Data.                              */
      __IO uint32_t  RS232_DMA_RX_EN:  1;           /*!< APB DMA Function to Receive RS232 Data.                               */
      __IO uint32_t  DMA_TX_BURST_MODE:  1;         /*!< DMA TX Burst mode.                                                    */
      __IO uint32_t  DMA_RX_BURST_MODE:  1;         /*!< DMA RX Burst mode.                                                    */
      __IO uint32_t  RTS_CTS_MODE_EN:  1;           /*!< RS232 RTS_CTS Auto Control Flow.                                      */
           uint32_t             :  3;
      __IO uint32_t  RS232_TX_INT_EN:  1;           /*!< RS232_TX_INT Interrupt Flag When TX is Ready.                         */
      __IO uint32_t  RS232_RX_INT_EN:  1;           /*!< RS232_RX_INT Interrupt Flag When RX is Ready.                         */
      __IO uint32_t  RS232_TX_INT_CLR:  1;          /*!< Clear the RS232_TX_INT Flag.                                          */
      __IO uint32_t  RS232_RX_INT_CLR:  1;          /*!< Clear the RS232_RX_INT Flag.                                          */
      __IO uint32_t  RS232_RX_START_ERR_FLAG:  1;   /*!< RS232 RX START BIT has error condition.                               */
      __IO uint32_t  RS232_RX_PARITY_ERR_FLAG:  1;  /*!< RS232 RX Parity Check BIT has error condition.                        */
      __IO uint32_t  RS232_RX_STOP_ERR_FLAG:  1;    /*!< RS232 RX STOP BIT has error condition.                                */
           uint32_t             :  1;
      __IO uint32_t  RS232_RX_START_ERR_FLAG_CLR:  1;/*!< Clear RS232_RX_START_ERR_FLAG.                                       */
      __IO uint32_t  RS232_RX_PARITY_ERR_FLAG_CLR:  1;/*!< Clear RS232_RX_PARITY_ERR_FLAG.                                     */
      __IO uint32_t  RS232_RX_STOP_ERR_FLAG_CLR:  1;/*!< Clear RS232_RX_STOP_ERR_FLAG_CLR.                                     */
           uint32_t             :  1;
      __IO uint32_t  RS232_TX_PARITY_EN:  1;        /*!< RS232 TX Has Parity Check Function.                                   */
      __IO uint32_t  RS232_TX_PARITY_EVEN:  1;      /*!< RS232 TX Parity Check Function is exclusive or.                       */
      __IO uint32_t  RS232_RX_PARITY_EN:  1;        /*!< RS232 RX Has Parity Check Function.                                   */
      __IO uint32_t  RS232_RX_PARITY_EVEN:  1;      /*!< RS232 RX Parity Check Function is exclusive or.                       */
    };
  };
  
  union {
    __IO uint32_t  UART_DMA_TX_SIZE;                /*!< REG_0x0004                                                            */
    
    struct {
      __IO uint32_t  DMA_TX_SIZE: 24;               /*!< RS232 TX DMA Transfer SIZE. 
                                                         Note :
                                                         Total size = APB_DMA_CH_SIZE X1 when
                                                          APB_DMA_CH_BURST_MODE = 0 (no Burst)
                                                         Total size = APB_DMA_SIZE X4 when
                                                         APB_DMA_CH_BURST_MODE = 1 (Burst)
                                                                                                                               */
    };
  };
  
  union {
    __IO uint32_t  UART_DMA_RX_SIZE;                /*!< REG_0x0008                                                            */
    
    struct {
      __IO uint32_t  DMA_RX_SIZE: 24;               /*!< RS232 RX DMA Transfer SIZE.
                                                         Note :
                                                         Total size = APB_DMA_CH_SIZE X1 when
                                                          APB_DMA_CH_BURST_MODE = 0 (no Burst)
                                                         Total size = APB_DMA_SIZE X4 when 
                                                         APB_DMA_CH_BURST_MODE = 1 (Burst)
                                                                                                                               */
    };
  };
  
  union {
    __IO uint32_t  UART_RATE;                       /*!< REG_0x000C                                                            */
    
    struct {
      __IO uint32_t  RS_RATE    :  7;               /*!< RS232 transition rate
                                                         Speed = 115200/RS_RATE bps                                            */
      __IO uint32_t  TRX_BASE   :  7;               /*!< Used to generate the 115200 Hz clock.
                                                         F115200 = UCLK / 8 / TRX_BASE                                         */
    };
  };
  __IO uint32_t  RS_DATA;                           /*!< Data Port for CPU Read or Write RS232.
                                                         Note: 
                                                         When CPU_DATA_MODE[1:0] = 2b00, the Data unit is 8 bits only.(RS_DATA[7:0]
                                                         )
                                                         CPU_DATA_MODE[1:0] = 2b01, the Data unit is 16 bits only.(RS_DATA[15:0])
                                                         CPU_DATA_MODE[1:0] = 2b10, the Data unit is 24 bits only.(RS_DATA[23:0])
                                                         CPU_DATA_MODE[1:0] = 2b11, the Data unit is 32 bits only.(RS_DATA[31:0]) */
  
  union {
    __IO uint32_t  UART_GPIO;                       /*!< REG_0x0014                                                            */
    
    struct {
      __I  uint32_t  TX_I       :  1;               /*!< Input value for TX GPIO.                                              */
      __IO uint32_t  TX_O       :  1;               /*!< Output value for TX GPIO.                                             */
      __IO uint32_t  TX_OE      :  1;               /*!< Output enable for TX GPIO.                                            */
           uint32_t             :  1;
      __I  uint32_t  RX_I       :  1;               /*!< Input value for RX GPIO.                                              */
      __IO uint32_t  RX_O       :  1;               /*!< Output value for RX GPIO.                                             */
      __IO uint32_t  RX_OE      :  1;               /*!< Output enable for RX GPIO.                                            */
           uint32_t             :  1;
      __IO uint32_t  CPU_DATA_MODE:  2;             /*!< CPU Data Mode.                                                        */
           uint32_t             :  2;
      __IO uint32_t  CTS_EN_FIFO_THD:  5;           /*!< When CTS_RTS_MODE_EN = 1, 
                                                         the numbers of Data that can be read in the RX 32x8bits FIFO
                                                         is >= (d32- CTS_EN_FIFO_THD),
                                                         HW will pull the CTS Signal High to disable receive data from
                                                          RX Port.                                                             */
           uint32_t             :  7;
      __I  uint32_t  RTS_I      :  1;               /*!< Input value for RTS GPIO.                                             */
      __IO uint32_t  RTS_O      :  1;               /*!< Output value for RTS GPIO.                                            */
      __IO uint32_t  RTS_OE     :  1;               /*!< Output enable for RTS GPIO.                                           */
           uint32_t             :  1;
      __I  uint32_t  CTS_I      :  1;               /*!< Input value for CTS GPIO.                                             */
      __IO uint32_t  CTS_O      :  1;               /*!< Output value for CTS GPIO.                                            */
      __IO uint32_t  CTS_OE     :  1;               /*!< Output enable for CTS GPIO.                                           */
    };
  };
  
  union {
    __IO uint32_t  UART_FIFO;                       /*!< REG_0x0018                                                            */
    
    struct {
      __IO uint32_t  TX_FIFO_THD:  5;               /*!< When use CPU to Write RS232 Data, the TX_RDY will be 1 when
                                                          the Data number that has been Written to TX 32x8bits FIFO <=
                                                         TX_FIFO_THD.                                                          */
           uint32_t             :  3;
      __IO uint32_t  RX_FIFO_THD:  5;               /*!< When use CPU to Read RS232 Data, the RX_RDY will be 1 whenthe
                                                         Data that can be read in the RX 32x8bits FIFO >= RX_FIFO_THD.
                                                                                                                               */
           uint32_t             :  3;
      __I  uint32_t  TX_FIFO_CNT:  6;               /*!< The Data Number which is Stored in TX 32x8 bits FIFO.                 */
           uint32_t             :  2;
      __I  uint32_t  RX_FIFO_CNT:  6;               /*!< The Data Number which is Stored in RX 32x8 bits FIFO.                 */
    };
  };
  __IO uint32_t  UART_VER;                          /*!< UART version.                                                         */
} UART1_Type;


/* ================================================================================ */
/* ================                      INTC                      ================ */
/* ================================================================================ */


/**
  * @brief Interrupt Controller (INTC)
  */

typedef struct {                                    /*!< INTC Structure                                                        */
  __I  uint32_t  IRQ0_SCR;                          /*!< Records the status of the interrupt source of IRQ
                                                         Note: Set to 1 when IRQ input is asserted no matter IRQ_EN is
                                                         1 or 0.                                                               */
  __IO uint32_t  IRQ0_EN;                           /*!< Enables the interrupt source of IRQ.
                                                         0: Disables the interrupt source
                                                         1: Enables the interrupt source
                                                         Note: Flowing is IRQ assignment.
                                                         IRQ[0] : TIMER1_INT
                                                         IRQ[1] : TIMER2_INT
                                                         IRQ[2] : TIMER3_INT
                                                         IRQ[3] : USB20_Device INT
                                                         IRQ[4] : USB20 HOST 2 INT
                                                         IRQ[5] : USB20 HOST 1 INT
                                                         IRQ[6] : LCD_INT
                                                         IRQ[7] : MIPI_INT
                                                         IRQ[8] : SEN_HSYNC_INT
                                                         IRQ[9] : ISP_WIN_END_INT
                                                         IRQ[10] : SEN_VSYNC_INT
                                                         IRQ[11] : ISP_DIS_INT
                                                         IRQ[12] : IMG_TX_INTIRQ[13] : H264_ENCODE_INT
                                                         IRQ[14] : JPEG_INT
                                                         IRQ[15] : RF1_INT
                                                         IRQ[16] : RF2_INT
                                                         IRQ[17]                                                               */
  __O  uint32_t  CLR_IRQ0;                          /*!< When set to 1, this bit will be reset to zero automatically
                                                         after clearing the interrupt status.
                                                         Note: This register takes effect only when the input interrupt
                                                          sources are in edge trigger mode.                                    */
  __IO uint32_t  IRQ0_TRG_MODE;                     /*!< The type of interrupt source of IRQ.
                                                         0: Level-trigger mode
                                                         1: Edge-trigger mode                                                  */
  __IO uint32_t  IRQ0_TRG_LEVEL;                    /*!< The trigger level of interrupt source of IRQ
                                                         0: Active-high level trigger or rising-edge trigger
                                                         1: Active-low level trigger or falling-edge trigger                   */
  __I  uint32_t  IRQ0_FLAG;                         /*!< Records the IRQ status after masking.
                                                         0: No interrupt
                                                         1: Interrupt is asserted
                                                         Note: IRQ_FLAG=IRQ_SRC & IRQ_EN                                       */
  __I  uint32_t  RESERVED[2];
  __I  uint32_t  FIQ_SCR;                           /*!< Records the status of the interrupt source of FIQ
                                                         Note: Set to 1 when FIQ input is asserted no matter FIQ_EN is
                                                         1 or 0.                                                               */
  __IO uint32_t  FIQ_EN;                            /*!< Enables the interrupt source of FIQ.
                                                         0: Disables the interrupt source
                                                         1: Enables the interrupt source
                                                         Note: Following is the FIQ assignment                                 */
  __O  uint32_t  CLR_FIQ;                           /*!< When set to 1, this bit will be reset to zero automatically
                                                         after clearing the interrupt status.
                                                         Note: This register takes effect only when the input interrupt
                                                          sources are in edge trigger mode.                                    */
  __IO uint32_t  FIQ_TRG_MODE;                      /*!< The type of interrupt source of FIQ.
                                                         0: Level-trigger mode
                                                         1: Edge-trigger mode                                                  */
  __IO uint32_t  FIQ_TRG_LEVEL;                     /*!< The trigger level of interrupt source of FIQ
                                                         0: Active-high level trigger or rising-edge trigger
                                                         1: Active-low level trigger or falling-edge trigger                   */
  __I  uint32_t  FIQ_FLAG;                          /*!< Records the FIQ status after masking.
                                                         0: No interrupt
                                                         1: Interrupt is asserted
                                                         Note: FIQ_FLAG=FIQ_SRC & FIQ_EN                                       */
  __I  uint32_t  RESERVED1[6];
  __I  uint32_t  INTC_REVISION;                     /*!< Interrupt controller revision.                                        */
  
  union {
    __I  uint32_t  INTC_NUMBER;                     /*!< Records supported IRQ & FIQ pin number.                               */
    
    struct {
      __I  uint32_t  FIQ_NUMBER :  8;               /*!< Records supported FIQ pin number.                                     */
      __I  uint32_t  IRQ_NUMBER :  8;               /*!< Records supported IRQ pin number.                                     */
    };
  };
  __I  uint32_t  IRQ0_DEBOUNCE;                     /*!< Records IRQ interrupt source with de-bounce indication.               */
  __I  uint32_t  FIQ_DEBOUNCE;                      /*!< Records FIQ interrupt source with de-bounce indication.               */
  __I  uint32_t  IRQ1_SCR;                          /*!< Records the status of the interrupt source of IRQ
                                                         Note: Set to 1 when IRQ input is asserted no matter IRQ_EN is
                                                         1 or 0.                                                               */
  __IO uint32_t  IRQ1_EN;                           /*!< Enables the interrupt source of IRQ.
                                                         0: Disables the interrupt source
                                                         1: Enables the interrupt source
                                                         Note: Flowing is IRQ assignment.
                                                         IRQ[32] : AHB0_AHBC_INT
                                                         IRQ[33] : AHBC1_INT
                                                         IRQ[34] : AHBC2_INT
                                                         IRQ[35] : AHBC3_INT
                                                         IRQ[36] : I2C1_INT
                                                         IRQ[37] : I2C2_INT
                                                         IRQ[38] : I2C3_INT
                                                         IRQ[39] : I2C4_INT
                                                         IRQ[40] : I2C5_INT
                                                         IRQ[41] : SSP_INT
                                                         IRQ[42] : APB_INT
                                                         IRQ[43] : DDR_CTRL_INT
                                                         IRQ[44] : WDOG_INT
                                                         IRQ[45] : RTC_ALARM
                                                         IRQ[46] : RTC_WAKEUP
                                                         IRQ[47] : CMDQUE_INT
                                                         IRQ[48] : KEY
                                                         IRQ[49] : RTC_GPIO0
                                                         IRQ[50] : RTC_GPIO1
                                                         IRQ                                                                   */
  __O  uint32_t  CLR_IRQ1;                          /*!< When set to 1, this bit will be reset to zero automatically
                                                         after clearing the interrupt status.
                                                         Note: This register takes effect only when the input interrupt
                                                          sources are in edge trigger mode.                                    */
  __IO uint32_t  IRQ1_TRG_MODE;                     /*!< The type of interrupt source of IRQ.
                                                         0: Level-trigger mode
                                                         1: Edge-trigger mode                                                  */
  __IO uint32_t  IRQ1_TRG_LEVEL;                    /*!< The trigger level of interrupt source of IRQ
                                                         0: Active-high level trigger or rising-edge trigger
                                                         1: Active-low level trigger or falling-edge trigger                   */
  __I  uint32_t  IRQ1_FLAG;                         /*!< Records the IRQ status after masking.
                                                         0: No interrupt
                                                         1: Interrupt is asserted
                                                         Note: IRQ_FLAG=IRQ_SRC & IRQ_EN                                       */
  __I  uint32_t  IRQ1_DEBOUNCE;                     /*!< Records IRQ interrupt source with de-bounce indication.               */
} INTC_Type;


/* ================================================================================ */
/* ================                      I2C1                      ================ */
/* ================================================================================ */


/**
  * @brief I2C Inter-Integrated Circuit (I2C1)
  */

typedef struct {                                    /*!< I2C1 Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< 9240_0000                                                             */
    
    struct {
      __IO uint32_t  I2C_RST    :  1;               /*!< Reset the I2C controller. Note: This bit will automatically
                                                         be cleared after two PCLK clocks.                                     */
      __IO uint32_t  I2C_EN     :  1;               /*!< Enable the I2C bus interface controller.                              */
      __IO uint32_t  I2C_SCL_EN :  1;               /*!< Enable I2C controller clock output for master mode operation.         */
      __IO uint32_t  I2C_GC_EN  :  1;               /*!< Enable I2C controller to respond to a general call message as
                                                         a slave.                                                              */
      __IO uint32_t  I2C_START  :  1;               /*!< When set this register, I2C controller initiates a start condition
                                                         or a repeated start condition. Note: The bit will clear to "0"
                                                          automatically after completion.                                      */
      __IO uint32_t  I2C_STOP   :  1;               /*!< When set this register, I2C controller initiates a stop condition
                                                         after transferring the next data byte on the I2C bus when I2C
                                                          is in master mode. Note: The bit will clear to "0" automatically
                                                          after completion.                                                    */
      __IO uint32_t  I2C_NACK   :  1;               /*!< The acknowledge signal when I2C controller is in master receive
                                                         or slave receive mode. 0: ACK, 1: NACK.                               */
      __IO uint32_t  I2C_TB_EN  :  1;               /*!< When Transfer Byte Enable (TB_EN) is set, I2C controller is
                                                         ready to receive or transmit one byte. Note: The bit will clear
                                                          to "0" automatically after completion.                               */
      __IO uint32_t  I2C_DT_INTR_EN:  1;            /*!< Enables I2C controller to interrupt the host processor when
                                                         DR register has transmitted one data byte onto the I2C bus.           */
      __IO uint32_t  I2C_DR_INTR_EN:  1;            /*!< Enables I2C controller to interrupt the host processor when
                                                         DR register has received one data byte onto the I2C bus.              */
      __IO uint32_t  I2C_BERR_INTR_EN:  1;          /*!< Enables I2C controller to interrupt the host processor when
                                                         detects non-ACK response from slave device after one byte of
                                                          data has been sent in master mode.                                   */
      __IO uint32_t  I2C_STOP_INTR_EN:  1;          /*!< Enables I2C controller to interrupt the host processor when
                                                         detects a stop condition happening on the I2C bus.                    */
      __IO uint32_t  I2C_SAM_INTR_EN:  1;           /*!< Enables I2C controller to interrupt the host processor when
                                                         detects a slave address which matches the SAR register or a
                                                          general call address (When GC_EB is set)                             */
      __IO uint32_t  I2C_AL_INTR_EN:  1;            /*!< Enables I2C controller to interrupt the host processor when
                                                         loses arbitration in master mode.                                     */
      __IO uint32_t  I2C_START_INTR_EN:  1;         /*!< Enables I2C controller to interrupt the host processor when
                                                         detects a start condition happening on the I2C bus.                   */
      __IO uint32_t  I2C_SCL_LOW:  1;               /*!< If set, the SCLout will be tied to 0. For special case, it is
                                                         suggested to set this bit to 0.                                       */
      __IO uint32_t  I2C_SDA_LOW:  1;               /*!< If set, the SDAout will be tied to 0. For special case, it is
                                                         suggested to set this bit to 0.                                       */
      __IO uint32_t  I2C_TEST   :  1;               /*!< Special test mode, which must be set to 0.                            */
    };
  };
  
  union {
    __I  uint32_t  REG_0x0004;                      /*!< I2C1_RW                                                               */
    
    struct {
      __I  uint32_t  I2C_RW     :  1;               /*!< Set when the I2C controller serves in a master-receive or slave-transmit
                                                         mode.                                                                 */
      __I  uint32_t  I2C_NACK_R :  1;               /*!< Set when the I2C controller receives or sends non-acknowledges.       */
      __I  uint32_t  I2C_I2CB   :  1;               /*!< Set when the I2C controller is busy, i.e. during the time period
                                                         between the first start or stop.                                      */
      __I  uint32_t  I2C_BB     :  1;               /*!< Set when the I2C bus is busy, but the I2C controller is not
                                                         involved in the transaction.                                          */
      __I  uint32_t  I2C_DT_FLAG:  1;               /*!< Set when the data register (DR) has transmitted one data byte
                                                         onto the I2C bus. Note: The flag is clear by read this register.      */
      __I  uint32_t  I2C_DR_FLAG:  1;               /*!< Set when the data register (DR) has received one data byte onto
                                                         the I2C bus. Note: The flag is clear by read this register.           */
      __I  uint32_t  I2C_BERR_FLAG:  1;             /*!< Set when I2C controller detects non-ACK responses from the slave
                                                         device after one byte of data has been transmitted. Note: The
                                                          flag is clear by read this register.                                 */
      __I  uint32_t  I2C_STOP_FLAG:  1;             /*!< Set when I2C controller detects a stop condition on the I2C
                                                         bus. Note: The flag is clear by read this register.                   */
      __I  uint32_t  I2C_SAM_FLAG:  1;              /*!< Set when I2C controller receives a slave address which matches
                                                         the address in the slave register (SAR) when slave mode. Note:
                                                          The flag is clear by read this register.                             */
      __I  uint32_t  I2C_GC_FLAG:  1;               /*!< Set when I2C controller receives a slave address which matches
                                                         the general call address (SAR) when slave mode. Note: The flag
                                                          is clear by read this register.                                      */
      __I  uint32_t  I2C_AL_FLAG:  1;               /*!< Set when I2C controller loses arbitration when operating in
                                                         master mode. Note: The flag is clear by read this register.           */
      __I  uint32_t  I2C_START_FLAG:  1;            /*!< Set when I2C controller detects a start condition on the I2C
                                                         bus. Note: The flag is clear by read this register.                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< I2C_SCL_COUNT                                                         */
    
    struct {
      __IO uint32_t  I2C_SCL_COUNT: 10;             /*!< The counter value used to generate an I2C clock (SCLout) from
                                                         the internal bus clock PCLK. SCLout = PCLK / [2*(SCL_COUNT+2)+GSR]
                                                          Note: One limitation is SCL_COUNT > 3+GSR+TSR                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< I2C_DR                                                                */
    
    struct {
      __IO uint32_t  I2C_DR     :  8;               /*!< Buffer for I2C bus data transmission and reception.                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< I2C_SAR                                                               */
    
    struct {
      __IO uint32_t  I2C_SAR    : 10;               /*!< The 7-bit address when the I2C operates in 7-bit address slave
                                                         mode (EN10=0) or
                                                         the least significant 7-bit addresss when the I2C operates in
                                                          10-bits addressing slave mode.
                                                         The most significant 3-bit addres when the I2C operates in 10
                                                          bit addressing slave mode (EN10=1).                                  */
           uint32_t             : 21;
      __IO uint32_t  I2C_EN10   :  1;               /*!< Enable 10bits address mode                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< 9240_0014                                                             */
    
    struct {
      __IO uint32_t  I2C_TSR    : 10;               /*!< The delay values of PCLK clock cycles that the data or acknowledge
                                                         will be driven into the I2C SDA bus after I2C SCL bus goes LOW.       */
      __IO uint32_t  I2C_GSR    :  3;               /*!< Defines the value of PCLK clock period that the I2C bus interface
                                                         has built-in glitch suppression logic. Glitch is suppressed
                                                          according to (GSR * PCLK) clock period.                              */
    };
  };
  
  union {
    __I  uint32_t  REG_0x0018;                      /*!< 9240_0018                                                             */
    
    struct {
      __I  uint32_t  I2C_SDAIN  :  1;               /*!< This bit continuously reflects the value of the SDAin pin.            */
      __I  uint32_t  I2C_SCLIN  :  1;               /*!< This bit continuously reflects the value of the SCLin pin.            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< 9240_001C                                                             */
    
    struct {
      __IO uint32_t  I2C_MODE   :  2;               /*!< 2'b00: Open-drain I2C mode 2'b01: Push-pull I2C mode 2'b1x:
                                                         GPIO mode                                                             */
      __IO uint32_t  SCL_GPIO_OE:  1;               /*!< 1: Enable SCL GPIO output                                             */
      __IO uint32_t  SDA_GPIO_OE:  1;               /*!< 1: Enable SDA GPIO output                                             */
      __IO uint32_t  SCL_GPIO_O :  1;               /*!< SCL GPIO output                                                       */
      __IO uint32_t  SDA_GPIO_O :  1;               /*!< SDA GPIO output                                                       */
      __I  uint32_t  SCL_GPIO_I :  1;               /*!< SCL GPIO input                                                        */
      __I  uint32_t  SDA_GPIO_I :  1;               /*!< SDA GPIO input                                                        */
    };
  };
  __I  uint32_t  RESERVED[4];
  
  union {
    __I  uint32_t  REG_0x0030;                      /*!< I2C_REVISION                                                          */
    
    struct {
      __I  uint32_t  I2C_REVISION: 32;              /*!< The Revision number.                                                  */
    };
  };
  
  union {
    __I  uint32_t  REG_0x0034;                      /*!< I2C_MULTI_MASTER                                                      */
    
    struct {
      __I  uint32_t  I2C_MULTI_MASTER:  1;          /*!< 1: Multi-master mode is configured. 0: Non-multi-master mode
                                                         is configured.                                                        */
    };
  };
} I2C1_Type;


/* ================================================================================ */
/* ================                      WDRT                      ================ */
/* ================================================================================ */


/**
  * @brief Watch Dog Reset Timer (WDRT)
  */

typedef struct {                                    /*!< WDRT Structure                                                        */
  __I  uint32_t  WDOG_COUNTER;                      /*!< The watchdog counter current value. The watchdog counter starts
                                                         to decrease once WDOG_EN=1.
                                                         The watchdog counter holds the value when WDOG_EN=0.                  */
  __IO uint32_t  WDOG_LOAD;                         /*!< The watchdog counter reload values.                                   */
  __O  uint32_t  WDOG_RESTART;                      /*!< The watchdog counter restart.
                                                         Note: If writing 0x5AB9 to this register, the watchdog timer
                                                         will
                                                         automatically reload WDOG_LOAD to WDOG_COUNTER.                       */
  
  union {
    __IO uint32_t  WDOG_CTR;                        /*!< REG_0x000C                                                            */
    
    struct {
      __IO uint32_t  WDOG_EN    :  1;               /*!< 1: Enable watchdog timer                                              */
      __IO uint32_t  WDOG_RST_EN:  1;               /*!< Enable watchdog timer reset system                                    */
      __IO uint32_t  WDOG_INTR_EN:  1;              /*!< Enable watchdog timer system interrupt enable                         */
      __IO uint32_t  WDOG_EXT_EN:  1;               /*!< Enable watchdog timer external signal enable                          */
      __IO uint32_t  WDOG_CLOCK :  1;               /*!< Watch Dog clcok source select                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< REG_0x00010                                                           */
    
    struct {
      __I  uint32_t  WDOG_FLAG  :  1;               /*!< Record if the watchdog timer reaches 0 or not.                        */
    };
  };
  __O  uint8_t   CLR_WDOG_FLAG;                     /*!< When writing 1 to this register, the WDOG_FLAG will be cleared        */
  __I  uint8_t   RESERVED[3];
  __IO uint8_t   WD_LENGTH;                         /*!< The assert duration of wd_rst, wd_intr, and wd_ext signals.
                                                         Assert duration = (WD_LWNGTH + 1) clock                               */
} WDRT_Type;


/* ================================================================================ */
/* ================                      GPIO                      ================ */
/* ================================================================================ */


/**
  * @brief GPIO[20:0] (GPIO)
  */

typedef struct {                                    /*!< GPIO Structure                                                        */
  
  union {
    __IO uint32_t  GPIO_O;                          /*!< GPIO data output                                                      */
    
    struct {
      __IO uint32_t  GPIO_O0    :  1;               /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_O1    :  1;               /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_O2    :  1;               /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_O3    :  1;               /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_O4    :  1;               /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_O5    :  1;               /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_O6    :  1;               /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_O7    :  1;               /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_O8    :  1;               /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_O9    :  1;               /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_O10   :  1;               /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_O11   :  1;               /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_O12   :  1;               /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_O13   :  1;               /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_O14   :  1;               /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_O15   :  1;               /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_O16   :  1;               /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_O17   :  1;               /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_O18   :  1;               /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_O19   :  1;               /*!< GPIO data bit 195                                                     */
      __IO uint32_t  GPIO_O20   :  1;               /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __I  uint32_t  GPIO_I;                          /*!< GPIO data input                                                       */
    
    struct {
      __I  uint32_t  GPIO_I0    :  1;               /*!< GPIO data bit 0                                                       */
      __I  uint32_t  GPIO_I1    :  1;               /*!< GPIO data bit 1                                                       */
      __I  uint32_t  GPIO_I2    :  1;               /*!< GPIO data bit 2                                                       */
      __I  uint32_t  GPIO_I3    :  1;               /*!< GPIO data bit 3                                                       */
      __I  uint32_t  GPIO_I4    :  1;               /*!< GPIO data bit 4                                                       */
      __I  uint32_t  GPIO_I5    :  1;               /*!< GPIO data bit 5                                                       */
      __I  uint32_t  GPIO_I6    :  1;               /*!< GPIO data bit 6                                                       */
      __I  uint32_t  GPIO_I7    :  1;               /*!< GPIO data bit 7                                                       */
      __I  uint32_t  GPIO_I8    :  1;               /*!< GPIO data bit 8                                                       */
      __I  uint32_t  GPIO_I9    :  1;               /*!< GPIO data bit 9                                                       */
      __I  uint32_t  GPIO_I10   :  1;               /*!< GPIO data bit 10                                                      */
      __I  uint32_t  GPIO_I11   :  1;               /*!< GPIO data bit 11                                                      */
      __I  uint32_t  GPIO_I12   :  1;               /*!< GPIO data bit 12                                                      */
      __I  uint32_t  GPIO_I13   :  1;               /*!< GPIO data bit 13                                                      */
      __I  uint32_t  GPIO_I14   :  1;               /*!< GPIO data bit 14                                                      */
      __I  uint32_t  GPIO_I15   :  1;               /*!< GPIO data bit 15                                                      */
      __I  uint32_t  GPIO_I16   :  1;               /*!< GPIO data bit 16                                                      */
      __I  uint32_t  GPIO_I17   :  1;               /*!< GPIO data bit 17                                                      */
      __I  uint32_t  GPIO_I18   :  1;               /*!< GPIO data bit 18                                                      */
      __I  uint32_t  GPIO_I19   :  1;               /*!< GPIO data bit 19                                                      */
      __I  uint32_t  GPIO_I20   :  1;               /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_OE;                         /*!< GPIO output enable
                                                          1: enable
                                                          0: disable                                                           */
    
    struct {
      __IO uint32_t  GPIO_OE0   :  1;               /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_OE1   :  1;               /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_OE2   :  1;               /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_OE3   :  1;               /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_OE4   :  1;               /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_OE5   :  1;               /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_OE6   :  1;               /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_OE7   :  1;               /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_OE8   :  1;               /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_OE9   :  1;               /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_OE10  :  1;               /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_OE11  :  1;               /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_OE12  :  1;               /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_OE13  :  1;               /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_OE14  :  1;               /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_OE15  :  1;               /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_OE16  :  1;               /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_OE17  :  1;               /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_OE18  :  1;               /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_OE19  :  1;               /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_OE20  :  1;               /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_BYP;                        /*!< GPIO bypass mode.
                                                          0: No bypass
                                                          1: Bypass                                                            */
    
    struct {
      __IO uint32_t  GPIO_BYP0  :  1;               /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_BYP1  :  1;               /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_BYP2  :  1;               /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_BYP3  :  1;               /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_BYP4  :  1;               /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_BYP5  :  1;               /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_BYP6  :  1;               /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_BYP7  :  1;               /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_BYP8  :  1;               /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_BYP9  :  1;               /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_BYP10 :  1;               /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_BYP11 :  1;               /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_BYP12 :  1;               /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_BYP13 :  1;               /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_BYP14 :  1;               /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_BYP15 :  1;               /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_BYP16 :  1;               /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_BYP17 :  1;               /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_BYP18 :  1;               /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_BYP19 :  1;               /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_BYP20 :  1;               /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __O  uint32_t  GPIO_O_SET;                      /*!< Set GPIO_O data bit.
                                                         Note: When writing 1 to this register, the corresponding bits
                                                         in GPIO_O
                                                         register are set to one, and the other bits remain unchanged.         */
    
    struct {
      __O  uint32_t  GPIO_O_SET0:  1;               /*!< GPIO data bit 0                                                       */
      __O  uint32_t  GPIO_O_SET1:  1;               /*!< GPIO data bit 1                                                       */
      __O  uint32_t  GPIO_O_SET2:  1;               /*!< GPIO data bit 2                                                       */
      __O  uint32_t  GPIO_O_SET3:  1;               /*!< GPIO data bit 3                                                       */
      __O  uint32_t  GPIO_O_SET4:  1;               /*!< GPIO data bit 4                                                       */
      __O  uint32_t  GPIO_O_SET5:  1;               /*!< GPIO data bit 5                                                       */
      __O  uint32_t  GPIO_O_SET6:  1;               /*!< GPIO data bit 6                                                       */
      __O  uint32_t  GPIO_O_SET7:  1;               /*!< GPIO data bit 7                                                       */
      __O  uint32_t  GPIO_O_SET8:  1;               /*!< GPIO data bit 8                                                       */
      __O  uint32_t  GPIO_O_SET9:  1;               /*!< GPIO data bit 9                                                       */
      __O  uint32_t  GPIO_O_SET10:  1;              /*!< GPIO data bit 10                                                      */
      __O  uint32_t  GPIO_O_SET11:  1;              /*!< GPIO data bit 11                                                      */
      __O  uint32_t  GPIO_O_SET12:  1;              /*!< GPIO data bit 12                                                      */
      __O  uint32_t  GPIO_O_SET13:  1;              /*!< GPIO data bit 13                                                      */
      __O  uint32_t  GPIO_O_SET14:  1;              /*!< GPIO data bit 14                                                      */
      __O  uint32_t  GPIO_O_SET15:  1;              /*!< GPIO data bit 15                                                      */
      __O  uint32_t  GPIO_O_SET16:  1;              /*!< GPIO data bit 16                                                      */
      __O  uint32_t  GPIO_O_SET17:  1;              /*!< GPIO data bit 17                                                      */
      __O  uint32_t  GPIO_O_SET18:  1;              /*!< GPIO data bit 18                                                      */
      __O  uint32_t  GPIO_O_SET19:  1;              /*!< GPIO data bit 19                                                      */
      __O  uint32_t  GPIO_O_SET20:  1;              /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __O  uint32_t  GPIO_O_CLR;                      /*!< Clear GPIO_O data bit.
                                                         Note: When writing 1 to this register, the corresponding bits
                                                         in GPIO_O
                                                          register are cleared to zero, and the other bits remain unchanged.   */
    
    struct {
      __O  uint32_t  GPIO_O_CLR0:  1;               /*!< GPIO data bit 0                                                       */
      __O  uint32_t  GPIO_O_CLR1:  1;               /*!< GPIO data bit 1                                                       */
      __O  uint32_t  GPIO_O_CLR2:  1;               /*!< GPIO data bit 2                                                       */
      __O  uint32_t  GPIO_O_CLR3:  1;               /*!< GPIO data bit 3                                                       */
      __O  uint32_t  GPIO_O_CLR4:  1;               /*!< GPIO data bit 4                                                       */
      __O  uint32_t  GPIO_O_CLR5:  1;               /*!< GPIO data bit 5                                                       */
      __O  uint32_t  GPIO_O_CLR6:  1;               /*!< GPIO data bit 6                                                       */
      __O  uint32_t  GPIO_O_CLR7:  1;               /*!< GPIO data bit 7                                                       */
      __O  uint32_t  GPIO_O_CLR8:  1;               /*!< GPIO data bit 8                                                       */
      __O  uint32_t  GPIO_O_CLR9:  1;               /*!< GPIO data bit 9                                                       */
      __O  uint32_t  GPIO_O_CLR10:  1;              /*!< GPIO data bit 10                                                      */
      __O  uint32_t  GPIO_O_CLR11:  1;              /*!< GPIO data bit 11                                                      */
      __O  uint32_t  GPIO_O_CLR12:  1;              /*!< GPIO data bit 12                                                      */
      __O  uint32_t  GPIO_O_CLR13:  1;              /*!< GPIO data bit 13                                                      */
      __O  uint32_t  GPIO_O_CLR14:  1;              /*!< GPIO data bit 14                                                      */
      __O  uint32_t  GPIO_O_CLR15:  1;              /*!< GPIO data bit 15                                                      */
      __O  uint32_t  GPIO_O_CLR16:  1;              /*!< GPIO data bit 16                                                      */
      __O  uint32_t  GPIO_O_CLR17:  1;              /*!< GPIO data bit 17                                                      */
      __O  uint32_t  GPIO_O_CLR18:  1;              /*!< GPIO data bit 18                                                      */
      __O  uint32_t  GPIO_O_CLR19:  1;              /*!< GPIO data bit 19                                                      */
      __O  uint32_t  GPIO_O_CLR20:  1;              /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_PULL_EN;                    /*!< GPIO pull enable
                                                          0: Disable GPIO pulled function]
                                                          1: Enable GPIO pulled function                                       */
    
    struct {
      __IO uint32_t  GPIO_PULL_EN0:  1;             /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_PULL_EN1:  1;             /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_PULL_EN2:  1;             /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_PULL_EN3:  1;             /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_PULL_EN4:  1;             /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_PULL_EN5:  1;             /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_PULL_EN6:  1;             /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_PULL_EN7:  1;             /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_PULL_EN8:  1;             /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_PULL_EN9:  1;             /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_PULL_EN10:  1;            /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_PULL_EN11:  1;            /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_PULL_EN12:  1;            /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_PULL_EN13:  1;            /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_PULL_EN14:  1;            /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_PULL_EN15:  1;            /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_PULL_EN16:  1;            /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_PULL_EN17:  1;            /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_PULL_EN18:  1;            /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_PULL_EN19:  1;            /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_PULL_EN20:  1;            /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_PULL_HIGH;                  /*!< GPIO pull high or pull low when pulled is enable.
                                                          0: Pulled low 
                                                          1: Pulled high                                                       */
    
    struct {
      __IO uint32_t  GPIO_PULL_HIGH0:  1;           /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_PULL_HIGH1:  1;           /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_PULL_HIGH2:  1;           /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_PULL_HIGH3:  1;           /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_PULL_HIGH4:  1;           /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_PULL_HIGH5:  1;           /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_PULL_HIGH6:  1;           /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_PULL_HIGH7:  1;           /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_PULL_HIGH8:  1;           /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_PULL_HIGH9:  1;           /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_PULL_HIGH10:  1;          /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_PULL_HIGH11:  1;          /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_PULL_HIGH12:  1;          /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_PULL_HIGH13:  1;          /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_PULL_HIGH14:  1;          /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_PULL_HIGH15:  1;          /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_PULL_HIGH16:  1;          /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_PULL_HIGH17:  1;          /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_PULL_HIGH18:  1;          /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_PULL_HIGH19:  1;          /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_PULL_HIGH20:  1;          /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_INTR_EN;                    /*!< GPIO interrupt enable.
                                                          0: Disable GPIO interrupt
                                                          1: Enable GPIO interrupt                                             */
    
    struct {
      __IO uint32_t  GPIO_INTR_EN0:  1;             /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_INTR_EN1:  1;             /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_INTR_EN2:  1;             /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_INTR_EN3:  1;             /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_INTR_EN4:  1;             /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_INTR_EN5:  1;             /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_INTR_EN6:  1;             /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_INTR_EN7:  1;             /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_INTR_EN8:  1;             /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_INTR_EN9:  1;             /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_INTR_EN10:  1;            /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_INTR_EN11:  1;            /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_INTR_EN12:  1;            /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_INTR_EN13:  1;            /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_INTR_EN14:  1;            /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_INTR_EN15:  1;            /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_INTR_EN16:  1;            /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_INTR_EN17:  1;            /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_INTR_EN18:  1;            /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_INTR_EN19:  1;            /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_INTR_EN20:  1;            /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __I  uint32_t  GPIO_RAW_FLAG;                   /*!< GPIO interrupt raw status.
                                                          0: Interrupt is not detected
                                                          1: Interrupt is detected                                             */
    
    struct {
      __I  uint32_t  GPIO_RAW_FLAG0:  1;            /*!< GPIO data bit 0                                                       */
      __I  uint32_t  GPIO_RAW_FLAG1:  1;            /*!< GPIO data bit 1                                                       */
      __I  uint32_t  GPIO_RAW_FLAG2:  1;            /*!< GPIO data bit 2                                                       */
      __I  uint32_t  GPIO_RAW_FLAG3:  1;            /*!< GPIO data bit 3                                                       */
      __I  uint32_t  GPIO_RAW_FLAG4:  1;            /*!< GPIO data bit 4                                                       */
      __I  uint32_t  GPIO_RAW_FLAG5:  1;            /*!< GPIO data bit 5                                                       */
      __I  uint32_t  GPIO_RAW_FLAG6:  1;            /*!< GPIO data bit 6                                                       */
      __I  uint32_t  GPIO_RAW_FLAG7:  1;            /*!< GPIO data bit 7                                                       */
      __I  uint32_t  GPIO_RAW_FLAG8:  1;            /*!< GPIO data bit 8                                                       */
      __I  uint32_t  GPIO_RAW_FLAG9:  1;            /*!< GPIO data bit 9                                                       */
      __I  uint32_t  GPIO_RAW_FLAG10:  1;           /*!< GPIO data bit 10                                                      */
      __I  uint32_t  GPIO_RAW_FLAG11:  1;           /*!< GPIO data bit 11                                                      */
      __I  uint32_t  GPIO_RAW_FLAG12:  1;           /*!< GPIO data bit 12                                                      */
      __I  uint32_t  GPIO_RAW_FLAG13:  1;           /*!< GPIO data bit 13                                                      */
      __I  uint32_t  GPIO_RAW_FLAG14:  1;           /*!< GPIO data bit 14                                                      */
      __I  uint32_t  GPIO_RAW_FLAG15:  1;           /*!< GPIO data bit 15                                                      */
      __I  uint32_t  GPIO_RAW_FLAG16:  1;           /*!< GPIO data bit 16                                                      */
      __I  uint32_t  GPIO_RAW_FLAG17:  1;           /*!< GPIO data bit 17                                                      */
      __I  uint32_t  GPIO_RAW_FLAG18:  1;           /*!< GPIO data bit 18                                                      */
      __I  uint32_t  GPIO_RAW_FLAG19:  1;           /*!< GPIO data bit 19                                                      */
      __I  uint32_t  GPIO_RAW_FLAG20:  1;           /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __I  uint32_t  GPIO_INTR_FLAG;                  /*!< GPIO interrupt status after masking.
                                                          0: Interrupt is not detected
                                                          1: Interrupt is detected
                                                          Note: GPIO_INTR_FLAG=GPIO_RAW_FLAG & ~GPIO_INTR_MSK                  */
    
    struct {
      __I  uint32_t  GPIO_INTR_FLAG0:  1;           /*!< GPIO data bit 0                                                       */
      __I  uint32_t  GPIO_INTR_FLAG1:  1;           /*!< GPIO data bit 1                                                       */
      __I  uint32_t  GPIO_INTR_FLAG2:  1;           /*!< GPIO data bit 2                                                       */
      __I  uint32_t  GPIO_INTR_FLAG3:  1;           /*!< GPIO data bit 3                                                       */
      __I  uint32_t  GPIO_INTR_FLAG4:  1;           /*!< GPIO data bit 4                                                       */
      __I  uint32_t  GPIO_INTR_FLAG5:  1;           /*!< GPIO data bit 5                                                       */
      __I  uint32_t  GPIO_INTR_FLAG6:  1;           /*!< GPIO data bit 6                                                       */
      __I  uint32_t  GPIO_INTR_FLAG7:  1;           /*!< GPIO data bit 7                                                       */
      __I  uint32_t  GPIO_INTR_FLAG8:  1;           /*!< GPIO data bit 8                                                       */
      __I  uint32_t  GPIO_INTR_FLAG9:  1;           /*!< GPIO data bit 9                                                       */
      __I  uint32_t  GPIO_INTR_FLAG10:  1;          /*!< GPIO data bit 10                                                      */
      __I  uint32_t  GPIO_INTR_FLAG11:  1;          /*!< GPIO data bit 11                                                      */
      __I  uint32_t  GPIO_INTR_FLAG12:  1;          /*!< GPIO data bit 12                                                      */
      __I  uint32_t  GPIO_INTR_FLAG13:  1;          /*!< GPIO data bit 13                                                      */
      __I  uint32_t  GPIO_INTR_FLAG14:  1;          /*!< GPIO data bit 14                                                      */
      __I  uint32_t  GPIO_INTR_FLAG15:  1;          /*!< GPIO data bit 15                                                      */
      __I  uint32_t  GPIO_INTR_FLAG16:  1;          /*!< GPIO data bit 16                                                      */
      __I  uint32_t  GPIO_INTR_FLAG17:  1;          /*!< GPIO data bit 17                                                      */
      __I  uint32_t  GPIO_INTR_FLAG18:  1;          /*!< GPIO data bit 18                                                      */
      __I  uint32_t  GPIO_INTR_FLAG19:  1;          /*!< GPIO data bit 19                                                      */
      __I  uint32_t  GPIO_INTR_FLAG20:  1;          /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_INTR_MSK;                   /*!< GPIO interrupt mask
                                                          0: Disable mask.
                                                          1: Enable mask                                                       */
    
    struct {
      __IO uint32_t  GPIO_INTR_MSK0:  1;            /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_INTR_MSK1:  1;            /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_INTR_MSK2:  1;            /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_INTR_MSK3:  1;            /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_INTR_MSK4:  1;            /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_INTR_MSK5:  1;            /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_INTR_MSK6:  1;            /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_INTR_MSK7:  1;            /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_INTR_MSK8:  1;            /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_INTR_MSK9:  1;            /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_INTR_MSK10:  1;           /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_INTR_MSK11:  1;           /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_INTR_MSK12:  1;           /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_INTR_MSK13:  1;           /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_INTR_MSK14:  1;           /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_INTR_MSK15:  1;           /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_INTR_MSK16:  1;           /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_INTR_MSK17:  1;           /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_INTR_MSK18:  1;           /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_INTR_MSK19:  1;           /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_INTR_MSK20:  1;           /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __O  uint32_t  CLR_GPIO_INTR;                   /*!< GPIO interrupt clear.
                                                          0: No effect 
                                                          1: Clear interrupt                                                   */
    
    struct {
      __O  uint32_t  CLR_GPIO_INTR0:  1;            /*!< GPIO data bit 0                                                       */
      __O  uint32_t  CLR_GPIO_INTR1:  1;            /*!< GPIO data bit 1                                                       */
      __O  uint32_t  CLR_GPIO_INTR2:  1;            /*!< GPIO data bit 2                                                       */
      __O  uint32_t  CLR_GPIO_INTR3:  1;            /*!< GPIO data bit 3                                                       */
      __O  uint32_t  CLR_GPIO_INTR4:  1;            /*!< GPIO data bit 4                                                       */
      __O  uint32_t  CLR_GPIO_INTR5:  1;            /*!< GPIO data bit 5                                                       */
      __O  uint32_t  CLR_GPIO_INTR6:  1;            /*!< GPIO data bit 6                                                       */
      __O  uint32_t  CLR_GPIO_INTR7:  1;            /*!< GPIO data bit 7                                                       */
      __O  uint32_t  CLR_GPIO_INTR8:  1;            /*!< GPIO data bit 8                                                       */
      __O  uint32_t  CLR_GPIO_INTR9:  1;            /*!< GPIO data bit 9                                                       */
      __O  uint32_t  CLR_GPIO_INTR10:  1;           /*!< GPIO data bit 10                                                      */
      __O  uint32_t  CLR_GPIO_INTR11:  1;           /*!< GPIO data bit 11                                                      */
      __O  uint32_t  CLR_GPIO_INTR12:  1;           /*!< GPIO data bit 12                                                      */
      __O  uint32_t  CLR_GPIO_INTR13:  1;           /*!< GPIO data bit 13                                                      */
      __O  uint32_t  CLR_GPIO_INTR14:  1;           /*!< GPIO data bit 14                                                      */
      __O  uint32_t  CLR_GPIO_INTR15:  1;           /*!< GPIO data bit 15                                                      */
      __O  uint32_t  CLR_GPIO_INTR16:  1;           /*!< GPIO data bit 16                                                      */
      __O  uint32_t  CLR_GPIO_INTR17:  1;           /*!< GPIO data bit 17                                                      */
      __O  uint32_t  CLR_GPIO_INTR18:  1;           /*!< GPIO data bit 18                                                      */
      __O  uint32_t  CLR_GPIO_INTR19:  1;           /*!< GPIO data bit 195                                                     */
      __O  uint32_t  CLR_GPIO_INTR20:  1;           /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_TRG_MODE;                   /*!< GPIO interrupt trigger mode.
                                                          0: Edge trigger
                                                          1: Level trigger                                                     */
    
    struct {
      __IO uint32_t  GPIO_TRG_MODE0:  1;            /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_TRG_MODE1:  1;            /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_TRG_MODE2:  1;            /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_TRG_MODE3:  1;            /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_TRG_MODE4:  1;            /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_TRG_MODE5:  1;            /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_TRG_MODE6:  1;            /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_TRG_MODE7:  1;            /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_TRG_MODE8:  1;            /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_TRG_MODE9:  1;            /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_TRG_MODE10:  1;           /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_TRG_MODE11:  1;           /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_TRG_MODE12:  1;           /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_TRG_MODE13:  1;           /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_TRG_MODE14:  1;           /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_TRG_MODE15:  1;           /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_TRG_MODE16:  1;           /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_TRG_MODE17:  1;           /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_TRG_MODE18:  1;           /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_TRG_MODE19:  1;           /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_TRG_MODE20:  1;           /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_TRG_EDGE;                   /*!< GPIO interrupt edge trigger by single or both edge.
                                                          0: Single edge
                                                          1: Both edges                                                        */
    
    struct {
      __IO uint32_t  GPIO_TRG_EDGE0:  1;            /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_TRG_EDGE1:  1;            /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_TRG_EDGE2:  1;            /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_TRG_EDGE3:  1;            /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_TRG_EDGE4:  1;            /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_TRG_EDGE5:  1;            /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_TRG_EDGE6:  1;            /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_TRG_EDGE7:  1;            /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_TRG_EDGE8:  1;            /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_TRG_EDGE9:  1;            /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_TRG_EDGE10:  1;           /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_TRG_EDGE11:  1;           /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_TRG_EDGE12:  1;           /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_TRG_EDGE13:  1;           /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_TRG_EDGE14:  1;           /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_TRG_EDGE15:  1;           /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_TRG_EDGE16:  1;           /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_TRG_EDGE17:  1;           /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_TRG_EDGE18:  1;           /*!< GPIO data bit 185                                                     */
      __IO uint32_t  GPIO_TRG_EDGE19:  1;           /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_TRG_EDGE20:  1;           /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_TRG_LEVEL;                  /*!< GPIO interrupt trigger level.
                                                          0 : Active-high level or rising-edge trigger
                                                          1 : Active-low level or falling-edge trigger                         */
    
    struct {
      __IO uint32_t  GPIO_TRG_LEVEL0:  1;           /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL1:  1;           /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL2:  1;           /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL3:  1;           /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL4:  1;           /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL5:  1;           /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL6:  1;           /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL7:  1;           /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL8:  1;           /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL9:  1;           /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_TRG_LEVEL10:  1;          /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL11:  1;          /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL12:  1;          /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL13:  1;          /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL14:  1;          /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL15:  1;          /*!< GPIO data bit 15                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL16:  1;          /*!< GPIO data bit 16                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL17:  1;          /*!< GPIO data bit 17                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL18:  1;          /*!< GPIO data bit 18                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL19:  1;          /*!< GPIO data bit 19                                                      */
      __IO uint32_t  GPIO_TRG_LEVEL20:  1;          /*!< GPIO data bit 20                                                      */
    };
  };
  
  union {
    __IO uint32_t  GPIO_BOUNCE_EN;                  /*!< GPIO pre-scale clock enable.
                                                          0: Disable 
                                                          1: Enable
                                                          Note: When enabled, PCLK will be divided by BouncePreScale
                                                         clocks.
                                                          This signal is used to extend the clock cycle of detecting
                                                          interrupt.                                                           */
    
    struct {
      __IO uint32_t  GPIO_BOUNCE_EN0:  1;           /*!< GPIO data bit 0                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN1:  1;           /*!< GPIO data bit 1                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN2:  1;           /*!< GPIO data bit 2                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN3:  1;           /*!< GPIO data bit 3                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN4:  1;           /*!< GPIO data bit 4                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN5:  1;           /*!< GPIO data bit 5                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN6:  1;           /*!< GPIO data bit 6                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN7:  1;           /*!< GPIO data bit 7                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN8:  1;           /*!< GPIO data bit 8                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN9:  1;           /*!< GPIO data bit 9                                                       */
      __IO uint32_t  GPIO_BOUNCE_EN10:  1;          /*!< GPIO data bit 10                                                      */
      __IO uint32_t  GPIO_BOUNCE_EN11:  1;          /*!< GPIO data bit 11                                                      */
      __IO uint32_t  GPIO_BOUNCE_EN12:  1;          /*!< GPIO data bit 12                                                      */
      __IO uint32_t  GPIO_BOUNCE_EN13:  1;          /*!< GPIO data bit 13                                                      */
      __IO uint32_t  GPIO_BOUNCE_EN14:  1;          /*!< GPIO data bit 14                                                      */
      __IO uint32_t  GPIO_BOUNCE_EN15:  1;          /*!< GPIO data bit 15                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0044;                      /*!< 92B0_0044                                                             */
    
    struct {
      __IO uint32_t  GPIO_PRESCALE: 24;             /*!< GPIO Pre-scale, used to adjust different PCLK frequencies.(1~ffffff)
                                                          Note: If GPIO_BOUNCE_PRESCALE is zero, and bounce is enabled,
                                                         the pin will not detect any interrupt.                                */
    };
  };
} GPIO_Type;


/* ================================================================================ */
/* ================                     Timer1                     ================ */
/* ================================================================================ */


/**
  * @brief Timer1 function (Timer1)
  */

typedef struct {                                    /*!< Timer1 Structure                                                      */
  __IO uint32_t  TM1_COUNTER;                       /*!< Timer1 counter.                                                       */
  __IO uint32_t  TM1_LOAD;                          /*!< Timer1 auto reload value.
                                                         Note: When timer1 overflow or underflow occurs, TM1_LOAD is
                                                         load
                                                         into TM1_COUNTER.                                                     */
  __IO uint32_t  TM1_MATCH1;                        /*!< Timer1 match value 1.                                                 */
  __IO uint32_t  TM1_MATCH2;                        /*!< Timer1 match value 2.                                                 */
  __IO uint32_t  TM2_COUNTER;                       /*!< Timer2 counter.                                                       */
  __IO uint32_t  TM2_LOAD;                          /*!< Timer2 auto reload value.
                                                         Note: When timer2 overflow or underflow occurs, TM2_LOAD is
                                                         load
                                                         into TM2_COUNTER                                                      */
  __IO uint32_t  TM2_MATCH1;                        /*!< Timer2 match value 1.                                                 */
  __IO uint32_t  TM2_MATCH2;                        /*!< Timer2 match value 2.                                                 */
  __IO uint32_t  TM3_COUNTER;                       /*!< Timer3 counter.                                                       */
  __IO uint32_t  TM3_LOAD;                          /*!< Timer3 auto reload value.
                                                         Note: When timer1 overflow or underflow occurs, TM3_LOAD is
                                                         load
                                                         into TM3_COUNTER                                                      */
  __IO uint32_t  TM3_MATCH1;                        /*!< Timer3 match value 1.                                                 */
  __IO uint32_t  TM3_MATCH2;                        /*!< Timer3 match value 2.                                                 */
  
  union {
    __IO uint32_t  TIMER_CTR;                       /*!< Timer Control register                                                */
    
    struct {
      __IO uint32_t  TM1_EN     :  1;               /*!< Tiemr 1 enable bit                                                    */
      __IO uint32_t  TM1_CLOCK  :  1;               /*!< Tiemr 1 clock source select                                           */
      __IO uint32_t  TM1_OF_EN  :  1;               /*!< Timer1 overflow interrup enable bit                                   */
      __IO uint32_t  TM2_EN     :  1;               /*!< Tiemr 2 enable bit                                                    */
      __IO uint32_t  TM2_CLOCK  :  1;               /*!< Tiemr 2 clock source select                                           */
      __IO uint32_t  TM2_OF_EN  :  1;               /*!< Timer2 overflow interrup enable bit                                   */
      __IO uint32_t  TM3_EN     :  1;               /*!< Tiemr 3 enable bit                                                    */
      __IO uint32_t  TM3_CLOCK  :  1;               /*!< Tiemr 3 clock source select                                           */
      __IO uint32_t  TM3_OF_EN  :  1;               /*!< Timer3 overflow interrup enable bit                                   */
      __IO uint32_t  TM1_UPDOWN :  1;               /*!< Timer1 count type select                                              */
      __IO uint32_t  TM2_UPDOWN :  1;               /*!< Timer2 count type select                                              */
      __IO uint32_t  TM3_UPDOWN :  1;               /*!< Timer3 count type select                                              */
    };
  };
  
  union {
    __IO uint32_t  TIMER_FLAG;                      /*!< Timer Flag                                                            */
    
    struct {
      __I  uint32_t  TM1_MATCH1_FLAG:  1;           /*!< Timer1 match1 interrupt flag.                                         */
      __I  uint32_t  TM1_MATCH2_FLAG:  1;           /*!< Timer1 match2 interrupt flag.                                         */
      __I  uint32_t  TM1_OF_FLAG:  1;               /*!< Timer1 overflow interrupt flag.                                       */
      __I  uint32_t  TM2_MATCH1_FLAG:  1;           /*!< Timer2 match1 interrupt flag.                                         */
      __I  uint32_t  TM2_MATCH2_FLAG:  1;           /*!< Timer2 match2 interrupt flag.                                         */
      __I  uint32_t  TM2_OF_FLAG:  1;               /*!< Timer2 overflow interrupt flag.                                       */
      __I  uint32_t  TM3_MATCH1_FLAG:  1;           /*!< Timer3 match1 interrupt flag.                                         */
      __I  uint32_t  TM3_MATCH2_FLAG:  1;           /*!< Timer3 match2 interrupt flag.                                         */
      __I  uint32_t  TM3_OF_FLAG:  1;               /*!< Timer3 overflow interrupt flag.                                       */
      __O  uint32_t  CLR_TM1_MATCH1_FLAG:  1;       /*!< Write 1 to clear Timer1 match1 interrupt flag.                        */
      __O  uint32_t  CLR_TM1_MATCH2_FLAG:  1;       /*!< Write 1 to clear Timer1 match2 interrupt flag.                        */
      __O  uint32_t  CLR_TM1_OF_FLAG:  1;           /*!< Write 1 to clear Timer1 overflow interrupt flag.                      */
      __O  uint32_t  CLR_TM2_MATCH1_FLAG:  1;       /*!< Write 1 to clear Timer2 match1 interrupt flag.                        */
      __O  uint32_t  CLR_TM2_MATCH2_FLAG:  1;       /*!< Write 1 to clear Timer2 match2 interrupt flag.                        */
      __O  uint32_t  CLR_TM2_OF_FLAG:  1;           /*!< Write 1 to clear Timer2 overflow interrupt flag.                      */
      __O  uint32_t  CLR_TM3_MATCH1_FLAG:  1;       /*!< Write 1 to clear Timer3 match1 interrupt flag.                        */
      __O  uint32_t  CLR_TM3_MATCH2_FLAG:  1;       /*!< Write 1 to clear Timer3 match2 interrupt flag.                        */
      __O  uint32_t  CLR_TM3_OF_FLAG:  1;           /*!< Write 1 to clear Timer3 overflow interrupt flag.                      */
    };
  };
  
  union {
    __IO uint32_t  TIMER_MASK;                      /*!< Timer Mask                                                            */
    
    struct {
      __IO uint32_t  TM1_MATCH1_MSK:  1;            /*!< 1: Mask timer1 match1 interrupt (not affect TM1_MATCH1_FLAG)          */
      __IO uint32_t  TM1_MATCH2_MSK:  1;            /*!< 1: Mask timer1 match2 interrupt (not affect TM1_MATCH2_FLAG)          */
      __IO uint32_t  TM1_OF_MSK :  1;               /*!< 1: Mask timer1 overflow interrupt (not affect TM1_OF_FLAG)            */
      __IO uint32_t  TM2_MATCH1_MSK:  1;            /*!< 1: Mask timer2 match1 interrupt (not affect TM2_MATCH1_FLAG)          */
      __IO uint32_t  TM2_MATCH2_MSK:  1;            /*!< 1: Mask timer2 match2 interrupt (not affect TM2_MATCH2_FLAG)          */
      __IO uint32_t  TM2_OF_MSK :  1;               /*!< 1: Mask timer2 overflow interrupt (not affect TM2_OF_FLAG)            */
      __IO uint32_t  TM3_MATCH1_MSK:  1;            /*!< 1: Mask timer3 match1 interrupt (not affect TM3_MATCH1_FLAG)          */
      __IO uint32_t  TM3_MATCH2_MSK:  1;            /*!< 1: Mask timer3 match2 interrupt (not affect TM3_MATCH2_FLAG)          */
      __IO uint32_t  TM3_OF_MSK :  1;               /*!< 1: Mask timer3 overflow interrupt (not affect TM3_OF_FLAG)            */
    };
  };
} Timer1_Type;


/* ================================================================================ */
/* ================                      AHB2                      ================ */
/* ================================================================================ */


/**
  * @brief AHB2 Controller (Arbiter / Decoder / Multiplexer) (AHB2)
  */

typedef struct {                                    /*!< AHB2 Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x0000                                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  HS0_SIZE   :  4;               /*!< AHB slave0 space size. (DDR Channel 6)                                */
      __IO uint32_t  HS0_BASE   : 12;               /*!< AHB slave0 base address of [31:20] (unit: 1MB)
                                                         Note: Base address must be multiple of space size.                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  HS1_SIZE   :  4;               /*!< AHB slave1 space size. (AHB0 Bridge Slaver)                           */
      __IO uint32_t  HS1_BASE   : 12;               /*!< AHB slave1 base address of [31:20] (unit: 1MB)
                                                         Note: Base address must be multiple of space size.
                                                          32'h8000_0000(AHB1 addr) to 32'h0000_0000(AHB0 addr)                 */
    };
  };
  __I  uint32_t  RESERVED[30];
  
  union {
    __IO uint32_t  REG_0x0080;                      /*!< REG_0x0080                                                            */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  PLEVEL     : 15;               /*!< Bit n represents the priority level of master n (n=1~15)
                                                         The arbitration is 2-level round-robin.
                                                         0: Low level , level 0
                                                         1: High level , level 1
                                                         Note: bit1:APBC DMA, bit2: ARM926-D, bit3:DMAC, bit4:MAC,
                                                         bit5:USB20, bit6:MS, bit7:AUDIO, bit8:reserved,
                                                         bit9:reserved, bit10: ARM926-I                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0084;                      /*!< REG_0x0084                                                            */
    
    struct {
      __IO uint32_t  IDLE_COUNT :  6;               /*!< The arbiter will re-arbitrate if a granted master dosen't issue
                                                         a
                                                         NON-SEN command within the idle count period.                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0088;                      /*!< REG_0x0088                                                            */
    
    struct {
      __IO uint32_t  REMAP      :  1;               /*!< 1: Activate remap function, switch base addresses of slave 4
                                                         and slave 6
                                                         Note: After applying the remap function,
                                                         (1) base address of slave 6 = original base address of slave
                                                          4
                                                         (2) base address of slave 4 = original base address of slave
                                                          4 + the space
                                                         size of slave 6.
                                                         Note that the base address should be the boundary of the space
                                                          size.                                                                */
           uint32_t             :  7;
      __IO uint32_t  INCR_LENGTH:  8;               /*!< When a master issues an INCR command, the arbiter will grant
                                                         the
                                                         master to transfer a total amount of (INCR_LENGTH+1) bursts.
                                                         (range 1~255)                                                         */
      __IO uint32_t  AHBC_INTR_EN:  1;              /*!< Enable or disable the interrupt when receiving a non-existing
                                                         address.                                                              */
           uint32_t             :  3;
      __IO uint32_t  AHBC_RESPONSE:  2;             /*!< Response status, when receiving a non-existing address, the
                                                         decoder
                                                         responds to the master.                                               */
           uint32_t             :  2;
      __IO uint32_t  AHBC_INTR_FLAG:  1;            /*!< Interrupt status, set when receiving a non-existing address.
                                                         Note: Writing a '0' to this bit clears the interrupt.                 */
    };
  };
  
  union {
    __I  uint32_t  REG_0x008C;                      /*!< REG_0x008C                                                            */
    
    struct {
      __I  uint32_t  AHBC_REVISION: 32;             /*!< AHBC revision register.                                               */
    };
  };
} AHB2_Type;


/* ================================================================================ */
/* ================                      AHB3                      ================ */
/* ================================================================================ */


/**
  * @brief AHB3 Controller (Arbiter / Decoder / Multiplexer) (AHB3)
  */

typedef struct {                                    /*!< AHB3 Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< REG_0x0000                                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  HS0_SIZE   :  4;               /*!< AHB slave0 space size. (DDR Channel 6)                                */
      __IO uint32_t  HS0_BASE   : 12;               /*!< AHB slave0 base address of [31:20] (unit: 1MB)
                                                         Note: Base address must be multiple of space size.                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< REG_0x0004                                                            */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  HS1_SIZE   :  4;               /*!< AHB slave1 space size. (AHB0 Bridge Slaver)                           */
      __IO uint32_t  HS1_BASE   : 12;               /*!< AHB slave1 base address of [31:20] (unit: 1MB)
                                                         Note: Base address must be multiple of space size.
                                                         32'h8000_0000(AHB1 addr) to 32'h0000_0000(AHB0 addr)                  */
    };
  };
  __I  uint32_t  RESERVED[30];
  
  union {
    __IO uint32_t  REG_0x0080;                      /*!< REG_0x0080                                                            */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  PLEVEL     : 15;               /*!< Bit n represents the priority level of master n (n=1~15)
                                                         The arbitration is 2-level round-robin.
                                                         0: Low level , level 0
                                                         1: High level , level 1
                                                         Note: bit1:APBC DMA, bit2: ARM926-D, bit3:DMAC, bit4:MAC,
                                                         bit5:USB20, bit6:MS, bit7:AUDIO, bit8:reserved,
                                                         bit9:reserved, bit10: ARM926-I                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0084;                      /*!< REG_0x0084                                                            */
    
    struct {
      __IO uint32_t  IDLE_COUNT :  6;               /*!< The arbiter will re-arbitrate if a granted master dosen't issue
                                                         a
                                                         NON-SEN command within the idle count period.                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0088;                      /*!< REG_0x0088                                                            */
    
    struct {
      __IO uint32_t  REMAP      :  1;               /*!< 1: Activate remap function, switch base addresses of slave 4
                                                         and slave 6
                                                         Note: After applying the remap function,
                                                         (1) base address of slave 6 = original base address of slave
                                                          4
                                                         (2) base address of slave 4 = original base address of slave
                                                          4 + the space
                                                         size of slave 6.
                                                         Note that the base address should be the boundary of the space
                                                          size.                                                                */
           uint32_t             :  7;
      __IO uint32_t  INCR_LENGTH:  8;               /*!< When a master issues an INCR command, the arbiter will grant
                                                         the
                                                         master to transfer a total amount of (INCR_LENGTH+1) bursts.
                                                         (range 1~255)                                                         */
      __IO uint32_t  AHBC_INTR_EN:  1;              /*!< Enable or disable the interrupt when receiving a non-existing
                                                         address.                                                              */
           uint32_t             :  3;
      __IO uint32_t  AHBC_RESPONSE:  2;             /*!< Response status, when receiving a non-existing address, the
                                                         decoder
                                                         responds to the master.                                               */
           uint32_t             :  2;
      __IO uint32_t  AHBC_INTR_FLAG:  1;            /*!< Interrupt status, set when receiving a non-existing address.
                                                         Note: Writing a '0' to this bit clears the interrupt.                 */
    };
  };
  
  union {
    __I  uint32_t  REG_0x008C;                      /*!< REG:4002_008C                                                         */
    
    struct {
      __I  uint32_t  AHBC_REVISION: 32;             /*!< AHBC revision register.                                               */
    };
  };
} AHB3_Type;


/* ================================================================================ */
/* ================                      JPEG                      ================ */
/* ================================================================================ */


/**
  * @brief JPEG Codec IP (JPEG)
  */

typedef struct {                                    /*!< JPEG Structure                                                        */
  
  union {
    __IO uint32_t  JPG_CFG;                         /*!< JPEG Config                                                           */
    
    struct {
      __IO uint32_t  JPG_TX_EN  :  1;               /*!< Enable or Disable JPEG Encode or Decode.                              */
      __IO uint32_t  JPG_ENCODE :  1;               /*!< Encode or Decode function.                                            */
      __IO uint32_t  JPG_FORMAT :  1;               /*!< JPEG Format.                                                          */
           uint32_t             :  5;
      __IO uint32_t  JPG_QP     :  8;               /*!< JPEG QP value.                                                        */
      __IO uint32_t  JPG_SCAL   :  2;               /*!< Select scaling mode of the decoded image for both horizontal
                                                         and vertical direction.                                               */
      __IO uint32_t  JPG_SWAP   :  2;               /*!< JPEG_SWAP[0] = 1 : Apply horizontal mirror function to output
                                                         image.
                                                         JPEG_SWAP[1] = 1 : Apply vertical mirror function to output
                                                          imag.                                                                */
      __IO uint32_t  JPG_ROT90  :  1;               /*!< Rotate the decoded image by 90 degree clockwise.                      */
    };
  };
  
  union {
    __IO uint32_t  JPG_H_SIZE;                      /*!< JPEG Horizontal size                                                  */
    
    struct {
      __IO uint32_t  JPG_ORG_HSIZE:  9;             /*!< Horizontal size of the Original Image Data.                           */
           uint32_t             :  7;
      __IO uint32_t  JPG_HSIZE  :  9;               /*!< The Horizontal Size for JPEG Encoder.(Unit:16 pixels)                 */
    };
  };
  
  union {
    __IO uint32_t  JPG_HVSTART_ADDR;                /*!< JPEG H and V Start address                                            */
    
    struct {
      __IO uint32_t  JPG_HSTART : 12;               /*!< The HSTART Position of the Original Image Data for JPEG Encoder.(Unit:2
                                                         pixels)                                                               */
           uint32_t             :  4;
      __IO uint32_t  JPG_VSTART : 11;               /*!< The VSTART Position of the Original Image Data for JPEG Encoder.(Unit:2
                                                         lines)                                                                */
    };
  };
  __IO uint32_t  JPG_VSIZE;                         /*!< JPEG Vertical size                                                    */
  
  union {
    __IO uint32_t  VDO_ADDR_CTR;                    /*!< Start address of the decoded/Encoded image.(Unit: 1K bytes)           */
    
    struct {
           uint32_t             : 10;
      __IO uint32_t  VDO_START_ADDR: 22;            /*!< Start address of the decoded/Encoded image.(Unit: 1K bytes)           */
    };
  };
  
  union {
    __IO uint32_t  QTAB_CTR;                        /*!< Q Table Control.                                                      */
    
    struct {
      __IO uint32_t  QTAB_RAM_EN:  1;               /*!< Enable CPU to read or write Q-table RAM                               */
      __IO uint32_t  QTAB_SEL_RD:  1;               /*!< Read or Write Q-table                                                 */
      __O  uint32_t  QTAB_RD_TRG:  1;               /*!< Trigger to read Q-table                                               */
           uint32_t             :  5;
      __IO uint32_t  QTAB_ADDR  :  7;               /*!< Q-table read or write address.
                                                         Actions of reading or writing Q-table increase QTAB_ADDR by
                                                         1 automatically.                                                      */
    };
  };
  __IO uint8_t   QTAB_DAT;                          /*!< Data port of Q-table.
                                                         To read Q-table:
                                                         1.Let QTAB_RAM_EN = 1
                                                         2.Let QTAB_SEL_RD = 1
                                                         3.Set QTAB_ADDR (optional)
                                                         4.Let QTAB_RD_TRG = 1
                                                         5.Read QTAB_DAT
                                                         To write Q-table:
                                                         1.Let QTAB_RAM_EN = 1
                                                         2.Let QTAB_SEL_RD = 0
                                                         3.Set QTAB_ADDR (optional)
                                                         4.Write QTAB_DAT                                                      */
  __I  uint8_t   RESERVED[3];
  
  union {
    __IO uint32_t  JPG_FLAG;                        /*!< JPEG Flag.                                                            */
    
    struct {
      __IO uint32_t  JPG_CODEC_INT_MASK:  3;        /*!< Bit 0 = 1: Mask JPEG encoding/decoding completed interrupt.
                                                         Bit 1 = 1: Mask JPEG encoding/decoding error interrupt.
                                                         Bit 2 = 1: Mask AHB error interrupt.                                  */
      __I  uint32_t  JPG_TX_OK_FLAG:  1;            /*!< 1: JPEG encoding/decoding completed.                                  */
      __I  uint32_t  JPG_ERR_FLAG:  1;              /*!< 1: JPEG encoding/decoding error occurred.                             */
      __I  uint32_t  JPG_AHB_ERR_FLAG:  1;          /*!< 1: JPEG AHB error occurred.                                           */
      __O  uint32_t  CLR_JPG_TX_OK_FLAG:  1;        /*!< 1: Clear JPEG_TX_OK_FLAG.                                             */
      __O  uint32_t  CLR_JPG_ERR_FLAG:  1;          /*!< 1: Clear JPEG_TX_ERR_FLAG.                                            */
      __O  uint32_t  CLR_JPG_AHB_ERR_FLAG:  1;      /*!< 1: Clear JPEG_AHB_ERR_FLAG                                            */
    };
  };
  
  union {
    __IO uint32_t  JPG_BUF_START_CTR;               /*!< The Ring FIFO START ADDR For Encode/Decdoe Bit-Streams.(Unit
                                                         : 1K Bytes)                                                           */
    
    struct {
           uint32_t             : 10;
      __IO uint32_t  JPG_BUF_START: 22;             /*!< The Ring FIFO START ADDR For Encode/Decdoe Bit-Streams.(Unit
                                                         : 1K Bytes)                                                           */
    };
  };
  
  union {
    __IO uint32_t  JPG_BUF_END_CTR;                 /*!< The Ring FIFO END ADDR For Encode/Decdoe Bit-Streams.(Unit :
                                                         1K Bytes)                                                             */
    
    struct {
           uint32_t             : 10;
      __IO uint32_t  JPG_BUF_END: 22;               /*!< The Ring FIFO END ADDR For Encode/Decdoe Bit-Streams.(Unit :
                                                         1K Bytes)                                                             */
    };
  };
  
  union {
    __IO uint32_t  JPG_ADDR_CTR;                    /*!< The JPEG Encode/Decoder Bit_Stream Start Address.(Unit : 4 Bytes)     */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  JPG_START_ADDR: 30;            /*!< The JPEG Encode/Decoder Bit_Stream Start Address.(Unit : 4 Bytes)     */
    };
  };
  
  union {
    __I  uint32_t  JPG_BS_SIZE_INFO;                /*!< Ecode JPEG bitstream size.(Unit : Byte)                               */
    
    struct {
           uint32_t             :  2;
      __I  uint32_t  JPG_BS_SIZE: 30;               /*!< Ecode JPEG bitstream size.(Unit : Byte)                               */
    };
  };
  __I  uint32_t  RESERVED1[3];
  __IO uint32_t  JPG_VER;                           /*!< JPEG CODEC version.                                                   */
} JPEG_Type;


/* ================================================================================ */
/* ================                     EHCI_1                     ================ */
/* ================================================================================ */


/**
  * @brief USB 2.0 Host IP (EHCI_1)
  */

typedef struct {                                    /*!< EHCI_1 Structure                                                      */
  
  union {
    __IO uint32_t  VER_CPLGTH;                      /*!< Host controller interface version number and Capability register
                                                         length.                                                               */
    
    struct {
      __I  uint32_t  CAPLENGTH  :  8;               /*!< This register is used as an offset to add to register
                                                         base to find the beginning of the Operational Register Space.         */
           uint32_t             :  8;
      __I  uint32_t  HCIVERSION : 16;               /*!< This is a two-byte register containing a BCD encoding of the
                                                         EHCI revision number
                                                         supported by this host controller.
                                                         The most significant byte of this register represents a major
                                                          revision and the
                                                         least significant byte is the minor revision.                         */
    };
  };
  
  union {
    __IO uint32_t  HCSPARAMS;                       /*!< Structural parameters                                                 */
    
    struct {
      __I  uint32_t  N_PORTS    :  4;               /*!< This field specifies the number of physical downstream ports
                                                         implemented
                                                         on this host controller.
                                                         The value of this field determines how many port registers are
                                                          addressable
                                                         in the Operational RegisterSpace (see Table 2-8). Valid values
                                                          are in the
                                                         range of 1H to FH.
                                                         A zero in this field is undefined.
                                                         USB20HOST support only one of physical downstream port                */
      __I  uint32_t  PPC        :  1;               /*!< Port Power Control.
                                                         This field indicates whether the host controller
                                                         implementation includes port power control. A one
                                                         in this bit indicates the ports have port power
                                                         switches. A zero in this bit indicates the port do not
                                                         have port power switches. The value of this field
                                                         affects the functionality of the Port Power field in
                                                         each port status and control register (see EHCI Section 2.3.8).       */
           uint32_t             :  2;
      __I  uint32_t  PRT_RT_RL  :  1;               /*!< Port Routing Rules.No support. This field indicates the method
                                                         used bythis implementation for how all ports are mapped tocompanion
                                                          controllers. The value of this field has thefollowing interpretation:Value
                                                          Meaning0 The first N_PCC ports are routed to thelowest numbered
                                                          function companion hostcontroller, the next N_PCC port are routedto
                                                          the next lowest function companioncontroller, and so on.1 The
                                                          port routing is explicitly enumeratedby the first N_PORTS elements
                                                          of theHCSP-PORTROUTE array                                           */
      __I  uint32_t  N_PCC      :  4;               /*!< Number of Ports per Companion Controller.
                                                         This field indicates the number of ports supported
                                                         per companion host controller. It is used to indicate
                                                         the port routing configuration to system software.
                                                         For example, if N_PORTS has a value of 6 and
                                                         N_CC has a value of 2 then N_PCC could have a
                                                         value of 3. The convention is that the first N_PCC
                                                         ports are assumed to be routed to companion controller 1, the
                                                         next N_PCC ports to companion controller
                                                         2, etc. In the previous example, the N_PCC could
                                                         have been 4, where                                                    */
      __I  uint32_t  N_CC       :  4;               /*!< Number of Companion Controller.
                                                         This field indicates the number of companion controllers associated
                                                         with this USB 2.0 host controller.A zero in this field indicates
                                                         there are no companion host
                                                         controllers. Port-ownership hand-off is not supported. Only
                                                         high-speed devices are supported on thehost controller root
                                                          ports.
                                                         A value larger than zero in this field indicates there are companion
                                                         USB 1.1 host controller(s). Port-ownership hand-off are supported.
                                                         High, Full- and Lowspeed devices are supported on the h               */
      __I  uint32_t  P_INDICATOR:  1;               /*!< Port Indicators.
                                                         This bit indicates whether the ports support port indicator
                                                         control.
                                                         When this bit is a one, the port statusand control registers
                                                          include a
                                                         read/writable field for controlling the state of the port indicator.
                                                         See EHCI Section 2.3.9 for definition of the port indicator
                                                          control field.                                                       */
    };
  };
  
  union {
    __IO uint32_t  HCCPARAMS;                       /*!< Capability parameters                                                 */
    
    struct {
           uint32_t             :  1;
      __I  uint32_t  FRAME_FLAG :  1;               /*!< Programmable Frame List Flag. Default = Implementation dependent.
                                                         If this
                                                         bit is set to a zero, then system software must use a frame
                                                          list length of
                                                         1024 elements with this host controller. The USBCMDregister
                                                          Frame List
                                                         Size field is a read-only register and should be set to zero.
                                                         If set to a one, then system software can specify and use a
                                                          smaller frame
                                                         list and configure the host controller via the USBCMD register
                                                          Frame List
                                                         Size field. The frame list must always be aligned on a 4K page
                                                          boundary.
                                                         This req                                                              */
      __I  uint32_t  PARK_CAP   :  1;               /*!< Asynchronous Schedule Park Capability.
                                                         Default = Implementation dependent. If this bit is set to a
                                                         one, then the
                                                         host controller supports the park feature for high-speed queue
                                                          heads in
                                                         the Asynchronous Schedule.
                                                         The feature can be disabled or enabled and set to aspecific
                                                          level by
                                                         using the Asynchronous SchedulePark Mode Enable and Asynchronous
                                                          Schedule
                                                         Park Mode Count fields in the USBCMD register.                        */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  USBCMD;                          /*!< USB command register                                                  */
    
    struct {
      __IO uint32_t  RUN_NSTOP  :  1;               /*!< Run/Stop.
                                                         1=Run. 0=Stop.
                                                         When set to a 1, the Host Controller proceeds with execution
                                                         of the schedule.
                                                         The Host Controller continues execution as long as this bit
                                                          is set to a 1. When
                                                         this bit is set to 0, the Host Controller completes thecurrent
                                                          and any
                                                         actively pipeline transactions on the USB and then halts.
                                                         The Host Controller must halt within 16 microframes after software
                                                          clears
                                                         the Run bit. The HC Halted bit in the status register indicates
                                                          when the
                                                         Host Controller has finished its pending pipeline tr                  */
      __IO uint32_t  HCRESET    :  1;               /*!< Host Controller Reset.
                                                         This control bit is used by software to reset the host controller.
                                                         The
                                                         effects of this on Root Hubregisters are similar to a Chip Hardware
                                                          Reset.
                                                         When software writes a one to this bit, the Host Controller
                                                          resets its
                                                         internal pipelines, timers, counters, state machines, etc. to
                                                          their initial
                                                         value. Any transaction currently in progress on USB is immediately
                                                          terminated.
                                                         A USB reset is not driven on downstream ports.
                                                         All operational registers, including port registers andport
                                                          state mac                                                            */
      __IO uint32_t  FRAME_CTR  :  2;               /*!< Frame List Size No.This field is R/W only when one or both of
                                                         the Programmable Frame List Flag
                                                         and 32-Frame Periodic List Capability bits in the HCCPARAMS
                                                          registers is
                                                         set to a one. This field specifies the size of the frame list
                                                          and controls
                                                         which bits in the Frame Index Register should be used for the
                                                          Frame List
                                                         Currentindex.
                                                         Values mean:
                                                         00b 1024 frames [default]
                                                         01b 512 frames
                                                         10b 256 frames
                                                         11b Reserved or 32 frames (see below)
                                                         Software may only program a 32 frame list when the 32-Frame
                                                          Periodic List
                                                                                                                               */
      __IO uint32_t  PERIODIC_EN:  1;               /*!< Periodic Schedule Enable.
                                                         This bit controls whether the host controller skipsprocessing
                                                         the
                                                         Periodic Schedule.
                                                         Values mean:
                                                         0b Do not process the Periodic Schedule
                                                         1b Use the PERIODICLISTBASE register to access the Periodic
                                                          Schedule.                                                            */
      __IO uint32_t  ASYNC_EN   :  1;               /*!< Asynchronous Schedule Enable.
                                                         This bit controls whether the host controller skipsprocessing
                                                         the
                                                         Asynchronous Schedule.
                                                         Values mean:
                                                         0b Do not process the Asynchronous Schedule
                                                         1b Use the ASYNCLISTADDR register to accessthe Asynchronous
                                                          Schedule.                                                            */
      __IO uint32_t  DOORBELL_EN:  1;               /*!< Interrupt on Async Advance Doorbell.
                                                         This bit is used as a doorbell by software to tell the host
                                                         controller
                                                         to issue an interrupt the next time it advances asynchronous
                                                          schedule.
                                                         Software must write a 1 to this bit to ring the doorbell.
                                                         When the host controller has evicted all appropriate cached
                                                          schedule
                                                         state, it sets the Interrupt on Async Advance status bit in
                                                          the USBSTS
                                                         register. If the Interrupt on Async Advance Enable bit in the
                                                          USBINTR
                                                         register is a one then the host controller will assert an interr      */
           uint32_t             :  1;
      __IO uint32_t  PARK_CNT   :  2;               /*!< Asynchronous Schedule Park Mode Count.
                                                         It contains a count of the number of successive transactions
                                                         the host
                                                         controller is allowed to execute from a high-speed queue head
                                                          on the
                                                         Asynchronous schedule before continuing traversal of the Asynchronous
                                                         schedule.Valid values are 1h to 3h. Software must not write
                                                          a zero to this bit
                                                         when Park Mode Enable is a one as this will result in undefined
                                                          behavior.                                                            */
           uint32_t             :  1;
      __IO uint32_t  PARK_EN    :  1;               /*!< Asynchronous Schedule Park Mode Enable.
                                                         If Software uses this bit to enable or disable Park mode. When
                                                         this
                                                         bit is one, Park mode is enabled.
                                                         When this bit is a zero, Park mode is disabled.                       */
           uint32_t             :  4;
      __IO uint32_t  INT_CTR    :  8;               /*!< Interrupt Threshold Control.
                                                         This field is used by system software to select the maximum
                                                         rate at
                                                         which the host controller will issue interrupts. The only valid
                                                         values are defined below.If software writes an invalid value
                                                          to this register, the results
                                                         are undefined.
                                                         Value Maximum Interrupt Interval
                                                         00h Reserved
                                                         01h 1 micro-frame
                                                         02h 2 micro-frames
                                                         04h 4 micro-frames
                                                         08h 8 micro-frames (default, equates to 1 ms)
                                                         10h 16 micro-frames (2 ms)
                                                         20h 32 micro-frames (4 ms)
                                                         40h 64 micro-frames (8 ms)
                                                         Any other value                                                       */
    };
  };
  
  union {
    __IO uint32_t  USBSTS;                          /*!< USB status register                                                   */
    
    struct {
      __IO uint32_t  USB_INT    :  1;               /*!< USB Interrupt.
                                                         The Host Controller sets this bit to 1 on the completion of
                                                         a USB
                                                         transaction, which results in the retirement of a Transfer Descriptor
                                                         that had its IOC bit set.
                                                         The Host Controller also sets this bit to 1 when a short packet
                                                          is
                                                         detected (actual number of bytes received was less than the
                                                          expected
                                                         number of bytes).                                                     */
      __IO uint32_t  USB_ERR_INT:  1;               /*!< USB Error Interrupt.
                                                         The Host Controller sets this bit to 1 when completion of a
                                                         USB
                                                         transaction results in an error condition (e.g., error counter
                                                         underflow).If the TD on which the error interrupt occurred also
                                                          had its IOC
                                                         bit set, both this bit and USBINT bit are set.                        */
      __IO uint32_t  PO_CHG_INT :  1;               /*!< Port Change Detect.
                                                         The Host Controller sets this bit to a one when any port for
                                                         which the Port Owner bit is set to zero has a change bit
                                                         transition from a zero to a one or a Force Port Resume bit
                                                         transition from a zero to a one as a result of a J-K transition
                                                         detected on a suspended port.
                                                         This bit will also be set as a result of the Connect Status
                                                         Change
                                                         being set to a one after system software has relinquished ownership
                                                         of a connected portby writing a one to a port's Port Owner bit.
                                                         It is acceptable that                                                 */
      __IO uint32_t  ROLLOVER_INT:  1;              /*!< Frame List Rollover R/WC.
                                                         The Host Controller sets this bit to a one when the Frame List
                                                         Index
                                                         rolls over from its maximum value to zero.
                                                         The exact value at which the rollover occurs depends on the
                                                          frame
                                                         list size. For example, if the frame list size (as programmed
                                                          in the
                                                         Frame List Size field of the USBCMD register) is 1024, the Frame
                                                          Index
                                                         Register rolls over every time FRINDEX[13] toggles. Similarly,
                                                          if the
                                                         size is 512, the Host Controller sets this bit to a one every
                                                          time
                                                         FRINDEX[12] toggles.                                                  */
      __IO uint32_t  SYS_ERR_INT:  1;               /*!< Host System Error.
                                                         The Host Controller sets this bit to 1 when a serious error
                                                         occurs
                                                         during a host system access involving the Host Controller module.
                                                         In a PCI system, conditions that set this bit to 1 include PCI
                                                          Parity
                                                         error, PCI Master Abort, and PCI Target Abort. When this error
                                                          occurs,
                                                         the Host Controller clears the Run/Stop bit in the Command register
                                                          to
                                                         prevent further execution of the scheduled TDs.                       */
      __IO uint32_t  ASYNC_ADVANCE_INT:  1;         /*!< Interrupt on Async Advance.
                                                         System software can force the host controller to issue an interrupt
                                                         the
                                                         next time the host controller advances the asynchronous schedule
                                                          by
                                                         writing a one to the Interrupt on Async Advance Doorbell bit
                                                          in the
                                                         USBCMD register. This status bit indicates the assertion of
                                                          that
                                                         interrupt source.                                                     */
           uint32_t             :  6;
      __I  uint32_t  HC_HALTED  :  1;               /*!< HCHalted.
                                                         This bit is a zero whenever the Run/Stop bit is a one.
                                                         The Host Controller sets this bit to one after it has stopped
                                                         executing
                                                         as a result of the Run/Stop bitbeing set to 0, either by software
                                                          or
                                                         by the Host Controller hardware (e.g. internal error).                */
      __I  uint32_t  RECLAMATION:  1;               /*!< Reclamation.
                                                         This is a read-only status bit, which is used to detectan empty
                                                         asynchronous schedule.                                                */
      __I  uint32_t  PERIODIC_STS:  1;              /*!< Periodic Schedule Status.
                                                         The bit reports the current real status of the Periodic Schedule.
                                                         If this bit is a zero then the status of the Periodic Schedule
                                                         is
                                                         disabled.
                                                         If this bit is a one then the status of the Periodic Schedule
                                                          is
                                                         enabled. The Host Controller is not required to immediately
                                                          disable
                                                         or enable the Periodic Schedule when software transitions the
                                                         Periodic Schedule Enable bit in the USBCMD register.
                                                         When this bit and the Periodic Schedule Enable bit are the same
                                                         value, the Periodic Schedule is                                       */
      __I  uint32_t  ASYNC_STS  :  1;               /*!< Asynchronous Schedule Status.
                                                         The bit reports the current real status of the Asynchronous
                                                         Schedule.
                                                         If this bit is a zero then the status of the Asynchronous Schedule
                                                         is disabled.If this bit is a one then the status of the Asynchronous
                                                          Schedule
                                                         is enabled. The Host Controller is not required to immediately
                                                         disable or enable the Asynchronous Schedule when software transitions
                                                         the Asynchronous Schedule Enable bit in the USBCMD register.When
                                                          this bit and the Asynchronous Schedule Enable bit are the same
                                                         value                                                                 */
           uint32_t             : 15;
      __IO uint32_t  SOF_INT    :  1;               /*!< SOF Interrupt
                                                         SOF Interrupr control by USBCMD1 register.                            */
    };
  };
  
  union {
    __IO uint32_t  USBINTR;                         /*!< USB interrupt enable register                                         */
    
    struct {
      __IO uint32_t  USB_INT_EN :  1;               /*!< When this bit is a one, and the USBINT bit in the USBSTS register
                                                         is a one, the host controller will issue an interrupt at the
                                                         next
                                                         interrupt threshold. The interrupt is acknowledged by software
                                                         clearing the USBINT bit.                                              */
      __IO uint32_t  USB_ERR_INT_EN:  1;            /*!< When this bit is a one, and the USBERRINT bit in the USBSTS
                                                         register is a one, the host controller will issue an interrupt
                                                         at the next interrupt threshold.
                                                         The interrupt is acknowledged by software clearing the USBERRINT
                                                         bit.                                                                  */
      __IO uint32_t  PO_CHG_INT_EN:  1;             /*!< When this bit is a one, and the Port Change Detect bit in the
                                                         USBSTS register is a one, the host controller will issue an
                                                         interrupt. The interrupt is acknowledged by software clearing
                                                         the Port Change Detect bit.                                           */
      __IO uint32_t  ROLLOVER_INT_EN:  1;           /*!< When this bit is a one, and the Frame List Rollover bit in
                                                         the USBSTS register is a one, the host controller will issue
                                                         an interrupt.
                                                         The interrupt is acknowledged by software clearing the Frame
                                                         List Rollover bit.                                                    */
      __IO uint32_t  SYS_ERR_INT_EN:  1;            /*!< When this bit is a one, and the Host SystemError Status bit
                                                         in
                                                         the USBSTS register is a one, the host controller will issue
                                                          an
                                                         interrupt.
                                                         The interrupt is acknowledged by software clearing the Host
                                                         System Error bit.                                                     */
      __IO uint32_t  ASYNC_ADVANCE_INT_EN:  1;      /*!< When this bit is a one, and the Interrupt on Async Advance bit
                                                         in
                                                         the USBSTS register is a one, the host controller will issue
                                                          an
                                                         interrupt at the next interruptthreshold.
                                                         The interrupt is acknowledged by software clearing the Interrupt
                                                         on Async Advance bit.                                                 */
      __IO uint32_t  REGW_TO_INT_EN:  1;            /*!< Register write timeout interrupt enable. (For HREADY timeout
                                                         when
                                                         AHB Slave write )                                                     */
           uint32_t             : 24;
      __IO uint32_t  SOF_INT_EN :  1;               /*!< SOF interrupt enable                                                  */
    };
  };
  __IO uint16_t  FRINDEX;                           /*!< Frame Index.
                                                         The value in this register increments at the end of each time
                                                         frame
                                                         (e.g. micro-frame). Bits [N:3] are used for the Frame List current
                                                          index.
                                                         This means that each location of the frame list is accessed
                                                          8 times
                                                         (frames or micro-frames) before moving to the next index. The
                                                          following
                                                         illustrates values of N based on the value of the Frame List
                                                          Size field
                                                         in the USBCMD register.
                                                         USBCMD[Frame List Size] Number Elements N
                                                         00b (1024) 12
                                                         01b (512) 11
                                                         10b (256) 10
                                                         11b (32) 12                                                           */
  __I  uint16_t  RESERVED1[3];
  
  union {
    __IO uint32_t  PERIODICLISTBASE;                /*!< Periodic frame list base address register                             */
    
    struct {
           uint32_t             : 12;
      __IO uint32_t  BASE_ADDR  : 20;               /*!< Base Address (Low).
                                                         These bits correspond to memory address signals[31:12], respectively. */
    };
  };
  
  union {
    __IO uint32_t  ASYNCLISTADDR;                   /*!< Current asynchronous list address register                            */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  LPL        : 27;               /*!< Link Pointer Low.
                                                         These bits correspond to memory address signals[31:5], respectively.
                                                         This field may only reference a Queue Head (QH), see Section
                                                         3.6.                                                                  */
    };
  };
  __I  uint32_t  RESERVED2[10];
  
  union {
    __IO uint32_t  PORTSC0;                         /*!< Port status and control register                                      */
    
    struct {
      __I  uint32_t  CURR_CNNT_ST:  1;              /*!< Current Connect Status.
                                                         1=Device is present on port. 0=No device is present.
                                                         This value reflects the current state of the port, and may not
                                                         correspond directly to the event that caused the Connect Status
                                                         Change bit (Bit 1) to be set.
                                                         This field is zero if Port Power is zero.                             */
      __IO uint32_t  CNNT_ST_CHG:  1;               /*!< Connect Status Change.
                                                         1=Change in Current Connect Status. 0=No change.
                                                         Indicates a change has occurred in the port's Current Connect
                                                         Status.
                                                         The host controller sets this bit for all changes to the port
                                                          device
                                                         connect status, even if system software has not cleared an existing
                                                         connectstatus change. For example, the insertion status changes
                                                         twice before system software has cleared the changed condition,
                                                          hub
                                                         hardware will be "setting" an already-set bit (i.e., the bit
                                                          will
                                                         remain set).
                                                         Software sets this bi                                                 */
      __IO uint32_t  PORTENABLED:  1;               /*!< Port Enabled/Disabled.
                                                         1=Enable. 0=Disable.
                                                         Ports can only be enabled by the host controller as a part of
                                                         the
                                                         reset and enable. Software cannot enable a port by writing a
                                                          one to
                                                         this field. The host controller will only set this bit to a
                                                          one
                                                         when the reset sequence determines that the attached device
                                                          is a
                                                         high-speed device.
                                                         Ports can be disabled by either a fault condition (disconnect
                                                         event or other fault condition) or by host software. Note that
                                                          the
                                                         bit status does not change until the port state actually              */
      __IO uint32_t  PO_DIS_CHG :  1;               /*!< Port Enable/Disable Change.
                                                         1=Port enabled/disabled status has changed.
                                                         0=No change.
                                                         Default = 0.
                                                         For the root hub, this bit gets setto a one only when a port
                                                         is
                                                         disabled due to theappropriate conditions existing at the EOF2
                                                         point (See Chapter 11 of the USB Specification for the definition
                                                         of a Port Error). Software clears this bit by writing a 1 to
                                                          it.
                                                         This field is zero if Port Power is zero.                             */
      __I  uint32_t  OVER_CURR_ACT:  1;             /*!< Over-current Active.
                                                         1=This port currently has an over-current condition.
                                                         0=This port does not have an over-current condition.
                                                         This bit will automatically transition from a one to a zero
                                                         when the
                                                         over current condition is removed.                                    */
      __IO uint32_t  OVER_CURR_CHG:  1;             /*!< Over-current Change.
                                                         1=This bit gets set to a one when there is a change to Over-current
                                                         Active. Software clears this bit by writing a one to this bit
                                                         position.                                                             */
      __IO uint32_t  FORC_PO_RESU:  1;              /*!< Force Port Resume.
                                                         1= Resume detected/driven on port.
                                                         0= No resume
                                                         (K-state) detected/driven on port. This functionality defined
                                                         for
                                                         manipulating this bit depends on the value of the Suspend and
                                                         Suspend Using L1 bits. For example, if the port is not suspended
                                                         (Suspend and Enabled bits are a one) and software transitions
                                                          this
                                                         bit to a one, then the effects on the bus are undefined.
                                                         Software sets this bit to a one to drive resume signaling. The
                                                         Host Controller sets this bit to a one if a Jto-K transition
                                                          is
                                                                                                                               */
      __IO uint32_t  SUSPEND    :  1;               /*!< Suspend.
                                                         1 = Port in suspend state. 0 = Port not in suspend state.
                                                         The Port Enabled/Disabled and Suspend bits of this register
                                                         define the port state as follows:
                                                         Bits [Port Enabled, Suspend] Port State
                                                         0X Disable
                                                         10 Enable
                                                         11 Suspend
                                                         Software writes a one to this bit to transition a port to
                                                         either the suspend state. When in the suspend state, downstream
                                                         propagation of data is blocked on this port, except for port
                                                         reset. If this bit is set to a one when a transaction is in
                                                         progress then the blocking will not                                   */
      __IO uint32_t  PORTRESET  :  1;               /*!< Port Reset.
                                                         1=Port is in Reset. 0=Port is not in Reset. When software writes
                                                         a one to this bit (from a zero), the bus reset sequence as defined
                                                         in the USB Specification Revision 2.0 is started. Software writes
                                                         a zero to this bit to terminate the bus reset sequence. Software
                                                         must keep this bit at a one long enough to ensure the reset
                                                         sequence, as specified in the USB Specification Revision 2.0,
                                                         completes. Note: when software writes this bit to a one, it
                                                         must
                                                         also write a zero to the Port Enable bit.
                                                         Note th                                                               */
           uint32_t             :  1;
      __I  uint32_t  LINESTATUS :  2;               /*!< Line Status.
                                                         These bits reflect the current logical levels of the D+(bit
                                                         11) and D- (bit 10) signal
                                                         lines. These bits are used for detection of low-speed USB devices
                                                          prior to the port
                                                         reset and enable sequence. This field is valid only when the
                                                          port enable bit is zero
                                                         and the current connect status bit is set to a one.
                                                         The encoding of the bits are:
                                                         Bits[11:10] USB State Interpretation
                                                         00b SE0 Not Low-speed device, perform EHCI reset
                                                         10b J-state Not Low-speed device, perform EHCI reset
                                                         01b K-state Low-speed                                                 */
      __IO uint32_t  PP         :  1;               /*!< Port Power.
                                                         The function of this bit depends on the value of the Port Power
                                                         Control (PPC) field in
                                                         the HCSPARAMS register. The behavior is as follows:PPC PP Operation0b
                                                          1b RO--Host controller does not have port power control switches.
                                                          Each port is
                                                         hard-wired to power.
                                                         1b 1b/0b R/W--Host controller has port power control switches.
                                                          This bit represents the
                                                         current setting of the switch (0 = off, 1 = on). When power
                                                          is not available on a port
                                                         (i.e. PP equals a 0), the port is non-functional and will not
                                                          report                                                               */
           uint32_t             :  1;
      __IO uint32_t  PIC_P0     :  2;               /*!< Port Indicator Control.
                                                         Writing to these bits has no effect if the P_INDICATOR bit in
                                                         the HCSPARAMS register is
                                                         a zero. If P_INDICATOR bit is a one, then the bit encodings
                                                          are:
                                                         Bit Value Meaning
                                                         00b Port indicators are off
                                                         01b Amber
                                                         10b Green
                                                         11b Undefined
                                                         Refer to the USB Specification Revision 2.0 for a description
                                                          on how these bits are to be used.
                                                         This field is zero if Port Power is zero.                             */
      __IO uint32_t  PTC        :  4;               /*!< Port Test Control.
                                                         When this field is zero, the port is NOT operating in a test
                                                         mode. A non-zero value
                                                         indicates that it is operating in test mode and the specific
                                                          test mode is indicated
                                                         by the specific value. The encoding of the test mode bits are
                                                          (0110b - 1111b are reserved):
                                                         Bits Test Mode
                                                         0000b Test mode not enabled
                                                         0001b Test J_STATE
                                                         0010b Test K_STATE
                                                         0011b Test SE0_NAK
                                                         0100b Test Packet
                                                         0101b Test FORCE_ENABLE
                                                         Refer to EHCI Section 4.14 for the operational model for using
                                                          these test modes and
                                                         the US                                                                */
    };
  };
  __I  uint32_t  RESERVED3[10];
  __IO uint8_t   FLADJ;                             /*!< Frame Length Timing Value.
                                                         Each decimal value change to this register corresponds to 16
                                                         highspeed bit times. The SOF cycle
                                                         time (number of SOF counter clock periods to generate a SOF
                                                          micro-frame length) is equal to 59488 +
                                                         value in this field. The default value is decimal 32 (20h),
                                                          which gives a SOF cycle time of 60000.
                                                         Frame Length
                                                         (# High Speed bit times) FLADJ Value
                                                         (decimal) (decimal)
                                                         59488 0(00h)
                                                         59504 1(01h)
                                                         59520 2(02h)
                                                         ...
                                                         59984 31(1Fh)
                                                         60000 32(20h)
                                                         ...
                                                         60480 62(3Eh)
                                                         60496 63(3Fh)                                                         */
  __I  uint8_t   RESERVED4[3];
  
  union {
    __IO uint32_t  EC_CTL;                          /*!< EHCI flow control register                                            */
    
    struct {
      __IO uint32_t  OV_BYPASS  :  1;               /*!< OVERLAY Write Back Bypass.                                            */
      __IO uint32_t  PG_EN      :  1;               /*!< FW set 1 to enable the pattern generated function.
                                                         Pattern generator version only.                                       */
      __IO uint32_t  SOF_BYPASS :  1;               /*!< FW set 1 to bypass all the SOF between RESET & USB transaction.
                                                         HW clear this bit
                                                         after SOF bypassed. Pattern generator version only.                   */
      __IO uint32_t  SOF_1_BYPASS:  1;              /*!< FW set 1 to bypass the SOF once after RESET complete. HW clear
                                                         this bit after SOF bypassed.
                                                         Pattern generator version only.                                       */
      __IO uint32_t  SOF_MASK   :  1;               /*!< FW set 1 to always enable the xSOF function when host sends
                                                         SOF packet to device.
                                                         FW set 0 to disable this function. Pattern generator version
                                                          only.                                                                */
      __IO uint32_t  INT_OV     :  1;               /*!< FW set 1 to always enable the write back overlay function when
                                                         Interrupt transfer
                                                         received NAK from device.
                                                         FW set 0 to disable this function. Pattern generator version
                                                          only.                                                                */
      __IO uint32_t  HS_BYPASS  :  1;               /*!< FW set 1 to always disable the HS chirp function when device
                                                         sends K state to host
                                                         after attachment. FW set 0 to disable this function. Pattern
                                                          generator version only.                                              */
           uint32_t             :  1;
      __IO uint32_t  HK_DEL_CNT :  5;               /*!< FW can set these registers to control the delay system cycles
                                                         to transmit data or
                                                         handshake to device(PG mode). Refer to Table 22, "Handshake
                                                          delay count setting,"
                                                         on page 88 for correlated value setting.                              */
      __IO uint32_t  TX_BABBLE_EN:  1;              /*!< set will enable Host System Error interrupt include TX babble
                                                         status.                                                               */
    };
  };
  
  union {
    __IO uint32_t  EC_STS;                          /*!< EHCI status register                                                  */
    
    struct {
      __IO uint32_t  TYPE_FAIL  :  1;               /*!< QH Type Fail.
                                                         HC Fetch QH data Structure, but the Type field isn't a QH.            */
      __IO uint32_t  INT_ERR    :  1;               /*!< C-Mask & S-Mask error.
                                                         HC Fetch QH data Structure, but the S-mask and Cmask are set
                                                         fail. So HC judge the
                                                         start-split and complete-split true at the same u-frame.
                                                         SYS_ERR_INT also set by this reason.                                  */
      __IO uint32_t  TX_BABBLE  :  1;               /*!< TX babble occurred.
                                                         HC do USB out transaction, but the data is not finish before
                                                         the EOF2 timing pointer.
                                                         SYS_ERR_INT also set by this reason.                                  */
      __IO uint32_t  PO_FSDIS_CHG:  1;              /*!< Full speed Port Enable/Disable Change.
                                                         1=Port enabled/disabled status has changed.
                                                         0=No change.
                                                         Default = 0. For the root hub, this bit gets set to a one only
                                                         when a port is not in
                                                         high speed and is disabled due to the appropriate conditions
                                                          existing at the EOF2 point
                                                         (See Chapter 11 of the USB Specification for the definition
                                                          of a Port Error). Software
                                                         clears this bit by writing a 1 to it.
                                                         This field is zero if Port Power is zero.                             */
      __IO uint32_t  REGW_TO    :  1;               /*!< Register write timeout
                                                         HREADY timeout when AHB Slave write.
                                                         (HREADY de-assert over 31 AHB clock) It occur maybe no UTMI
                                                         clock                                                                 */
    };
  };
  
  union {
    __IO uint32_t  UTMI_VC;                         /*!< UTMI Vendor Control                                                   */
    
    struct {
      __IO uint32_t  VCONTROL   :  4;               /*!< to output U_VCONTROL                                                  */
      __IO uint32_t  VCONTROLLOADM:  1;             /*!< to output U_VCONTROLLOADM                                             */
           uint32_t             :  3;
      __I  uint32_t  VSTATUS    :  8;               /*!< U_VSTATUS from input                                                  */
      __IO uint32_t  RootHub_TEST:  1;              /*!< HW simulation only                                                    */
      __IO uint32_t  Pass_Chirp_Test:  1;           /*!< HW simulation only                                                    */
      __IO uint32_t  HS_DISC_DISABLE:  1;           /*!< UTMI PHY Host disconnect getting                                      */
      __IO uint32_t  Pass_Reset :  1;               /*!< Pass USB Reset protocol and enter USB Enable state. Pattern
                                                         generator version only.                                               */
      __IO uint32_t  HS_SWEN    :  1;               /*!< When Pass_Reset is high the bit
                                                         1: High speed USB Enable
                                                         0: Full/Low speed USB Enable
                                                         Pattern generator version only.                                       */
      __IO uint32_t  DISC_UTMI_RST_EN:  1;          /*!< Hardware auto reset UTMI when disconnected
                                                         1: enable;
                                                         0: disable;                                                           */
      __IO uint32_t  UTMI_RESET :  1;               /*!< UTMI reset set will reset UTMI, clear by Hardware.                    */
      __IO uint32_t  RootHub_Status:  9;            /*!< The RootHub main state machine status.
                                                         HW debug only                                                         */
    };
  };
  __I  uint32_t  RESERVED5[13];
  
  union {
    __IO uint32_t  MISC;                            /*!< MISC                                                                  */
    
    struct {
      __IO uint32_t  INCR_EN    :  1;               /*!< Enable AHBM fixed incremental burst transaction
                                                         (Dont change this value when USBCMD.Run = 1)
                                                         1:enable
                                                         0:disable                                                             */
      __I  uint32_t  HOST_SPEED :  2;               /*!< The speed that transfer between host and device.
                                                         11: Reserved
                                                         10: High speed.
                                                         01: Low speed.
                                                         00: Full speed.                                                       */
      __IO uint32_t  PO_FSEN    :  1;               /*!< Full speed Port Enabled/Disabled.
                                                         1=Enable. 0=Disable.
                                                         Ports can only be enabled by the host controller as a part of
                                                         the reset and enable.
                                                         Software cannot enable a port by writing a one to this field.
                                                          The host controller will
                                                         only set this bit to a one when the reset sequence determines
                                                          that the attached device
                                                         is a full-speed or low-speed device.
                                                         Ports can be disabled by either a fault condition (disconnect
                                                          event or other fault
                                                         condition) or by host software. Note that the bit status does
                                                          not change until                                                     */
           uint32_t             :  4;
      __IO uint32_t  GPIO       :  4;               /*!< GPIO for outside serial SIE control.
                                                         GPIO[0]: serial mode enable register.
                                                         GPIO[1]:FSPHY_SEL enable register. 1: outenn asserted before
                                                         SYNC bit 2T and deaserted
                                                         after EOP 1.5T.
                                                         GPIO[3:2]:skew control register. 0x:disable. 10:host issue slow
                                                          DPDM every 8bits to
                                                         test device DPLL. 11:host issue fast DPDM every 8bits to test
                                                          device DPLL.                                                         */
      __IO uint32_t  FS_TEST_PKT_EN:  1;            /*!< for register PORTSC bit[19:16], this bit
                                                         1: Port Test Control operated in Full Speed.
                                                         0: Port Test Control operated in High Speed.                          */
      __IO uint32_t  FS_TEST_SE0:  1;               /*!< Line state is SE0 when this bit was seted                             */
      __IO uint32_t  FS_TEST_SE1:  1;               /*!< Line state is SE1 when this bit was seted                             */
      __IO uint32_t  PARK_MOD_PLUS:  1;             /*!< set will enable Part mode plus when Park mode enable                  */
      __IO uint32_t  PARK_PLUS_CNT:  4;             /*!< Part count number when Park mode plus enable. Max. value is
                                                         12                                                                    */
      __IO uint32_t  ASYN_PRE_FETCH:  1;            /*!< set will enable pre-fetch feature for asynchronous schedule           */
      __IO uint32_t  LEV_INT_EN :  1;               /*!< Level interrupt enable                                                */
      __IO uint32_t  BYP_INT_TH_EN:  1;             /*!< Bypass interrupt threshold enable                                     */
           uint32_t             :  8;
      __IO uint32_t  SUSP_CLK_ON:  1;               /*!< set will keep UTMI clock always on when suspend                       */
    };
  };
  
  union {
    __IO uint32_t  REG_CFG;                         /*!< Register access control                                               */
    
    struct {
      __IO uint32_t  REGR_RDY_SEL:  3;              /*!< Register read ready selection, active when FW_CTRLR_EN = 1;
                                                         000: 1st clock latch data & 1T ready
                                                         001: 1st clock latch data & 2T ready
                                                         010: 2nd clock latch data & 3T ready (default)
                                                         011: 3rd clock latch data & 4T ready
                                                         100: 4th clock latch data & 5T ready
                                                         101: 5th clock latch data & 6T ready
                                                         110: 6th clock latch data & 7T ready
                                                         111: 7th clock latch data & 8T ready
                                                         note: T = one AHB clock                                               */
           uint32_t             :  1;
      __IO uint32_t  FW_CTRLR_EN:  1;               /*!< FW control read ready latency (REGR_RDY_SEL)
                                                         1: Enable
                                                         0: Disable (by HW auto control, about 2T ~ 4T)                        */
           uint32_t             :  3;
      __IO uint32_t  REGW_RDY_SEL:  5;              /*!< Register write ready selection, active when FW_CTRLW_EN = 1;
                                                         Because write access need to sync. to UTMI clock domain, HREADY
                                                         de-assert cycles
                                                         according to AHB clock. This value can set 1 to 31.
                                                         Reference (fastest) value example:
                                                         5'h3 (4T) when HCLK = 25Mhz;
                                                         5'h5 (6T) when HCLK = 50Mhz;
                                                         5'ha (11T) when HCLK = 100Mhz; (default)
                                                         5'hf (16T) when HCLK = 150Mhz;
                                                         5'h14 (21T) when HCLK = 200Mhz;
                                                         5'h19 (26T) when HCLK = 250Mhz;
                                                         Note1: T = one AHB clock
                                                         Note2: Write 0 is equal to write 31
                                                         Note3: The value can be set                                           */
      __IO uint32_t  FW_CTRLW_EN:  1;               /*!< FW control write ready latency (REGW_RDY_SEL)
                                                         1: Enable
                                                         0: Disable (by HW auto control)                                       */
      __IO uint32_t  REGW_FAST_MODE:  1;            /*!< Register write sync. fast mode
                                                         1:Enable (2-stage destination F.F)
                                                         0:Disable ( conservative mode, 3-stage F.F)                           */
           uint32_t             :  1;
      __IO uint32_t  RETRY_EN   :  1;               /*!< 1: AHBS RETRY/SPLIT enable;
                                                         0: AHBS OK response only;                                             */
      __IO uint32_t  SPLIT_SEL  :  1;               /*!< 1: AHBS SPLIT enable;
                                                         0: AHBS RETRY enable;                                                 */
    };
  };
} EHCI_1_Type;


/* ================================================================================ */
/* ================                      USBD                      ================ */
/* ================================================================================ */


/**
  * @brief USB 2.0 Device IP (USBD)
  */

typedef struct {                                    /*!< USBD Structure                                                        */
  
  union {
    __IO uint32_t  USBD_CONF;                       /*!< Global Configuration Register                                         */
    
    struct {
      __O  uint32_t  CFGRST     :  1;               /*!< Reset USB device configuration                                        */
      __O  uint32_t  CFGSET     :  1;               /*!< Set Configuration (The actual configuration status can be checked
                                                         in the USB_STS register)                                              */
           uint32_t             :  2;
      __O  uint32_t  USB2DIS    :  1;               /*!< Disconnect USB device in HS/FS (To connect disconnected device,
                                                         CPU performs software reset (UCB_CFG.SWRST))                          */
      __O  uint32_t  LENDIAN    :  1;               /*!< Little Endian access (When both LENDIAN and BENDIAN bits are
                                                         set to '1' while writing to USB_CONF register, the device behavior
                                                          is undefined)                                                        */
      __O  uint32_t  BENDIAN    :  1;               /*!< Big Endian access (When both LENDIAN and BENDIAN bits are set
                                                         to '1' while writing to USB_CONF register, the device behavior
                                                          is undefined)                                                        */
      __IO uint32_t  SWRST      :  1;               /*!< Device software reset                                                 */
      __O  uint32_t  DSING      :  1;               /*!< Singular DMA transfer mode (The status of this settings can
                                                         be check in the)                                                      */
      __O  uint32_t  DMULT      :  1;               /*!< Multiple DMA transfers mode (This bit is always '0' while reading.
                                                         The status of this settings can be check in the USB_STS.DTRANS
                                                          bit)                                                                 */
           uint32_t             :  2;
      __O  uint32_t  CFORCE_FS  :  1;               /*!< Clear Force Full Speed (When both SFORCE_FS and CFORCE_FS bits
                                                         are set to '1' while writing to USB_CONF register, the device
                                                          behavior is undefined. The status of this settings can be check
                                                          in the USB_STS.DISABLE_HS bit)                                       */
      __O  uint32_t  SFORCE_FS  :  1;               /*!< Set Force Full Speed (When both SFORCE_FS and CFORCE_FS bits
                                                         are set to '1' while writing to USB_CONF register, the device
                                                          behavior is undefined. The status of this settings can be check
                                                          in the USB_STS.DISABLE_HS bit)                                       */
      __O  uint32_t  DEVEN      :  1;               /*!< Device enable                                                         */
      __O  uint32_t  DEVDS      :  1;               /*!< Device disable                                                        */
      __O  uint32_t  L1EN       :  1;               /*!< L1 LPM state entry enable (device side) (used in HS/FS mode)
                                                         When both L1EN and L1DS bits are set to '1' while writing to
                                                          USB_CONF register, the device behavior is undefined                  */
      __O  uint32_t  L1DS       :  1;               /*!< L1 LPM state entry disable (used in HS/FS mode)When both L1EN
                                                         and L1DS bits are set to '1' while writing to USB_CONF register,
                                                          the device behavior is undefined.                                    */
      __O  uint32_t  CLK2OFFEN  :  1;               /*!< USB 2.0 clock gate disable (The actual USB 2.0 clock gate status
                                                         in can be checked in the USB_STS.USB2OFF register. When both
                                                          CLK2OFFDS and CLK2OFFEN bits are set to '1' while writing to
                                                          USB_CONF register, the device behavior is undefined)                 */
      __O  uint32_t  CLK2OFFDS  :  1;               /*!< USB 2.0 clock gate enable                                             */
      __IO uint32_t  LGO_L0     :  1;               /*!< L0 LPM state entry request (used in HS/FS mode) If the LPM is
                                                         suspended (L2 state) and CPU set this bit to 1, upstream will
                                                          start driving resume signaling to indicate remote wakeup             */
    };
  };
  
  union {
    __I  uint32_t  USB_STS;                         /*!< Global Status Register                                                */
    
    struct {
      __I  uint32_t  CFGSTS     :  1;               /*!< Configuration status                                                  */
      __I  uint32_t  MEM_OV     :  1;               /*!< On-chip memory overflow (After each completion of enumeration
                                                         software should check this bit, and when a memory overflow occurred,
                                                          software must delete current configuration (using USB_CONF.CFGRST
                                                          bit) and then set the one that requires less on-chip memory)         */
           uint32_t             :  1;
      __I  uint32_t  DTRANS     :  1;               /*!< DMA transfer configuration status (This DMA transfer configuration
                                                         settings can be changed by using bits USB_CONF.DSING and USB_CONF.DMULT) */
      __I  uint32_t  USBSPEED   :  3;               /*!< Device speed (Low speed is not support)                               */
      __I  uint32_t  SFR_ENDA   :  1;               /*!< Endianess for SFR access (Little/Big Endian byte order for SFR
                                                         access) Endian byte order for SFR access can be changed by setting
                                                          BENDIAN or LEDNIAN bits in USB_CONF register                         */
      __I  uint32_t  CLK2OFF    :  1;               /*!< HS/FS clock turn-off status (When CLK2OFF bit is '0', the utmisuspendm
                                                         output signal is not set low in USB2.0 suspend state (L2 state),
                                                          thus USB2.0 PHY does not turn off the CLKHSFS clock)                 */
           uint32_t             :  5;
      __I  uint32_t  DEVS       :  1;               /*!< Device enable Status (This bit can be changed by setting DEVEN
                                                         or DEVDS bits in USB_CONF register)                                   */
      __I  uint32_t  ADDRESSED  :  1;               /*!< Address status                                                        */
      __I  uint32_t  L1ENS      :  1;               /*!< L1 LPM state enable status (used in HS/FS mode)                       */
      __I  uint32_t  VBUSS      :  1;               /*!< Internal VBUS connection status (used both in HS/FS and SS mode)      */
      __I  uint32_t  LPMST      :  2;               /*!< HS/FS LPM state (used in FS/HS mode) This field reflects USBSS-DEV
                                                         current LPM (used in HS/FS mode) state                                */
      __I  uint32_t  USB2CONS   :  1;               /*!< HS/FS mode connection status (used in FS/HS mode)                     */
      __I  uint32_t  DISABLE_HS :  1;               /*!< Disable HS status (used in FS/HS mode)                                */
           uint32_t             :  9;
      __I  uint32_t  SFR_EDNS   :  1;               /*!< SFR Endian status Little/Big Endian byte order for SFR access         */
    };
  };
  
  union {
    __O  uint16_t  USB_CMD;                         /*!< Global Command Register                                               */
    
    struct {
      __O  uint16_t  SET_ADDR   :  1;               /*!< Set Function Address (After saving device address, software
                                                         should (as with all other requests) EP_CMD.ERDY bit set to quit
                                                          the setup phase and then set bit EP_CMD.REQ_CMPL to confirm
                                                          the status of the host phase)                                        */
      __O  uint16_t  FADDR      :  7;               /*!< Function Address (This field is saved to the device only when
                                                         the field SET_ADDR is)                                                */
           uint16_t             :  1;
      __O  uint16_t  STMODE     :  1;               /*!< Set Test Mode (used only in HS/FS mode)                               */
      __O  uint16_t  TMODE_SEL  :  2;               /*!< Test mode selector (used only in HS/FS mode) This field contains
                                                         selected Test Mode, Device will enter this Test mode when 1
                                                          is written to STMODE. USB 2.0 Test mode selector:                    */
    };
  };
  __I  uint16_t  RESERVED;
  
  union {
    __I  uint16_t  USB_ITPN;                        /*!< ITP/SOF number Register                                               */
    
    struct {
      __I  uint16_t  ITPN       : 14;               /*!< SOF (HS/FS) number (In HS/FS mode the field [13:3] represents
                                                         number of last SOF received from host. The field [2:0] represents
                                                          number of micro frame counted by device and will be cleared
                                                          bythe field [13:3] increasing)                                       */
    };
  };
  __I  uint16_t  RESERVED1;
  
  union {
    __IO uint8_t   USB_LPM;                         /*!< Global Command Register                                               */
    
    struct {
      __IO uint8_t   HIRD       :  4;               /*!< Host Initiated Resume DurationThis is the Resume duration from
                                                         L1 LPM state, received from the host in the latest Extended
                                                          Token packet                                                         */
      __I  uint8_t   BRW        :  1;               /*!< Remote Wakeup Enable (bRemoteWake)                                    */
    };
  };
  __I  uint8_t   RESERVED2[3];
  
  union {
    __IO uint32_t  USB_IEN;                         /*!< USB Interrupt Enable Register                                         */
    
    struct {
           uint32_t             : 10;
      __IO uint32_t  ITPIEN     :  1;               /*!< ITP/SOF packet detected interrupt enable (This bit enables requesting
                                                         an ITPI interrupt)                                                    */
      __IO uint32_t  WAKEIEN    :  1;               /*!< Wakeup interrupt enable (This bit enables requesting a Wakeup
                                                         interrupt)                                                            */
           uint32_t             :  4;
      __IO uint32_t  CON2IEN    :  1;               /*!< HS/FS mode connection interrupt enable (This bit enables requesting
                                                         a CON2I interrupt)                                                    */
      __IO uint32_t  DIS2IEN    :  1;               /*!< HS/FS mode disconnection interrupt enable (This bit enables
                                                         requesting a DIS2I interrupt.)                                        */
      __IO uint32_t  U2RESIEN   :  1;               /*!< USB reset (HS/FS mode) interrupt enable (This bit enables requesting
                                                         an U2RESI interrupt.)                                                 */
           uint32_t             :  1;
      __IO uint32_t  L2ENTIEN   :  1;               /*!< LPM L2 state enter interrupt enable (This bit enables requesting
                                                         an L2ENTI interrupt.)                                                 */
      __IO uint32_t  L2EXTIEN   :  1;               /*!< LPM L2 state exit interrupt enable (This bit enables requesting
                                                         an L2EXTI interrupt.)                                                 */
           uint32_t             :  2;
      __IO uint32_t  L1ENTIEN   :  1;               /*!< LPM L1 state enter interrupt enable (This bit enables requesting
                                                         an L1ENTI interrupt.)                                                 */
      __IO uint32_t  L1EXTIEN   :  1;               /*!< LPM L1 state exit interrupt enable (This bit enables requesting
                                                         an L1EXTI interrupt.)                                                 */
      __IO uint32_t  CFGRESIEN  :  1;               /*!< Configuration reset interrupt enable (This bit enables requesting
                                                         a CFGRESI interrupt.)                                                 */
      __IO uint32_t  REGTOIEN   :  1;               /*!< Register access Timeout Interrupt enable (This bit enables requesting
                                                         a REGTOI interrupt.)                                                  */
    };
  };
  
  union {
    __IO uint32_t  USB_ISTS;                        /*!< USB Interrupt Status Register                                         */
    
    struct {
           uint32_t             : 10;
      __IO uint32_t  ITPI       :  1;               /*!< ITP/SOF packet detected (In FS/HS mode this interrupt informs
                                                         that SOF was detected. This interrupt is reported on the O2_IRQS
                                                          [0] pin)                                                             */
      __IO uint32_t  WAKEI      :  1;               /*!< Wakeup(This interrupt informs that at wakeup pin appeared active
                                                         states. This interrupt is reported on the O2_IRQS [1] pin.)           */
           uint32_t             :  4;
      __IO uint32_t  CON2I      :  1;               /*!< HS/FS mode connection detected(This interrupt informs that HS/FS
                                                         upstream port was connected to the USB line)                          */
      __IO uint32_t  DIS2I      :  1;               /*!< HS/FS mode disconnection detected (This interrupt informs that
                                                         HS/FS upstream port was disconnected from the USB line. This
                                                          interrupt is reported on the O2_IRQS[0] pin.)                        */
      __IO uint32_t  U2RESI     :  1;               /*!< USB reset (HS/FS mode) detected (This interrupt is requested
                                                         after the USB reset in HS/FS mode ends. This interrupt is reported
                                                          on the O2_IRQS[0] pin.)                                              */
           uint32_t             :  1;
      __IO uint32_t  L2ENTI     :  1;               /*!< LPM L2 state enter detected (This interrupt informs that HS/FS
                                                         LPM enter L2 state. This interrupt is reported on the O2_IRQS[0]
                                                          pin.)                                                                */
      __IO uint32_t  L2EXTI     :  1;               /*!< LPM L2 state exit detected (This interrupt informs that HS/FS
                                                         LPM exit L2 state. This interrupt is reported on the O2_IRQS[1]
                                                          pin.)                                                                */
           uint32_t             :  2;
      __IO uint32_t  L1ENTI     :  1;               /*!< LPM L1 state enter detected (This interrupt informs that HS/FS
                                                         LPM enter L1 state.This interrupt is reported on the O2_IRQS[0]
                                                          pin.)                                                                */
      __IO uint32_t  L1EXTI     :  1;               /*!< LPM L1 state exit detected (This interrupt informs that HS/FS
                                                         LPM exit L1 state. This interrupt is reported on the O2_IRQS[0]
                                                          pin.)                                                                */
      __IO uint32_t  CFGRESI    :  1;               /*!< USB configuration reset detected (This interrupt is requested
                                                         after the device internally resets its endpoints configuration)       */
      __I  uint32_t  REGTOI     :  1;               /*!< Register access Timeout detected
                                                         This interrupt informs that SFR access timeout (Set by REG_ACC_TO_CNT)
                                                         when MISC.
                                                         REG_ACC_TO_EN enable. This error occur maybe USB clock lost.
                                                         This bit belongs to INTEN_TYPE1.                                      */
    };
  };
  
  union {
    __IO uint8_t   EP_SEL;                          /*!< Endpoint Select Register                                              */
    
    struct {
      __IO uint8_t   EPNO       :  4;               /*!< Endpoint number                                                       */
           uint8_t              :  3;
      __IO uint8_t   DIR        :  1;               /*!< Endpoint directionMeaning of this bit                                 */
    };
  };
  __I  uint8_t   RESERVED3[3];
  __IO uint32_t  EP_TRADDR;                         /*!< Endpoint Transfer Ring Address Register                               */
  
  union {
    __IO uint32_t  EP_CFG;                          /*!< Endpoint Configuration Register                                       */
    
    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< Endpoint enable (If endpoint is disabled (the ENABLE bit is
                                                         cleared), the endpoint will not: request any interrupts start
                                                          any transmission over the DMA Even if Endpoint is disabled,
                                                          software can set DRDY bit for it, but the DMA transmission will
                                                          not begin until the endpoint is enabled.)                            */
      __IO uint32_t  EPTYPE     :  2;               /*!< Endpoint type (Endpoint type is programmable; however, certain
                                                         types of transmissions require hardware support that must be
                                                          incorporated prior to implementation. That can be done only
                                                          for selected endpoints. Selective inclusion of hardware support
                                                          is to reduce the size of the controller)                             */
           uint32_t             : 11;
      __IO uint32_t  MULT       :  2;               /*!< ISO max burst (HS/FS mode:This field indicates how many packets
                                                         will be transferred during micro frame. In Full-Speed mode only
                                                          one ISO IN packet can be transferred per endpoint, per frame,
                                                          thus this field has to be always 0. In High-Speed mode, up to
                                                          three ISO IN packets can be transferred per endpoint, per microframe,
                                                          so the max value that can be set in this field in High Speed
                                                          is 2)                                                                */
      __IO uint32_t  MAXPKTSIZE : 11;               /*!< Max packet size (The maximum packet size this endpoint is capable
                                                         of sending or receiving.)                                             */
      __IO uint32_t  BUFFERING  :  5;               /*!< Max number of buffered packets (The maximum number of packets
                                                         the device can buffer in the on-chip memory for a specified
                                                          endpoint. Valid values are from 0 to 15. Value 0 means that
                                                          1 on-chip buffer is available for the appropriate endpoint.
                                                          Value 15 means that 16 on-chip buffers are available for the
                                                          appropriate endpoint)                                                */
    };
  };
  
  union {
    __IO uint8_t   EP_CMD;                          /*!< Endpoint Command Register                                             */
    
    struct {
      __IO uint8_t   EPRST      :  1;               /*!< Endpoint reset (This command performs the following actions
                                                         for particular endpoint: clears DRDY bit and stops DMA transfer
                                                          clears on-chip buffers clears Data Toggle in HS/FS mode After
                                                          endpoint reset the software is responsible for it to re-set
                                                          the Endpoint TRADDR)                                                 */
      __IO uint8_t   SSTALL     :  1;               /*!< Endpoint STALL set (Writing 1 to this bit cause the endpoint
                                                         is halted)                                                            */
      __IO uint8_t   CSTALL     :  1;               /*!< Endpoint STALL clear (Writing 1 to this bit became not halted)        */
      __IO uint8_t   ERDY       :  1;               /*!< ERDY (Writing 1 to this bit forces the device EP0 to send data
                                                         or ACK to host. This bit only for EP0. Detail EP0 flow please
                                                          refer to CH8.5~CH8.8)                                                */
           uint8_t              :  1;
      __IO uint8_t   REQ_CMPL   :  1;               /*!< Request complete (Writing 1 to this bit informs SNUSB20DEVAHB
                                                         that software finished USB request service and device can send
                                                          ACK answer for the Status Stage within USB request. This bit
                                                          is automatically cleared by SNUSB20DEVAHB after device answers
                                                          to the status stage with ACK or STALL. Until software do not
                                                          set this bit, during proceeding current host request, the device
                                                          will answer to the status stage with NRDY answer)                    */
      __IO uint8_t   DRDY       :  1;               /*!< Transfer descriptor ready (Transfer Descriptor Ready for selected
                                                         endpoint) Writing 1 to this bit informs SNUSB20DEVAHB that in-system
                                                          memory has prepared a new Transfer Descriptor for selected endpoints.If
                                                          an IN endpoint is Not Ready (NRDY=1 in Endpoint Status Register),
                                                          then setting the DRDY bit (which is proceeded by DMA transfer
                                                          to the on-chip buffers) will cause the device to send the ERDY
                                                          packet. If the TRB error occurs, the DRDY bit is cleared and
                                                          held in the low state until the TRBERR is not cleare                 */
      __IO uint8_t   DFLUSH     :  1;               /*!< Data flush                                                            */
    };
  };
  __I  uint8_t   RESERVED4[3];
  
  union {
    __IO uint32_t  EP_STS;                          /*!< Endpoint Status Register                                              */
    
    struct {
      __IO uint32_t  SETUP      :  1;               /*!< Setup transfer complete (Bit used only for EP0) If setup type
                                                         transmission has been completed and data from host has been
                                                          received and copied to system memory, this bit is set to 1 and
                                                          interrupt is generated. Setup packet is applicable only to control
                                                          transmissions (EP0). This interrupt can be masked by the corresponding
                                                          bit in EP_STS_EN register                                            */
      __I  uint32_t  STALL      :  1;               /*!< Endpoint STALL status (This bit is not treated as an interrupt
                                                         (not reported in the EP_ISTS register))                               */
      __IO uint32_t  IOC        :  1;               /*!< Interrupt On Complete (When DMA transfer is completed and transfer
                                                         descriptor is updated, then this bit is set to 1 and interrupt
                                                          is generated.)                                                       */
      __IO uint32_t  ISP        :  1;               /*!< Interrupt on Short Packet (This bit is set to 1 and interrupt
                                                         is Generated when a transfer containing less data than MaxPacket
                                                          or device expects receiving a short packet for a given endpoint
                                                          has been completed and transfer descriptor has been updated.
                                                          Enabling or disabling of interrupt is realized by ISP bit in
                                                          transfer descriptor. Additionally, this interrupt can be masked
                                                          for a particular endpoint in EP_ISTS register)                       */
      __IO uint32_t  DESCMIS    :  1;               /*!< Transfer descriptor missing (This bit is set to 1 and interrupt
                                                         is generated when any of the following conditions are met:device
                                                          is requested to send data to host and none of Transfer Descriptor
                                                          is prepared (IN transfer) device receives OUT packet and cannot
                                                          transmit it using DMA as Transfer Descriptor has not been prepared
                                                          (DRBL was not set) for it (OUT transfer))                            */
           uint32_t             :  2;
      __IO uint32_t  TRBERR     :  1;               /*!< TRB error (This bit is set if DMA read corrupted TRB (wrong
                                                         C bit value or TRB type). Address of the TRB is stored in the
                                                          EP_TRADDR register. This interrupt can be masked by the corresponding
                                                          bit in EP_STS_EN register. If this error occurs, the bit DRDY
                                                          is cleared and held in the low state until the TRBERR is not
                                                          cleared. To start the DMA again, the software has to clear this
                                                          interrupt and set the DRDY bit once more.)                           */
           uint32_t             :  1;
      __I  uint32_t  DBUSY      :  1;               /*!< DMA busy (This bit is set to 1 while the DMA services the endpoint.
                                                         Through the service means either actual transmission of data
                                                          between on-chip cache and system memory for particular endpoint
                                                          or a pending data transmission which has already begun but was
                                                          interrupted by endpoint with a higher priority. Such pending
                                                          transmissions will begin automatically themselves after these
                                                          higher priorities.)                                                  */
      __I  uint32_t  BUFFEMPTY  :  1;               /*!< Endpoint Buffer Empty (This bit is set to 1 there are no packets
                                                         for the particular endpoint in the on-chip buffers. This bit
                                                          is not treated as an interrupt (is not reported in the EP_ISTS
                                                          register))                                                           */
      __I  uint32_t  CCS        :  1;               /*!< Current Cycle Status (Informs about current value of C bit corresponding
                                                         to DMA ownership of TRBs for selected endpoint)                       */
           uint32_t             :  2;
      __IO uint32_t  OUTSMM     :  1;               /*!< OUT size mismatch (This bit is set when host sends a different
                                                         data size than device was anticipating (according to Data Length
                                                          field in TRB).In such a case, the DMA updates length field in
                                                          current TRB, updates TRADDR (next TRB address), and triggers
                                                          the interrupt. DMA will not start processing TRB ring of this
                                                          EP until its DRBL is rung.) This interrupt can be masked by
                                                          the corresponding bit in EP_STS_EN register                          */
      __IO uint32_t  ISOERR     :  1;               /*!< ISO transmission error (Error of isochronous transmission. This
                                                         bit is set during data transmission to/from ISO endpoints while
                                                          the last data transfer at PIPE IF is in current micro frame)
                                                          This interrupt can be masked by the corresponding bit in EP_STS_EN
                                                          register                                                             */
           uint32_t             :  8;
      __I  uint32_t  OUTQ_NO    :  4;               /*!< OUT queue endpoint number (This field shows the number of the
                                                         endpoint to which the packet, received by the host, currently
                                                          is waiting to be transmitted by the DMA from the on-chip buffers
                                                          to the system memory. As there is one buffers queue for all
                                                          Out Endpoints, this field is not endpoint related, and thus
                                                          it can be read regardless of current value stored in the EP_SEL
                                                          register)                                                            */
      __I  uint32_t  OUTQ_VAL   :  1;               /*!< OUT queue valid flag (This field indicates whether the endpoint
                                                         number of the packet waiting for transmission by the DMA, is
                                                          valid or not. In other words, whether the packet queue is not
                                                          empty)                                                               */
           uint32_t             :  2;
      __IO uint32_t  STPWAIT    :  1;               /*!< SETUP WAIT (Bit used only for EP0.) If setup packet is received
                                                         correctly and stored in the on-chip buffer, this bit is set
                                                          to 1 and interrupt is generated. Setup packet is applicable
                                                          only to control transmissions (EP0)                                  */
    };
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  EP_STS_EN;                       /*!< Endpoint Status Register Enable                                       */
    
    struct {
      __IO uint32_t  SETUPEN    :  1;               /*!< Setup transfer complete (SETUP interrupt enable)                      */
           uint32_t             :  3;
      __IO uint32_t  DESCMISEN  :  1;               /*!< OUT transfer missing descriptor enable (OUTMIS interrupt enable)      */
           uint32_t             :  2;
      __IO uint32_t  TRBERREN   :  1;               /*!< TRB enable (TRBERR interrupt enable)                                  */
           uint32_t             :  6;
      __IO uint32_t  OUTSMMEN   :  1;               /*!< OUT size mismatch enable (OUTSMM interrupt enable)                    */
      __IO uint32_t  ISOERREN   :  1;               /*!< ISO transmission error enable (ISOERR interrupt enable)               */
           uint32_t             : 15;
      __IO uint32_t  STPWAITEN  :  1;               /*!< Setup Wait interrupt enable (This bit enables the STPWAIT interrupt)  */
    };
  };
  
  union {
    __IO uint32_t  DRBL;                            /*!< Doorbell Register                                                     */
    
    struct {
      __IO uint32_t  DRBL0O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL1O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL2O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL3O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL4O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL5O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL6O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL7O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL8O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL9O     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL10O    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL11O    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL12O    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL13O    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL14O    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL15O    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL0I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL1I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL2I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL3I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL4I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL5I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL6I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL7I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL8I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL9I     :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL10I    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL11I    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL12I    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL13I    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL14I    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
      __IO uint32_t  DRBL15I    :  1;               /*!< Register is used for initiating transfers with one access to
                                                         SNUSB20DEVAHB, without use of the EP_SEL register. Each bit
                                                          corresponds to one endpoint. Each of these bits has the same
                                                          role as the DRDY bit in the EP_CMD register (Writing 1 to this
                                                          bit informs SNUSB20DEVAHB that a new Transfer Descriptor is
                                                          prepared in system memory for selected endpoints)                    */
    };
  };
  
  union {
    __IO uint32_t  EP_IEN;                          /*!< EP Interrupt Enable Register                                          */
    
    struct {
      __IO uint32_t  EOUTEN0    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN1    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN2    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN3    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN4    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN5    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN6    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN7    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN8    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN9    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN10   :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN11   :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN12   :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN13   :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN14   :  1;               /*!< (null)                                                                */
      __IO uint32_t  EOUTEN15   :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN0     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN1     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN2     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN3     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN4     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN5     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN6     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN7     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN8     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN9     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN10    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN11    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN12    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN13    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN14    :  1;               /*!< (null)                                                                */
      __IO uint32_t  EINEN15    :  1;               /*!< (null)                                                                */
    };
  };
  
  union {
    __I  uint32_t  EP_ISTS;                         /*!< EP Interrupt Status Register                                          */
    
    struct {
      __I  uint32_t  EOUT_0     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_1     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_2     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_3     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_4     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_5     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_6     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_7     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_8     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_9     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_10    :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_11    :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_12    :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_13    :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_14    :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EOUT_15    :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_0      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_1      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_2      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_3      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_4      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_5      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_6      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_7      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_8      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_9      :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_10     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_11     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_12     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_13     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_14     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
      __I  uint32_t  EIN_15     :  1;               /*!< Endpoints interrupt vector (EIN.n/EOUT.n bit corresponds to
                                                         interrupt request of n-number endpoint. The reason for interrupt
                                                          can be read from EP_STS. Interrupt remains valid until given
                                                          EP_STS.n is cleared by writing in the corresponding bit)             */
    };
  };
  __I  uint32_t  RESERVED6[11];
  
  union {
    __IO uint16_t  SE0_CHK;                         /*!< SE0 check timing point for clock stable                               */
    
    struct {
      __IO uint16_t  REG_03FF   :  8;               /*!< SE0 Check Timing Point (UTMI Clock Gated) unit: 10us                  */
      __I  uint16_t  UCLK_GATED_RDY:  1;            /*!< UTMI Clock Ready indication (There are two UTMI clock gated
                                                         state (clock off internal), one is Power on (2ms) and another
                                                          is suspend to resume finish (resume gated time by SE0_CHK);
                                                          initially, FW need to check this bit until to 1, then start
                                                          normal register access flow)                                         */
      __IO uint16_t  DISABLE_UCLK_GATED:  1;        /*!< Disable UTMI Clock Gated. Set will disable UTMI Clock Gated
                                                         .(Force clock on)                                                     */
    };
  };
  __I  uint16_t  RESERVED7;
  __IO uint8_t   SE0_STABLE;                        /*!< SE0 stable time                                                       */
  __I  uint8_t   RESERVED8[3];
  
  union {
    __IO uint32_t  MISC_CTR;                        /*!< Miscellaneous control register                                        */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  HEADER2B   :  1;               /*!< Header 2Byte Enable                                                   */
      __IO uint32_t  SCR_PTS_EXIST:  1;             /*!< Source Clock Reference and Presentation Time Stamp Exist              */
      __IO uint32_t  FRAME_SRC_EN:  1;              /*!< Frame Source Clock Enable                                             */
      __IO uint32_t  UVC_ISO_EN :  1;               /*!< UVC ISO Enable                                                        */
      __IO uint32_t  RETRY_EN   :  1;               /*!< RETRY ENABLE                                                          */
           uint32_t             :  7;
      __IO uint32_t  REG_ACC_TO_EN:  1;             /*!< Register access Timeout Enable                                        */
      __IO uint32_t  REG_ACC_TO_CNT:  2;            /*!< Register access Timeout Count                                         */
           uint32_t             :  5;
      __IO uint32_t  TMDBPS     :  2;               /*!< Test mode bypass selector (used only for SA test patterns)            */
      __IO uint32_t  TMDBPS_EN  :  1;               /*!< Test mode bypass(chirp and cx flow) enable                            */
    };
  };
  
  union {
    __IO uint32_t  REG_007C;                        /*!< EP new maxpktsize register                                            */
    
    struct {
      __IO uint32_t  EP_NEW_MAXPKTSIZE: 11;         /*!< Set EP Transfer MaxPktSize(New MaxPktSize <= Config MaxPktSize).      */
           uint32_t             : 20;
      __IO uint32_t  EP_NEW_MAXPKTSIZE_EN:  1;      /*!< Enable MaxPktSize                                                     */
    };
  };
  
  union {
    __IO uint32_t  USB_ISTS_CLEAR;                  /*!< USB Interrupt Status Clear register                                   */
    
    struct {
           uint32_t             : 10;
      __O  uint32_t  ITPI_C     :  1;               /*!< ITP/SOF packet detected CLEAR                                         */
      __O  uint32_t  WAKEI_C    :  1;               /*!< Wakeup CLEAR                                                          */
           uint32_t             :  4;
      __O  uint32_t  CON2I_C    :  1;               /*!< HS/FS mode connection detected CLEAR                                  */
      __O  uint32_t  DIS2I_C    :  1;               /*!< HS/FS mode disconnection detected CLEAR                               */
      __O  uint32_t  U2RESI_C   :  1;               /*!< USB reset (HS/FS mode) detected CLEAR                                 */
           uint32_t             :  1;
      __O  uint32_t  L2ENTI_C   :  1;               /*!< LPM L2 state enter detected CLEAR                                     */
      __O  uint32_t  L2EXTI_C   :  1;               /*!< LPM L2 state exit detected CLEAR                                      */
           uint32_t             :  2;
      __O  uint32_t  L1ENTI_C   :  1;               /*!< LPM L1 state enter detected CLEAR                                     */
      __O  uint32_t  L1EXTI_C   :  1;               /*!< LPM L1 state exit detected CLEAR                                      */
      __O  uint32_t  CFGRESI_C  :  1;               /*!< USB configuration reset detected CLEAR                                */
      __O  uint32_t  REGTOI_C   :  1;               /*!< Register access Timeout detected CLEAR                                */
    };
  };
  
  union {
    __IO uint32_t  EP_STS_CLEAR;                    /*!< EP Status Clear register                                              */
    
    struct {
      __O  uint32_t  SETUP_C    :  1;               /*!< Setup transfer complete                                               */
           uint32_t             :  1;
      __O  uint32_t  IOC_C      :  1;               /*!< Interrupt On Complete CLEAR                                           */
      __O  uint32_t  ISP_C      :  1;               /*!< Interrupt on Short Packet CLEAR                                       */
      __O  uint32_t  DESCMIS_C  :  1;               /*!< Transfer descriptor missing CLEAR                                     */
           uint32_t             :  2;
      __O  uint32_t  TRBERR_C   :  1;               /*!< TRB error CLEAR                                                       */
           uint32_t             :  6;
      __O  uint32_t  OUTSMM_C   :  1;               /*!< OUT size mismatch CLEAR                                               */
      __O  uint32_t  ISOERR_C   :  1;               /*!< ISO transmission error CLEAR                                          */
           uint32_t             : 15;
      __O  uint32_t  STPWAIT_C  :  1;               /*!< SETUP WAIT CLEAR                                                      */
    };
  };
  __IO uint32_t  RAM_SIZE;                          /*!< Ram Size register                                                     */
} USBD_Type;


/* ================================================================================ */
/* ================                       IMG                      ================ */
/* ================================================================================ */


/**
  * @brief Image Control (IMG)
  */

typedef struct {                                    /*!< IMG Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< IMG_MODE                                                              */
    
    struct {
      __IO uint32_t  H264DEC_EN :  1;               /*!< Enable h264 decoder                                                   */
      __IO uint32_t  H264ENC_EN :  1;               /*!< Enable h264 encoder                                                   */
      __IO uint32_t  JPEG_EN    :  1;               /*!< Enable jpeg encoder                                                   */
      __IO uint32_t  SCALE_EN   :  1;               /*!< Enable scaling down                                                   */
      __IO uint32_t  IMG_TX_EN  :  1;               /*!< Start processing the frame.                                           */
      __I  uint32_t  IMG_TX_OK  :  1;               /*!< Frame processing is complete.                                         */
      __IO uint32_t  AUTO_CLR_IMG_TX_EN:  1;        /*!< 1:Auto clear image TX enable signal                                   */
           uint32_t             :  1;
      __IO uint32_t  IMG_NO     :  2;               /*!< 0:only 1Image 1:Combine 2 image 2:Combine 3 image                     */
      __IO uint32_t  IMG_NO_YUV_H_RATIO:  2;        /*!< Scaling down in H Direction 1:1/1 2:1/2 3:1/4                         */
      __IO uint32_t  IMG_NO_YUV_V_RATIO:  2;        /*!< Scaling down in V Direction 1:1/1 2:1/2 3:1/4                         */
      __IO uint32_t  ISP_IMG_LOCATE:  2;            /*!< ISP Image is in 1: 1 Location 2:2Location 3:3Location                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< DS_EN                                                                 */
    
    struct {
      __IO uint32_t  DS1_EN     :  1;               /*!< 1:date stamp enable 0:disable                                         */
      __IO uint32_t  DS1_WT     :  3;               /*!< Date stamp weighting selection.Note: OUT=(DS1_WT*TEXT+(8-DS1_WT)*IMG)/8. */
      __IO uint32_t  DS1_TRANS_EN:  1;              /*!< 1: Means Enable the transparent Color Function.                       */
           uint32_t             :  3;
      __IO uint32_t  DS_PALLET_ADDR:  8;            /*!< The DS_PALLET_SRAM Start address.                                     */
           uint32_t             : 13;
      __IO uint32_t  DS1_MODE   :  1;               /*!< Date stamp mode selection.Date stamp mode selection.1 : Use
                                                         direct text color mode.0 : Weighting mode for text color.             */
      __IO uint32_t  DS1_SIZE   :  2;               /*!< Date stamp size selection.00: 1bit is equal to one pixel.01:
                                                         2bits are equal to two pixels.10: 4bits are equal to four pixels.11:
                                                          no valid.                                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< DS_H_START                                                            */
    
    struct {
      __IO uint32_t  DS1_H_START:  8;               /*!< Horizontal start pixel for date stamp. (Unit: 16 pixels)              */
      __IO uint32_t  DS1_V_START:  8;               /*!< Vertical start line for date stamp. (Unit: 16 lines when 420)         */
      __IO uint32_t  DS1_H_STOP :  8;               /*!< Horizontal stop pixel for date stamp. (Unit: 16 pixels)               */
      __IO uint32_t  DS1_V_STOP :  8;               /*!< Vertical stop line for date stamp.(Unit: 16 lines when 420)           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< DS_PALLET_DI                                                          */
    
    struct {
      __IO uint32_t  DS_PALLET_DI: 16;              /*!< The DS_PALLET_DATA Which will be write to DS_PALLET_SRAM.DS_PALLET_DI[15:0
                                                         ] = {DS_Y[5:0],DS_CB[4:0],DS_CR[4:0]}.(Y Unit: 4 level at 8 bits
                                                         image)(CB Unit : 8 level at 8 bits image)(CR Unit : 8 level
                                                          at 8 bits image)DS_Y=0 and DS_CB=0 and DS_CR=0 means transparent
                                                          color.Note : When Write Data to DS_PALLET_DI, the DS_PALLET_ADDRwill
                                                          increase 1 automatically.                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< CURRENT_ADDR_STR                                                      */
    
    struct {
      __IO uint32_t  CURRENT_ADDR_STR: 32;          /*!< Starting address of current frame.(unit:4bytes)                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< CURRENT_ADDR_END                                                      */
    
    struct {
      __IO uint32_t  CURRENT_ADDR_END: 32;          /*!< End address of current frame. (unit:4bytes)                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0018;                      /*!< REF_REC _ADDR_STR                                                     */
    
    struct {
      __IO uint32_t  REF_REC_ADDR_STR: 32;          /*!< Starting address of reference/reconstruct frame. (unit:4bytes)        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< REF_REC_ADDR_END                                                      */
    
    struct {
      __IO uint32_t  REF_REC_ADDR_END: 32;          /*!< End address of reference/reconstruct frame. (unit:4bytes)             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< IMG_TX_INT                                                            */
    
    struct {
      __I  uint32_t  IMG_TX_INT :  1;               /*!< 1:image interrupt                                                     */
      __O  uint32_t  IMG_INT_CLR:  1;               /*!< 1:clear image interrupt(cleared by H/W)                               */
      __IO uint32_t  IMG_MASK_INT:  1;              /*!< 1:mask interrupt flag                                                 */
           uint32_t             :  5;
      __IO uint32_t  IMG_MIRROR_EN:  1;             /*!< 1: Enable Image Mirror Function                                       */
      __IO uint32_t  IMG_FLIP_EN:  1;               /*!< 1: Enable Image Flip Function                                         */
      __IO uint32_t  IMG_ROTATION_EN:  1;           /*!< 1: Enable Image Rotation Function.                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< WRITE_TO_REC                                                          */
    
    struct {
      __IO uint32_t  WRITE_TO_REC:  1;              /*!< 1:P frame write to reconstruct frame control signal.(must be
                                                         in small p)                                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< SCALE_ADDR_STR                                                        */
    
    struct {
      __IO uint32_t  SCALE_ADDR_STR: 32;            /*!< Starting address of scaling down of the frame. (unit:4bytes)          */
    };
  };
  __IO uint32_t  REG_0x002C;                        /*!< Reserved                                                              */
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< JPG_ADDR_STR                                                          */
    
    struct {
      __IO uint32_t  JPG_ADDR_STR: 32;              /*!< Starting address of bit-stream of jpeg encoder. (unit:8bytes)         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< DS2_ADDR_STR                                                          */
    
    struct {
      __IO uint32_t  DS2_ADDR_STR: 32;              /*!< Date stamp2 starting address. (If scaling enable parity must
                                                         be the samevalue. unit:4bytes)Example: Even line->0110 1100Odd
                                                          line ->0110 1100                                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0038;                      /*!< DS1_ADDR_STR                                                          */
    
    struct {
      __IO uint32_t  DS1_ADDR_STR: 32;              /*!< Date stamp1 starting address. (If scaling enable parity must
                                                         be the samevalue. unit:4bytes)Example: Even line->0110 1100Odd
                                                          line ->0110 1100                                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x003C;                      /*!< JPG_STR_CNT                                                           */
    
    struct {
      __IO uint32_t  QP         :  8;               /*!< QP data for jpeg encoder                                              */
      __IO uint32_t  JPG_STR_CNT: 20;               /*!< JPEG stream size(unit:4bytes)                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< ENC_QTAB                                                              */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  ENC_QTAB_SEL_RD:  1;           /*!< 1: Select read Q-table mode.0: Select write Q-table mode.             */
      __IO uint32_t  ENC_QTAB_RD_TRG:  1;           /*!< 1: Trigger to read Q-table.                                           */
           uint32_t             :  5;
      __IO uint32_t  ENC_QTAB_ADDR:  7;             /*!< Q-table read/write address.                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0044;                      /*!< ENC_QTAB_DAT                                                          */
    
    struct {
      __IO uint32_t  ENC_QTAB_DAT:  8;              /*!< Data port of Q-table.                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0048;                      /*!< BRIDGE_RDY                                                            */
    
    struct {
      __I  uint32_t  BRIDGE_RDY :  2;               /*!< 1:Asynchronous bridge is ready                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x004C;                      /*!< IMG _H_SIZE                                                           */
    
    struct {
      __IO uint32_t  IMG_H_SIZE :  8;               /*!< Horizontal pixel number for color original input.(Unit: 16 pixels)    */
      __IO uint32_t  IMG_V_SIZE :  8;               /*!< Vertical line number for color output. (Unit: 8 lines)                */
      __IO uint32_t  YUV_RATIO  :  2;               /*!< 0:1/1 scaling down1:1/2 scaling down2:1/4 scaling down3:reserved      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0050;                      /*!< DDR_IMG_SIZE                                                          */
    
    struct {
      __IO uint32_t  DDR_IMG_H_SIZE:  8;            /*!< Horizontal pixel number for DDR Image Data.(Unit: 16 pixels)          */
      __IO uint32_t  DDR_IMG_V_SIZE:  8;            /*!< Vertical line number for DDR Image Data. (Unit: 8 lines)              */
      __IO uint32_t  DDR_IMG_H_START:  8;           /*!< The start Pixel number for DDR Image Data.(Unit: 2 Pixels)            */
      __IO uint32_t  DDR_IMG_V_START:  8;           /*!< The start Line number for DDR Image Data.(Uint: 2 Lines)              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0054;                      /*!< DS2_EN                                                                */
    
    struct {
      __IO uint32_t  DS2_EN     :  1;               /*!< 1:date stamp enable 0:disable                                         */
      __IO uint32_t  DS2_WT     :  3;               /*!< Date stamp weighting selection.Note: OUT=(DS2_WT*TEXT+(8-DS2_WT)*IMG)/8. */
      __IO uint32_t  DS2_TRANS_EN:  1;              /*!< 1: Means Enable the transparent Color Function.                       */
           uint32_t             : 24;
      __IO uint32_t  DS2_MODE   :  1;               /*!< Date stamp mode selection.1 : Use direct text color mode.0 :
                                                         Weighting mode for text color.                                        */
      __IO uint32_t  DS2_SIZE   :  2;               /*!< Date stamp size selection.00: 1bit is equal to one pixel.01:
                                                         2bits are equal to two pixels.10: 4bits are equal to four pixels.11:
                                                          no valid.                                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0058;                      /*!< DS2_H_START                                                           */
    
    struct {
      __IO uint32_t  DS2_H_START:  8;               /*!< Horizontal start pixel for date stamp. (Unit: 16 pixels)              */
      __IO uint32_t  DS2_V_START:  8;               /*!< Vertical start line for date stamp. (Unit: 8 lines when 420)          */
      __IO uint32_t  DS2_H_STOP :  8;               /*!< Horizontal stop pixel for date stamp. (Unit: 16 pixels)               */
      __IO uint32_t  DS2_V_STOP :  8;               /*!< Vertical stop line for date stamp.(Unit: 8 lines when 420)            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x005C;                      /*!< DS_TRANS_DI                                                           */
    
    struct {
      __IO uint32_t  DS1_TRANS_DI: 16;              /*!< The DS1_TRANSPARENT_COLOR_DATA.DS1_TRANS_DI[15:0] ={DS1_TRANS_Y[5:0],
                                                         DS1_TRANS_CB[4:0], DS1_TRANS_CR[4:0]}.(DS1_TRANS_Y Unit: 4 level
                                                          at 8 bits image)(DS1_TRANS_CB Unit : 8 level at 8 bits image)(DS1_TRANS_CR
                                                          Unit : 8 level at 8 bits image)                                      */
      __IO uint32_t  DS2_TRANS_DI: 16;              /*!< The DS2_TRANSPARENT_COLOR_DATA.DS2_TRANS_DI[15:0] ={DS2_TRANS_Y[5:0],
                                                         DS2_TRANS_CB[4:0], DS2_TRANS_CR[4:0]}.(DS2_TRANS_Y Unit: 4 level
                                                          at 8 bits image)(DS2_TRANS_CB Unit : 8 level at 8 bits image)(DS2_TRANS_CR
                                                          Unit : 8 level at 8 bits image)                                      */
    };
  };
  __I  uint32_t  RESERVED[2];
  
  union {
    __IO uint32_t  REG_0x0068;                      /*!< H264_ENC_THD                                                          */
    
    struct {
      __IO uint32_t  H264_ENC_SIZE_THD: 16;         /*!< The Threshold Byte Number for H264 Encoded Bit-Stream(Unit :
                                                         1K Byte)                                                              */
      __I  uint32_t  H264_ENC_THD_OVERFLOW_FLAG:  1;/*!< 1: Means the H264 Enc threshold overflow occurs.                      */
           uint32_t             :  7;
      __O  uint32_t  H264_ENC_THD_OVERFLOW_CLR:  1; /*!< Write "1" to clear the"H264_ENC_THRESHOLD_OVERFLOW_FLAG to"
                                                         "0"                                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x006C;                      /*!< JPEG_ENC_THD                                                          */
    
    struct {
      __IO uint32_t  JPEG_ENC_SIZE_THD: 16;         /*!< The Threshold Byte Number for JPEG Encoded Bit-Stream(Unit :
                                                         1K Byte)                                                              */
      __I  uint32_t  JPEG_ENC_THD_OVERFLOW_FLAG:  1;/*!< 1: Means the JPEG Enc threshold overflow occurs.                      */
           uint32_t             :  7;
      __O  uint32_t  JPEG_ENC_THD_OVERFLOW_CLR:  1; /*!< Write"1"to clear theJPEG_ENC_THRESHOLD_OVERFLOW_FLAG                  */
    };
  };
  __I  uint32_t  RESERVED1[4];
  
  union {
    __IO uint32_t  REG_0x0080;                      /*!< FRAME2_CURRENT_ADDR_STR                                               */
    
    struct {
      __IO uint32_t  FRAME2_CURRENT_ADDR_STR: 32;   /*!< Starting address of current frame2.(unit : 8bytes)Note: Only
                                                         Valid in Three Frame Mode.                                            */
    };
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __IO uint32_t  REG_0x0088;                      /*!< FRAME3_CURRENT_ADDR_STR                                               */
    
    struct {
      __IO uint32_t  FRAME3_CURRENT_ADDR_STR: 32;   /*!< Starting address of current frame3.(unit : 8bytes)Note: Only
                                                         Valid in Three Frame Mode.                                            */
    };
  };
  __I  uint32_t  RESERVED3;
  
  union {
    __IO uint32_t  REG_0x0090;                      /*!< H264_RING_FIFO_START_ADDR                                             */
    
    struct {
      __IO uint32_t  H264_RING_FIFO_START_ADDR: 32; /*!< The H264 Encoder/Decoder Bit-Stream Ring FIFO Start Address.(Unit:
                                                         8bytes)                                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0094;                      /*!< H264_RING_FIFO_END_ADDR[                                              */
    
    struct {
      __IO uint32_t  H264_RING_FIFO_END_ADDR: 32;   /*!< The H264 Encoder/Decoder Bit-Stream Ring FIFO End Address.(Unit:8bytes) */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0098;                      /*!< H264_BIT_STREAM_START_ADDR                                            */
    
    struct {
      __IO uint32_t  H264_BIT_STREAM_START_ADDR: 32;/*!< The H264 Encoder/Decoder Bit-Stream Start Address for H264 Enc/Dec.(Uint:8
                                                         bytes)                                                                */
    };
  };
  __I  uint32_t  RESERVED4;
  
  union {
    __IO uint32_t  REG_0x00A0;                      /*!< JPEG_RING_FIFO_START_ADDR[                                            */
    
    struct {
      __IO uint32_t  JPEG_RING_FIFO_START_ADDR: 32; /*!< The JPEG Encoder Bit-Stream Ring FIFO Start Address.(Unit: 8bytes)    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A4;                      /*!< JPEG_RING_FIFO_END_ADDR[[                                             */
    
    struct {
      __IO uint32_t  JPEG_RING_FIFO_END_ADDR: 32;   /*!< The JPEG Encoder Bit-Stream Ring FIFO End Address.(Unit:8bytes)       */
    };
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  REG_0x00AC;                      /*!< H264_IMG_CTRL_VER[[                                                   */
    
    struct {
      __IO uint32_t  H264_IMG_CTRL_VER: 32;         /*!< The Version of H264_IMG_CTRL.                                         */
    };
  };
  __I  uint32_t  RESERVED6[20];
  
  union {
    __IO uint32_t  REG_0x0100;                      /*!< PARTITION_CTRL_EN                                                     */
    
    struct {
      __IO uint32_t  PARTITION_CTRL_EN:  1;         /*!< Partition size control enable                                         */
      __IO uint32_t  MBQPCTRL_EN:  1;               /*!< MB QP adjustment enable                                               */
      __IO uint32_t  SKIN_DETECT_EN:  1;            /*!< Skin detection enable                                                 */
      __IO uint32_t  SN_CHD_DET_EN:  1;             /*!< (null)                                                                */
      __IO uint32_t  MROI_MODE_EN:  1;              /*!< Enable the MROI mode                                                  */
      __IO uint32_t  MROI_NUM_WINS:  4;             /*!< Set the maximum number of regions                                     */
      __IO uint32_t  MROI_EN    :  8;               /*!< 1: the region is usable0: the region is disabled                      */
      __IO uint32_t  MROI_HIGHBITRATE:  1;          /*!< 1: selected region bigger 70% of image0: selected region lowwer
                                                         70% of image                                                          */
      __IO uint32_t  AROI_MODE_EN:  1;              /*!< AROI enable                                                           */
      __O  uint32_t  AROI_METHOD:  2;               /*!< Auto ROI generate method0: MV||Skin; 1:only MV; 2:only Skin;
                                                         3:MV and Skin                                                         */
      __O  uint32_t  AROI_PRIORITY:  2;             /*!< ROI output method                                                     */
      __O  uint32_t  FRAME_NUM  :  1;               /*!< Frame number0: the first frame, 1: the frame after the first
                                                         frame                                                                 */
      __O  uint32_t  CONDENSEMODE_EN:  1;           /*!< MB skip function enable                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00104;                     /*!< BS_TARGE                                                              */
    
    struct {
      __IO uint32_t  BS_TARGET0 : 16;               /*!< Bitstream length target for partition 0                               */
      __IO uint32_t  BS_TARGET1 : 16;               /*!< Bitstream length target for partition 1                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00108;                     /*!< BS_TARGE                                                              */
    
    struct {
      __IO uint32_t  BS_TARGET2 : 16;               /*!< Bitstream length target for partition 2                               */
      __IO uint32_t  BS_TARGET3 : 16;               /*!< Bitstream length target for partition 3                               */
    };
  };
  __I  uint32_t  RESERVED7;
  
  union {
    __I  uint32_t  REG_0x00110;                     /*!< QP_PART                                                               */
    
    struct {
      __I  uint32_t  QP_PART0   :  6;               /*!< QP value for partition 0                                              */
      __I  uint32_t  QP_PART1   :  6;               /*!< QP value for partition 1                                              */
      __I  uint32_t  QP_PART2   :  6;               /*!< QP value for partition 2                                              */
      __I  uint32_t  QP_PART3   :  6;               /*!< QP value for partition 3                                              */
      __I  uint32_t  QP_FM      :  6;               /*!< The average of four partition QP value                                */
      __I  uint32_t  MBRC_DATA_READY_FLAG:  1;      /*!< MBRC data ready. Clear by TX_EN                                       */
    };
  };
  __I  uint32_t  RESERVED8[3];
  
  union {
    __IO uint32_t  REG_0x00120;                     /*!< PAR_QP_ADJ                                                            */
    
    struct {
      __IO uint32_t  PAR_QP_ADJ0:  4;               /*!< Partition BS adjustment multiple 0                                    */
      __IO uint32_t  PAR_QP_ADJ1:  4;               /*!< Partition BS adjustment multiple 1                                    */
      __IO uint32_t  PAR_QP_ADJ2:  4;               /*!< Partition BS adjustment multiple 2                                    */
      __IO uint32_t  PAR_QP_ADJ3:  4;               /*!< Partition BS adjustment multiple 3                                    */
      __IO uint32_t  PAR_QP_ADJ4:  4;               /*!< Partition BS adjustment multiple 4                                    */
      __IO uint32_t  PAR_QP_ADJ5:  4;               /*!< Partition BS adjustment multiple 5                                    */
      __IO uint32_t  PAR_QP_ADJ6:  4;               /*!< Partition BS adjustment multiple 6                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00124;                     /*!< PAR_QP_NUM                                                            */
    
    struct {
      __IO uint32_t  PAR_QP_NUM0:  4;               /*!< Partition QP adjustment value 0                                       */
      __IO uint32_t  PAR_QP_NUM1:  4;               /*!< Partition QP adjustment value 1                                       */
      __IO uint32_t  PAR_QP_NUM2:  4;               /*!< Partition QP adjustment value 2                                       */
      __IO uint32_t  PAR_QP_NUM3:  4;               /*!< Partition QP adjustment value 3                                       */
      __IO uint32_t  PAR_QP_NUM4:  4;               /*!< Partition QP adjustment value 4                                       */
      __IO uint32_t  PAR_QP_NUM5:  4;               /*!< Partition QP adjustment value 5                                       */
      __IO uint32_t  PAR_QP_NUM6:  4;               /*!< Partition QP adjustment value 6                                       */
      __IO uint32_t  PAR_QP_NUM7:  4;               /*!< Partition QP adjustment value 7                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00128;                     /*!< QP_MAX                                                                */
    
    struct {
      __IO uint32_t  QP_MAX     :  6;               /*!< The maximum of QP limitation                                          */
      __IO uint32_t  QP_MIN     :  6;               /*!< The minimum of QP limitation                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0012C;                     /*!< MAD_SUM                                                               */
    
    struct {
      __I  uint32_t  MAD_SUM    : 24;               /*!< The sum of MAD _TRUE                                                  */
      __IO uint32_t  MAD_AVE    :  8;               /*!< The average of MAD_AVE                                                */
    };
  };
  __I  uint32_t  RESERVED9[3];
  
  union {
    __IO uint32_t  REG_0x0013C;                     /*!< MAD_SUM                                                               */
    
    struct {
      __IO uint32_t  MB_MODE    :  2;               /*!< MB mode                                                               */
           uint32_t             :  6;
      __IO uint32_t  MB_THD     :  8;               /*!< (null)                                                                */
      __I  uint32_t  SN_CHD_DET_CNT:  8;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00140;                     /*!< MB_QP_ADJ                                                             */
    
    struct {
      __IO uint32_t  MB_QP_ADJ0 :  4;               /*!< MB_AVE adjustment multiple 0                                          */
      __IO uint32_t  MB_QP_ADJ1 :  4;               /*!< MB_AVE adjustment multiple 1                                          */
      __IO uint32_t  MB_QP_ADJ2 :  4;               /*!< MB_AVE adjustment multiple 2                                          */
      __IO uint32_t  MB_QP_ADJ3 :  4;               /*!< MB_AVE adjustment multiple 3                                          */
      __IO uint32_t  MB_QP_ADJ4 :  4;               /*!< MB_AVE adjustment multiple 4                                          */
      __IO uint32_t  MB_QP_ADJ5 :  4;               /*!< MB_AVE adjustment multiple 5                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00144;                     /*!< MB_QP_NUM                                                             */
    
    struct {
      __IO uint32_t  MB_QP_NUM0 :  4;               /*!< MB QP adjustment value 0                                              */
      __IO uint32_t  MB_QP_NUM1 :  4;               /*!< MB QP adjustment value 1                                              */
      __IO uint32_t  MB_QP_NUM2 :  4;               /*!< MB QP adjustment value 2                                              */
      __IO uint32_t  MB_QP_NUM3 :  4;               /*!< MB QP adjustment value 3                                              */
      __IO uint32_t  MB_QP_NUM4 :  4;               /*!< MB QP adjustment value 4                                              */
      __IO uint32_t  MB_QP_NUM5 :  4;               /*!< MB QP adjustment value 5                                              */
      __IO uint32_t  MB_QP_NUM6 :  4;               /*!< MB QP adjustment value 6                                              */
    };
  };
  __I  uint32_t  RESERVED10[2];
  
  union {
    __IO uint32_t  REG_0x00150;                     /*!< SKIN_QPSUB                                                            */
    
    struct {
      __IO uint32_t  SKIN_QPSUB2:  4;               /*!< Skin QP adjustment value 2                                            */
      __IO uint32_t  SKIN_QPSUB1:  4;               /*!< Skin QP adjustment value 1                                            */
      __IO uint32_t  ROI_RATIO_SKIN:  4;            /*!< Skin MB number/Total MB                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00154;                     /*!< SN_CHD_DET_ADJ                                                        */
    
    struct {
      __IO uint32_t  SN_CHD_DET_ADJ:  2;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00158;                     /*!< SN_CHD_DET_NUM                                                        */
    
    struct {
      __IO uint32_t  SN_CHD_DET_NUM:  4;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0015C;                     /*!< MROI_WEIGHTED                                                         */
    
    struct {
      __IO uint32_t  MROI_WEIGHTED0:  3;            /*!< The priority of region.0 is first priority, 7 is last priority        */
      __IO uint32_t  MROI_WEIGHTED1:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_WEIGHTED2:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_WEIGHTED3:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_WEIGHTED4:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_WEIGHTED5:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_WEIGHTED6:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_WEIGHTED7:  3;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00160;                     /*!< MROI_QP_VALUE                                                         */
    
    struct {
      __IO uint32_t  MROI_QP_VALUE0:  5;            /*!< Qp value of each region( range +9 ~ -9)                               */
      __IO uint32_t  MROI_QP_VALUE1:  5;            /*!< (null)                                                                */
      __IO uint32_t  MROI_QP_VALUE2:  5;            /*!< (null)                                                                */
      __IO uint32_t  MROI_QP_VALUE3:  5;            /*!< (null)                                                                */
      __IO uint32_t  MROI_QP_VALUE4:  5;            /*!< (null)                                                                */
      __IO uint32_t  MROI_QP_VALUE5:  5;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00164;                     /*!< MROI_QP_VALUE                                                         */
    
    struct {
      __IO uint32_t  MROI_QP_VALUE6:  5;            /*!< Qp value of each region( range +9 ~ -9)                               */
      __IO uint32_t  MROI_QP_VALUE7:  5;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00168;                     /*!< MROI_POSX                                                             */
    
    struct {
      __IO uint32_t  MROI_POSX0 :  7;               /*!< X-axis position of region (MB unit)                                   */
      __IO uint32_t  MROI_POSX1 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSX2 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSX3 :  7;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0016C;                     /*!< MROI_POSX                                                             */
    
    struct {
      __IO uint32_t  MROI_POSX4 :  7;               /*!< X-axis position of region (MB unit)                                   */
      __IO uint32_t  MROI_POSX5 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSX6 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSX7 :  7;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00170;                     /*!< MROI_POSY                                                             */
    
    struct {
      __IO uint32_t  MROI_POSY0 :  7;               /*!< Y-axis position of region (MB unit)                                   */
      __IO uint32_t  MROI_POSY1 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSY2 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSY3 :  7;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00174;                     /*!< MROI_POSY                                                             */
    
    struct {
      __IO uint32_t  MROI_POSY4 :  7;               /*!< Y-axis position of region (MB unit)                                   */
      __IO uint32_t  MROI_POSY5 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSY6 :  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_POSY7 :  7;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00178;                     /*!< MROI_WIDTH                                                            */
    
    struct {
      __IO uint32_t  MROI_WIDTH0:  7;               /*!< Width of the region (MB unit)                                         */
      __IO uint32_t  MROI_WIDTH1:  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_WIDTH2:  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_WIDTH3:  7;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0017C;                     /*!< MROI_WIDTH                                                            */
    
    struct {
      __IO uint32_t  MROI_WIDTH4:  7;               /*!< Width of the region (MB unit)                                         */
      __IO uint32_t  MROI_WIDTH5:  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_WIDTH6:  7;               /*!< (null)                                                                */
      __IO uint32_t  MROI_WIDTH7:  7;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0180;                      /*!< MROI_HEIGHT                                                           */
    
    struct {
      __IO uint32_t  MROI_HEIGHT0:  7;              /*!< Height of the region (MB unit)                                        */
      __IO uint32_t  MROI_HEIGHT1:  7;              /*!< (null)                                                                */
      __IO uint32_t  MROI_HEIGHT2:  7;              /*!< (null)                                                                */
      __IO uint32_t  MROI_HEIGHT3:  7;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0184;                      /*!< MROI_HEIGHT                                                           */
    
    struct {
      __IO uint32_t  MROI_HEIGHT4:  7;              /*!< Height of the region (MB unit)                                        */
      __IO uint32_t  MROI_HEIGHT5:  7;              /*!< (null)                                                                */
      __IO uint32_t  MROI_HEIGHT6:  7;              /*!< (null)                                                                */
      __IO uint32_t  MROI_HEIGHT7:  7;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0188;                      /*!< MROI_EXT_SIZE                                                         */
    
    struct {
      __IO uint32_t  MROI_EXT_SIZE0:  3;            /*!< Extension size, can be 0, 3, and 7                                    */
      __IO uint32_t  MROI_EXT_SIZE1:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_EXT_SIZE2:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_EXT_SIZE3:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_EXT_SIZE4:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_EXT_SIZE5:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_EXT_SIZE6:  3;            /*!< (null)                                                                */
      __IO uint32_t  MROI_EXT_SIZE7:  3;            /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x018C;                      /*!< MB_MV_CNT                                                             */
    
    struct {
      __I  uint32_t  MB_MV_CNT  : 14;               /*!< MB motion vector count each frame                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0190;                      /*!< BS_PART0                                                              */
    
    struct {
      __I  uint32_t  BS_PART0   : 14;               /*!< Actual bitstream length for partition 0                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0194;                      /*!< BS_PART1                                                              */
    
    struct {
      __I  uint32_t  BS_PART1   : 14;               /*!< Actual bitstream length for partition 1                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0198;                      /*!< BS_PART2                                                              */
    
    struct {
      __I  uint32_t  BS_PART2   : 14;               /*!< Actual bitstream length for partition 2                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x019C;                      /*!< BS_PART3                                                              */
    
    struct {
      __I  uint32_t  BS_PART3   : 14;               /*!< Actual bitstream length for partition 3                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01A0;                      /*!< SKIN_DET                                                              */
    
    struct {
      __IO uint32_t  SKIN_DET_CBL:  8;              /*!< Cb's low bound                                                        */
      __IO uint32_t  SKIN_DET_CBU:  8;              /*!< Cb's upper bound                                                      */
      __IO uint32_t  SKIN_DET_CRL:  8;              /*!< CR's low bound                                                        */
      __IO uint32_t  SKIN_DET_CRU:  8;              /*!< CR's upper bound                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01A4;                      /*!< SKIN_DET_F                                                            */
    
    struct {
      __IO uint32_t  SKIN_DET_FL:  8;               /*!< Formula's low bound                                                   */
      __IO uint32_t  SKIN_DET_FU:  8;               /*!< Formula's upper bound                                                 */
      __IO uint32_t  SKIN_DET_FP:  8;               /*!< Formula's parameter                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01A8;                      /*!< AROI_BASE_START_ADDR                                                  */
    
    struct {
      __IO uint32_t  AROI_BASE_START_ADDR: 11;      /*!< AROI base start address, the total size is 4Kbype.(unit: 2 byptes)    */
           uint32_t             :  5;
      __IO uint32_t  MV_AVE_X   :  8;               /*!< Average Motion Vector x                                               */
      __IO uint32_t  MV_AVE_Y   :  8;               /*!< Average Motion Vector y                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01AC;                      /*!< AROI_QP_NUM                                                           */
    
    struct {
      __IO uint32_t  AROI_QP_NUM0:  4;              /*!< AROI MBQP offset0                                                     */
      __IO uint32_t  AROI_QP_NUM1:  4;              /*!< AROI MBQP offset1                                                     */
      __IO uint32_t  AROI_QP_NUM2:  4;              /*!< AROI MBQP offset2                                                     */
      __IO uint32_t  AROI_QP_NUM3:  4;              /*!< AROI MBQP offset3                                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01B0;                      /*!< BS_FM_TARGET                                                          */
    
    struct {
      __IO uint32_t  BS_FM_TARGET: 32;              /*!< Frame bitstream length target                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01B4;                      /*!< ROI_SKIN_NUM                                                          */
    
    struct {
      __I  uint32_t  ROI_SKIN_NUM: 13;              /*!< Have skin tone MB number in the frame                                 */
           uint32_t             :  3;
      __I  uint32_t  ROI_MV_NUM : 13;               /*!< Have motion MB number in the frame                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01B8;                      /*!< ROI_MIX_NUM                                                           */
    
    struct {
      __I  uint32_t  ROI_MIX_NUM: 13;               /*!< Have motion and skin tone MB number in the frame                      */
           uint32_t             :  3;
      __I  uint32_t  ROI_NUM    : 13;               /*!< ROI MB number in the frame                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01BC;                      /*!< I_ROI_MIX_NUM                                                         */
    
    struct {
      __I  uint32_t  I_ROI_MVX_NUM: 13;             /*!< Have X direction MV MB bunber in the frame                            */
           uint32_t             :  3;
      __I  uint32_t  I_ROI_MVY_NUM: 13;             /*!< Have Y direction MV MB bunber in the frame                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01C0;                      /*!< I_ROI_MVX_SUM                                                         */
    
    struct {
      __I  uint32_t  I_ROI_MVX_SUM: 18;             /*!< The sum of the MV on X direction MB number in the frame               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01C4;                      /*!< I_ROI_MVY_SUM                                                         */
    
    struct {
      __I  uint32_t  I_ROI_MVY_SUM: 18;             /*!< The sum of the MV on X direction MB number in the frame               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01C8;                      /*!< AROI_DEC_PAR                                                          */
    
    struct {
      __IO uint32_t  AROI_DEC_PAR0:  3;             /*!< (null)                                                                */
      __IO uint32_t  AROI_DEC_PAR1:  3;             /*!< (null)                                                                */
      __IO uint32_t  AROI_DEC_PAR2:  3;             /*!< (null)                                                                */
      __IO uint32_t  AROI_DELAY_OFF:  1;            /*!< (null)                                                                */
      __IO uint32_t  CONDENSEDMODE_SR:  3;          /*!< (null)                                                                */
    };
  };
} IMG_Type;


/* ================================================================================ */
/* ================                      H264                      ================ */
/* ================================================================================ */


/**
  * @brief H264 Control (H264)
  */

typedef struct {                                    /*!< H264 Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< Reserved for AXI Write Channel, Bit 4-0.                              */
    
    struct {
      __IO uint32_t  AWID       :  4;               /*!< A 4-bit value for AWID setting of AXI master, i.e H.264 codec
                                                         write transactions                                                    */
           uint32_t             : 26;
      __IO uint32_t  AWID_DECERR:  1;               /*!< DECERR occurred during the write transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
      __IO uint32_t  AWID_SLVERR:  1;               /*!< SLVERR occurred during the write transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< Reserved for AXI Read Channel, Bit 4-0.                               */
    
    struct {
      __IO uint32_t  ARID       :  4;               /*!< A 4-bit value for ARID setting of AXI master, i.e., H.264 codec
                                                         read transactions                                                     */
           uint32_t             : 26;
      __IO uint32_t  ARID_DECERR:  1;               /*!< DECERR occurred during the read transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
      __IO uint32_t  ARID_SLVERR:  1;               /*!< SLVERR occurred during the read transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< Interrupt Mask Register                                               */
    
    struct {
      __IO uint32_t  INT_MASK   :  1;               /*!< Encoder complete interrupt enable1: active                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< Interrupt Status Indicator                                            */
    
    struct {
      __IO uint32_t  INT_STATUS :  1;               /*!< Encoder complete interrupt1: active                                   */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< H.264 Control Register (Frame based)                                  */
    
    struct {
      __IO uint32_t  TRIG_COMPRESSION:  1;          /*!< Trigger compression (triggered by host, and cleared by H/W)
                                                         To set this bit to start compressing, and clear it by H/W frame
                                                          by frame, 1:active                                                   */
      __IO uint32_t  Bit_1      :  1;               /*!< This bit must be 1'b0 in encoding mode.                               */
           uint32_t             :  1;
      __IO uint32_t  AVS_enable_flag:  1;           /*!< AVS enable flag. This bit must be 1'b0 in AVC encoding mode.
                                                         0, AVC/H.264 format 1, AVS format                                     */
      __IO uint32_t  ENCODER_RESET:  1;             /*!< Encoder Engine Reset Bit (Refer to Reset Flow of H.264/AVC Codec)
                                                         1: active                                                             */
    };
  };
  __I  uint32_t  RESERVED1;
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< Frame Data Size Register                                              */
    
    struct {
      __IO uint32_t  Frame_Height: 12;              /*!< Valid number is 16*N, where N is within [4, 68]                       */
           uint32_t             :  4;
      __IO uint32_t  Frame_Width: 12;               /*!< Valid number is 16*M, where M is within [4, 120]                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< Picture Type Register                                                 */
    
    struct {
      __IO uint32_t  Picture_Type:  1;              /*!< 0, Inter/P frame1, Intra/I frame                                      */
      __IO uint32_t  Non_reference_frame_flag:  1;  /*!< Non-reference frame flag0, reference frame1, non-reference frame      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< Frame QP value                                                        */
    
    struct {
      __IO uint32_t  QP         :  6;               /*!< Frame QP valueValid number is N, N=[0:51]                             */
           uint32_t             : 10;
      __IO uint32_t  chroma_qp_index_offst:  5;     /*!< chorma_qp_index_offset and second_chroma_qp_index_offset are
                                                         available only when value of Profile (0x30 bit23-bit16) is 0x100.
                                                          There are three use cases described belowchroma_qp_index_offset
                                                          = second_chroma_qp_offset = 0x0, both index are not encoded.chroma_qp_inde
                                                         x_offset = second_chroma_qp_offset != 0x0, only chroma_qp_index_offset
                                                          is encoded.chroma_qp_index_offset != second_chroma_qp_offset,
                                                          both index are encoded.                                              */
      __IO uint32_t  second_chroma_qp_index_offset:  5;/*!< see details in 0x24 Bit 20-16.                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< POC_Num                                                               */
    
    struct {
      __IO uint32_t  PPS_Enable :  1;               /*!< PPS enable, 1 is active                                               */
      __IO uint32_t  SPS_Enable :  1;               /*!< SPS enable, 1 is active                                               */
      __IO uint32_t  IDR_Flag   :  1;               /*!< 0, Current frame is not IDR. No SPS/PPS header is included.[NOTE]
                                                         User must encode the first frame to be IDR I-framein order to
                                                          be compliant with H.264 spec.1, Current frame is IDR, SPS/PPS
                                                          header MAY be included.[NOTE] User should set bit IDR Flag =
                                                          1 with register 0x20 Picture Type Register = 0x1                     */
      __IO uint32_t  Symbol_Mode_Flag:  1;          /*!< "0": Set CAVLC as Entropy Coding Engine."1": Set CABAC as Entropy
                                                         Coding Engine.                                                        */
      __IO uint32_t  FMC_Flag   :  1;               /*!< "0": Disable FMC function."1": Enable FMC function; Each dataflow
                                                         through DMA interface will be compressed/decompressed by FMC
                                                          module.                                                              */
      __IO uint32_t  FMC_Chroma_Only:  1;           /*!< 0, The FMC compresses both the Luma and Chroma information,
                                                         when FMC flag is TRUE.1, The FMC compresses Chroma information
                                                          only, when FMC flag is TRUE.                                         */
      __IO uint32_t  Constrained_Intra_Pred:  1;    /*!< 0, Disable constrained intra prediction.1, Enable constrained
                                                         intra prediction. This function can be used to reduce the possibility
                                                          of visual defects caused by FMC, however the encoded bit rate
                                                          will be increased.                                                   */
      __IO uint32_t  LastFrame  :  1;               /*!< 0, The value of this register is always "0" in h.264 mode.            */
      __IO uint32_t  DefaultScalingMatrix:  1;      /*!< 0, Disable default scaling matrix.1, Enable default scaling
                                                         matrix.                                                               */
           uint32_t             :  1;
      __IO uint32_t  PoCType    :  2;               /*!< The value of pic_order_cnt_type. The value is limited to 2'b00
                                                         or 2'b10.                                                             */
      __IO uint32_t  ChannelID  :  4;               /*!< The value of the channel ID used in multiple-slice SEI, ranged
                                                         from 0 to 15                                                          */
      __IO uint32_t  FrameNum_IDR_PIC_ID:  8;       /*!< In IDR condition (both "Picture_Type(0x20)" and "IDR(0x28, Bit
                                                         2)" be set to "1"), this identifier is idr_pic_id.Valid number
                                                          is N, N=[0:1]In non-IDR condition, an identifier for pictures
                                                          and shall be limited by "log2_max_frame_num_minus4".Valid number
                                                          is N, N=[0:255]                                                      */
      __IO uint32_t  POC_Num_Picture_Distance:  8;  /*!< OC number in AVC modePicture_distance in AVS modeValid number
                                                         is N, N=[0:255]                                                       */
    };
  };
  
  union {
    __I  uint32_t  REG_0x002C;                      /*!< H.264 Codec IP Version                                                */
    
    struct {
      __I  uint32_t  Definition : 16;               /*!< Configuration value of h264_define.v                                  */
      __I  uint32_t  Version    :  3;               /*!< Version                                                               */
      __I  uint32_t  Day        :  5;               /*!< Day                                                                   */
      __I  uint32_t  Month      :  4;               /*!< Month                                                                 */
      __I  uint32_t  Year       :  4;               /*!< Year                                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< Profile/Level Information                                             */
    
    struct {
      __IO uint32_t  Level_information:  8;         /*!< Level information"31", level 3.1, default value."21", level
                                                         2.1                                                                   */
           uint32_t             :  4;
      __IO uint32_t  Constraint_Set_Flag:  4;       /*!< Constraint_Set0_Flag ~ Constraint_Set3_Flag4'b0100: Constrained
                                                         Baseline Profile, default value.                                      */
      __IO uint32_t  Profile_information:  8;       /*!< Profile information66, Baseline profile, default value.77, Main-profile
                                                         88, Extend-profile100, High profile                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< Bitstream Starting Address Register                                   */
    
    struct {
      __IO uint32_t  Bitstream_Starting_Address: 32;/*!< The bits 1-0 in this address must be 2'b00 for 32-bit bus; the
                                                         bits 2-0 must be 3'b000 for 64-bit bus.                               */
    };
  };
  __I  uint32_t  RESERVED2[2];
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< Raw Frame Starting Address Register                                   */
    
    struct {
      __IO uint32_t  Raw_Frame_Starting_Address_Register: 32;/*!< The bits 1-0 in this address must be 2'b00 for 32-bit bus; the
                                                         bits 2-0 must be 3'b000 for 64-bit bus.                               */
    };
  };
  __I  uint32_t  RESERVED3[2];
  
  union {
    __IO uint32_t  REG_0x004C;                      /*!< AR Table Starting Address                                             */
    
    struct {
      __IO uint32_t  AR_Table_Starting_Address: 32; /*!< When AR_EN (0x94 bit 31) is TRUE. A consecutive memory of 384
                                                         bytes is required for adaptive rounding function, and this register
                                                          is used to specify the starting address. The initial values
                                                          of this memory are given by software.                                */
    };
  };
  __I  uint32_t  RESERVED4[4];
  
  union {
    __IO uint32_t  REG_0x0060;                      /*!< Rec/Ref Frame Base Address Register for Luma                          */
    
    struct {
      __IO uint32_t  Rec_Ref_Frame_Base_Address_Register_for_Luma: 32;/*!< Bit 31-0:The bits 1-0 in this address must be 2'b00 for 32-bit
                                                         bus; the bits 2-0 must be 3'b000 for 64-bit bus                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0064;                      /*!< Rec/Ref Frame Base Address Register for Chroma                        */
    
    struct {
      __IO uint32_t  Rec_Ref_Frame_Base_Address_Register_for_Chroma: 32;/*!< Bit 31-0:The bits 1-0 in this address must be 2'b00 for 32-bit
                                                         bus; the bits 2-0 must be 3'b000 for 64-bit bus                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0068;                      /*!< Reconstructed Frame MB Y-axis Offset Register                         */
    
    struct {
      __IO uint32_t  Reconstructed_Frame_MB_Yaxis_Offset_Register:  9;/*!< Reconstructed Frame MB Y-axis Offset Register       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x006C;                      /*!< Reference Frame MB Y-axis Offset Register                             */
    
    struct {
      __IO uint32_t  Reference_Frame_MB_Yaxis_Offset_Register:  9;/*!< Reference Frame MB Y-axis Offset Register               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0070;                      /*!< Rec/Ref Frame Maximum MB Y-axis Offset Register                       */
    
    struct {
      __IO uint32_t  Rec_Ref_Frame_Maximum_MB_Yaxis_Offset_Register:  9;/*!< Rec/Ref Frame Maximum MB Y-axis Offset Register   */
    };
  };
  __I  uint32_t  RESERVED5[7];
  
  union {
    __IO uint32_t  REG_0x0090;                      /*!< Dynamic Search Window Size Register                                   */
    
    struct {
      __IO uint32_t  Dynamic_Search_Range_Y:  8;    /*!< Dynamic Search Range Y (DSRY), ranged from 8 to 16.Ex1: DSRY
                                                         = 8, vertical search range is between -8 and +7 Smaller search
                                                          range can shorten IME's processing time, but the prediction
                                                          effect is lower.Ex2: DSRY = 16, vertical search range is between
                                                          -16 and +15 Larger search range will extend IME's processing
                                                          time, but the prediction effect is better.                           */
      __IO uint32_t  Dynamic_Search_Range_X:  8;    /*!< Dynamic Search Range X (DSRX), ranged from 1 to 32.Ex1: DSRX
                                                         = 2, horizontal search range is between -2 and +1 Smaller search
                                                          range can shorten IME's processing time, but the prediction
                                                          effect is lower.Ex2: DSRX = 32, horizontal search range is between
                                                          -32 and +31 Larger search range will extend IME's processing
                                                          time, but the prediction effect is better.                           */
      __IO uint32_t  ThrForScnChgDetection:  8;     /*!< threshold value for scene change detection, ranged from 0 to
                                                         255.                                                                  */
      __IO uint32_t  ForceIntraAsScnChg:  1;        /*!< Force rest MBs in P frame intra mode as scene change detected.        */
      __IO uint32_t  I16CostTweak:  1;              /*!< Change the I16 cost function.                                         */
      __IO uint32_t  NewQP2QuantTable:  1;          /*!< Change the QP2Quant table for different cost function.                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0094;                      /*!< Function Control                                                      */
    
    struct {
      __IO uint32_t  Disable_DB :  1;               /*!< Disable DB0, inactive;1, active.                                      */
      __IO uint32_t  Advanced_MVP_prediction:  1;   /*!< Enable advanced MVP prediction function for DSW.0: inactive;
                                                         1: active.                                                            */
      __IO uint32_t  Forbid_Pframe_Intra_prediction:  1;/*!< Forbid P-frame use Intra-prediction 0: inactive; 1: active.       */
      __IO uint32_t  Disable_INTRA_I4:  1;          /*!< Disable INTRA blk_4x4 Intra-predictionDisable_INTRA_I4 and Disable_INTRA_I
                                                         16 cannot be "1" simultaneously.0: inactive; 1: active.               */
      __IO uint32_t  Disable_INTRA_I16:  1;         /*!< Disable INTRA blk_16x16 Intra-predictionDisable_INTRA_I16 and
                                                         Disable_INTRA_I4 cannot be "1" simultaneously.0: inactive; 1:
                                                          active.                                                              */
      __IO uint32_t  Enable_Fast_FME:  1;           /*!< Enable Fast FME, sub-partition modes (8x4, 4x8, 4x4) will not
                                                         be supported.0: inactive; 1: active.                                  */
      __IO uint32_t  EnableMSliceInfoSEI:  1;       /*!< Enable the function of generating an SEI which reports the byte-length
                                                         of each NAL unit.                                                     */
           uint32_t             :  1;
      __IO uint32_t  SliceHeightMB:  8;             /*!< Define the number of MB rows to construct a slice. This register
                                                         can be frame-by-frame changed, when value 0x00 is given, encoder
                                                          treat a frame as a slice. (0: default). When value 0xFF is given,
                                                          the size of a slice self-determining according the given bitstream
                                                          byte number of a slice. The byte number is currently set by
                                                          EC_AUTO_SLICE_CNT define.                                            */
      __IO uint32_t  I4mode_Num_P:  4;              /*!< Define the number of Intra4x4-prediction-modes to be processed
                                                         in each MB of P-frame. (9: default)                                   */
      __IO uint32_t  I4mode_Num_I:  4;              /*!< Define the number of Intra4x4-prediction-modes to be processed
                                                         in each MB of I-frame. (9: default)                                   */
      __IO uint32_t  FastFME_Mode:  2;              /*!< define FME's acceleration mode, this option is ONLY active whileEnable_Fas
                                                         t_FME Register be set to '1'.0: best quality. (default)1: normal.2:
                                                         fastest speed.                                                        */
      __IO uint32_t  AR_SAVE    :  1;               /*!< Save the updating table for adaptive rounding to the memory
                                                         specified by 0x4C.                                                    */
      __IO uint32_t  AR_LOAD    :  1;               /*!< Load the table for adaptive rounding from the memory specified
                                                         by 0x4C.                                                              */
      __IO uint32_t  MB_QP_Generator:  1;           /*!< Enable MB_QP generator.0: inactive; 1: active.                        */
      __IO uint32_t  MB_SKIP_EN :  1;               /*!< Can be active in I frames or P frames. MB_SKIP_EN is a mask
                                                         signal. When active, this H.264/AVS IP allows that the rate
                                                          control module can force all residuals and MVDs to be zero in
                                                          an MB-by-MB control. When inactive, this H.264/AVS IP will disable
                                                          the ability described above for rate control module.0, inactive;1,
                                                          active.                                                              */
      __IO uint32_t  FRAME_SKIP :  1;               /*!< Only can be active when the nal_ref_idc is equal 0, i.e., register
                                                         0x20 [1:0] is 2'b10. When FRAM_SKIP is enabled, each MB in that
                                                          frame is forced in P-skip mode and to have zero residual.0,
                                                          inactive;1, active.                                                  */
      __IO uint32_t  AR_EN      :  1;               /*!< Enable the adaptive rounding function. The related registers
                                                         are 0x94 bit 27~26 and 0x4C.0, inactive,1, active.                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0098;                      /*!< Bitstream Length                                                      */
    
    struct {
      __IO uint32_t  Bitstream_Length_Register: 32; /*!< Bit 31-0: current frame encoded bitstream length, in BYTE unit.This
                                                         registers always returns a total length of bitstream outputted
                                                          by this design. When EnableMSliceInfoSEI ( bit-6 of Register
                                                          0x94 ) is set, the total length also counts the length of MSlice
                                                          Info SEI; when the EnableMSliceInfoSEI is clear, the total length
                                                          only counts the video bitstream.                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x009C;                      /*!< Status Register 1                                                     */
    
    struct {
      __IO uint32_t  Status_Register_1: 32;         /*!< Bit 31-0: Frame_cycle_counter , encoder feedback message.             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A0;                      /*!< Status Register 2                                                     */
    
    struct {
      __IO uint32_t  Status_Register_2: 32;         /*!< Bit 31-0: System_cycle_count, encoder feedback message.               */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00A4;                      /*!< Global Debug Register 0                                               */
    
    struct {
      __I  uint32_t  db_end     :  1;               /*!< db_end                                                                */
      __I  uint32_t  db_start   :  1;               /*!< db_start                                                              */
      __I  uint32_t  ec_end     :  1;               /*!< ec_end                                                                */
      __I  uint32_t  ec_start   :  1;               /*!< ec_start                                                              */
      __I  uint32_t  intra_end  :  1;               /*!< intra_end                                                             */
      __I  uint32_t  intra_start:  1;               /*!< intra_start                                                           */
      __I  uint32_t  fme_end    :  1;               /*!< fme_end                                                               */
      __I  uint32_t  fme_start  :  1;               /*!< fme_start                                                             */
      __I  uint32_t  ime_end    :  1;               /*!< ime_end                                                               */
      __I  uint32_t  ime_start  :  1;               /*!< ime_start                                                             */
      __I  uint32_t  frame_end  :  1;               /*!< frame_end                                                             */
      __I  uint32_t  frame_start:  1;               /*!< frame_start                                                           */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00A8;                      /*!< Global Debug Register 1                                               */
    
    struct {
      __I  uint32_t  record_the_row_of_the_MBY_under_processing:  7;/*!< record the row of the MB (MBY) under processing       */
      __I  uint32_t  record_the_column_of_the_MBX_under_processing:  7;/*!< record the column of the MB (MBX) under processing */
      __I  uint32_t  PreFetch_Y_Done:  4;           /*!< Pre-Fetch_Y_Done                                                      */
    };
  };
  __I  uint32_t  RESERVED6;
  
  union {
    __IO uint32_t  REG_0x00B0;                      /*!< Frame_Crop_Offset_Syntax                                              */
    
    struct {
      __IO uint32_t  frame_crop_bottom_offset:  7;  /*!< frame_crop_bottom_offset, 7 valid bits for SPS header generation.     */
           uint32_t             :  1;
      __IO uint32_t  frame_crop_top_offset:  7;     /*!< frame_crop_top_offset, 7 valid bits for SPS header generation.        */
           uint32_t             :  1;
      __IO uint32_t  frame_crop_right_offset:  7;   /*!< frame_crop_right_offset, 7 valid bits for SPS header generation.      */
           uint32_t             :  1;
      __IO uint32_t  frame_crop_left_offset:  7;    /*!< frame_crop_left_offset, 7 valid bits for SPS header generation.       */
    };
  };
  __I  uint32_t  RESERVED7;
  
  union {
    __I  uint32_t  REG_0x00B8;                      /*!< Bitstream Length without SEI Register                                 */
    
    struct {
      __I  uint32_t  Bitstream_Length_without_SEI_Register: 32;/*!< The bitstream byte-length of an encoding frame. When EnableMSliceInfoSEI
                                                         ( bit-6 of Register 0x94 ) is clear, this register returns a
                                                          value the same as Register 0x98. When EnableMSliceInfoSEI is
                                                          set, this register returns the length of video bitstream only,
                                                          not include the MSlice Info SEI.                                     */
    };
  };
  __I  uint32_t  RESERVED8[5];
  __I  uint32_t  REG_0x00D0;                        /*!< Reserved.(IME Debug Register)                                         */
  __I  uint32_t  REG_0x00D4;                        /*!< Reserved. (FME Debug Register)                                        */
  __I  uint32_t  REG_0x00D8;                        /*!< Reserved. (INTRA Debug Register)                                      */
  __I  uint32_t  REG_0x00DC;                        /*!< Reserved. (EC Debug Register)                                         */
  __I  uint32_t  REG_0x00E0;                        /*!< Reserved. (DB Debug Register)                                         */
  
  union {
    __I  uint32_t  REG_0x00E4;                      /*!< Configuration value of h264_define_dev.v                              */
    
    struct {
      __I  uint32_t  Configuration_Value: 32;       /*!< Configuration value of h264_define_dev.v                              */
    };
  };
} H264_Type;


/* ================================================================================ */
/* ================                    H264_Dec                    ================ */
/* ================================================================================ */


/**
  * @brief H264_Dec Control (H264_Dec)
  */

typedef struct {                                    /*!< H264_Dec Structure                                                    */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< Reserved for AXI Write Channel, Bit 4-0.                              */
    
    struct {
      __IO uint32_t  AWID       :  4;               /*!< A 4-bit value for AWID setting of AXI master, i.e H.264 codec
                                                         write transactions                                                    */
           uint32_t             : 26;
      __IO uint32_t  AWID_DECERR:  1;               /*!< DECERR occurred during the write transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
      __IO uint32_t  AWID_SLVERR:  1;               /*!< SLVERR occurred during the write transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< Reserved for AXI Read Channel, Bit 4-0.                               */
    
    struct {
      __IO uint32_t  ARID       :  4;               /*!< A 4-bit value for ARID setting of AXI master, i.e., H.264 codec
                                                         read transactions                                                     */
           uint32_t             : 26;
      __IO uint32_t  ARID_DECERR:  1;               /*!< DECERR occurred during the read transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
      __IO uint32_t  ARID_SLVERR:  1;               /*!< SLVERR occurred during the read transactions of AXI master.
                                                         This bit cleared by reset or by host                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< Interrupt Mask Register                                               */
    
    struct {
      __IO uint32_t  INT_MASK   :  1;               /*!< Decoder complete interrupt enable1: active                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< Interrupt Status Indicator                                            */
    
    struct {
      __IO uint32_t  INT_STATUS :  1;               /*!< Decoder complete interrupt1: active                                   */
    };
  };
  __I  uint32_t  RESERVED;
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< H.264 Control Register (Frame based)                                  */
    
    struct {
      __IO uint32_t  Bit_0      :  1;               /*!< This bit must be 1b0 in decoding mode.                                */
      __IO uint32_t  Trigger_Decompression:  1;     /*!< Trigger decompression (triggered by host, and cleared by H/W).
                                                         To set this bit to start decompressing, and clear it by H/W
                                                          frame by frame, 1:active                                             */
           uint32_t             :  1;
      __IO uint32_t  AVS_enable_flag:  1;           /*!< AVS enable flag. This bit must be 1b1 in AVC decoding mode.0,
                                                         AVC/H.264 format;1, AVS format                                        */
      __IO uint32_t  ENCODER_RESET:  1;             /*!< Encoder Engine Reset Bit (Refer to Reset Flow of H.264/AVC Codec)
                                                         1: active                                                             */
    };
  };
  __I  uint32_t  RESERVED1;
  
  union {
    __IO uint32_t  REG_0x001C;                      /*!< Frame Data Size Register                                              */
    
    struct {
      __IO uint32_t  Frame_Height: 12;              /*!< Valid number is 16*N, where N is within [4, 68]                       */
           uint32_t             :  4;
      __IO uint32_t  Frame_Width: 12;               /*!< Valid number is 16*M, where M is within [4, 120]                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< Picture Type Register                                                 */
    
    struct {
      __IO uint32_t  Picture_Type:  1;              /*!< 0, Inter/P frame1, Intra/I frame                                      */
      __IO uint32_t  Non_reference_frame_flag:  1;  /*!< Non-reference frame flag0, reference frame1, non-reference frame      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< Frame QP value                                                        */
    
    struct {
      __IO uint32_t  QP         :  6;               /*!< Frame QP value                                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< POC_Num                                                               */
    
    struct {
           uint32_t             :  2;
      __I  uint32_t  IDR_Flag   :  1;               /*!< 0, non-IDR frame1, IDR frame.                                         */
      __IO uint32_t  Symbol_Mode_Flag:  1;          /*!< "0": Set CAVLC as Entropy Coding Engine."1": Set CABAC as Entropy
                                                         Coding Engine.                                                        */
      __IO uint32_t  FMC_Flag   :  1;               /*!< "0": Disable FMC function."1": Enable FMC function; Each dataflow
                                                         through DMA interface will be compressed/decompressed by FMC
                                                          module.                                                              */
           uint32_t             : 11;
      __IO uint32_t  FrameNum   :  8;               /*!< Frame number                                                          */
      __IO uint32_t  POC_Num    :  8;               /*!< POC number                                                            */
    };
  };
  
  union {
    __I  uint32_t  REG_0x002C;                      /*!< H.264 Codec IP Version                                                */
    
    struct {
      __I  uint32_t  Definition : 16;               /*!< Configuration value of h264_define.v                                  */
      __I  uint32_t  Version    :  3;               /*!< Version                                                               */
      __I  uint32_t  Day        :  5;               /*!< Day                                                                   */
      __I  uint32_t  Month      :  4;               /*!< Month                                                                 */
      __I  uint32_t  Year       :  4;               /*!< Year                                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< Profile/Level Information                                             */
    
    struct {
      __IO uint32_t  Level_information:  8;         /*!< Level information"31", level 3.1, default value."21", level
                                                         2.1                                                                   */
           uint32_t             :  4;
      __IO uint32_t  Constraint_Set_Flag:  4;       /*!< Constraint_Set0_Flag ~ Constraint_Set3_Flag4'b0100: Constrained
                                                         Baseline Profile, default value.                                      */
      __IO uint32_t  Profile_information:  8;       /*!< Profile information66, Baseline profile, default value.77, Main-profile
                                                         88, Extend-profile100, High profile                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< Bitstream Starting Address Register                                   */
    
    struct {
      __IO uint32_t  Bitstream_Starting_Address: 32;/*!< The bits 2-0 in this address must be 0                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0038;                      /*!< Bitstream Base Address Register                                       */
    
    struct {
      __IO uint32_t  Bitstream_Base_Address: 32;    /*!< The bits 5-0 in this address must be 0                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x003C;                      /*!< Bitstream Max Address Register                                        */
    
    struct {
      __IO uint32_t  Bitstream_Max_Address: 32;     /*!< The bits 5-0 in this address must be 0                                */
    };
  };
  __I  uint32_t  RESERVED2[8];
  
  union {
    __IO uint32_t  REG_0x0060;                      /*!< Rec/Ref Frame Base Address Register for Luma                          */
    
    struct {
      __IO uint32_t  Rec_Ref_Frame_Base_Address_Register_for_Luma: 32;/*!< Bit 31-0:The bits 1-0 in this address must be 2'b00 for 32-bit
                                                         bus; the bits 2-0 must be 3'b000 for 64-bit bus                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0064;                      /*!< Rec/Ref Frame Base Address Register for Chroma                        */
    
    struct {
      __IO uint32_t  Rec_Ref_Frame_Base_Address_Register_for_Chroma: 32;/*!< Bit 31-0:The bits 1-0 in this address must be 2'b00 for 32-bit
                                                         bus; the bits 2-0 must be 3'b000 for 64-bit bus                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0068;                      /*!< Reconstructed Frame MB Y-axis Offset Register                         */
    
    struct {
      __IO uint32_t  Reconstructed_Frame_MB_Yaxis_Offset_Register:  9;/*!< Reconstructed Frame MB Y-axis Offset Register       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x006C;                      /*!< Reference Frame MB Y-axis Offset Register                             */
    
    struct {
      __IO uint32_t  Reference_Frame_MB_Yaxis_Offset_Register:  9;/*!< Reference Frame MB Y-axis Offset Register               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0070;                      /*!< Rec/Ref Frame Maximum MB Y-axis Offset Register                       */
    
    struct {
      __IO uint32_t  Rec_Ref_Frame_Maximum_MB_Yaxis_Offset_Register:  9;/*!< Rec/Ref Frame Maximum MB Y-axis Offset Register   */
    };
  };
  __I  uint32_t  RESERVED3[8];
  
  union {
    __IO uint32_t  REG_0x0094;                      /*!< Function Control                                                      */
    
    struct {
      __IO uint32_t  Disable_DB :  1;               /*!< Disable DB0, inactive;1, active.                                      */
           uint32_t             :  6;
      __IO uint32_t  Disable_UP_DB:  1;             /*!< Disable Upper DB0, inactive;1, active.                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0098;                      /*!< Bitstream Length                                                      */
    
    struct {
      __I  uint32_t  Bitstream_Length_Register: 32; /*!< current frame decoded bitstream length, in BYTE unit                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x009C;                      /*!< Status Register 1                                                     */
    
    struct {
      __I  uint32_t  Status_Register_1: 32;         /*!< Bit 31-0: Frame_cycle_counter ,decoder feedback message.              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A0;                      /*!< Status Register 2                                                     */
    
    struct {
      __I  uint32_t  Status_Register_2: 32;         /*!< Bit 31-0: System_cycle_count, decoder feedback message.               */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00A4;                      /*!< Global Debug Register 0                                               */
    
    struct {
      __I  uint32_t  db_end     :  1;               /*!< db_end                                                                */
      __I  uint32_t  db_start   :  1;               /*!< db_start                                                              */
      __I  uint32_t  ec_end     :  1;               /*!< ec_end                                                                */
      __I  uint32_t  ec_start   :  1;               /*!< ec_start                                                              */
      __I  uint32_t  intra_end  :  1;               /*!< intra_end                                                             */
      __I  uint32_t  intra_start:  1;               /*!< intra_start                                                           */
      __I  uint32_t  fme_end    :  1;               /*!< fme_end                                                               */
      __I  uint32_t  fme_start  :  1;               /*!< fme_start                                                             */
      __I  uint32_t  ime_end    :  1;               /*!< ime_end                                                               */
      __I  uint32_t  ime_start  :  1;               /*!< ime_start                                                             */
      __I  uint32_t  frame_end  :  1;               /*!< frame_end                                                             */
      __I  uint32_t  frame_start:  1;               /*!< frame_start                                                           */
      __I  uint32_t  cavld_end  :  1;               /*!< cavld_end                                                             */
      __I  uint32_t  cavld_start:  1;               /*!< cavld_start                                                           */
      __I  uint32_t  parser_end :  1;               /*!< parser_end                                                            */
      __I  uint32_t  parser_start:  1;              /*!< parser_start                                                          */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00A8;                      /*!< Global Debug Register 1                                               */
    
    struct {
      __I  uint32_t  record_the_row_of_the_MBY_under_processing:  7;/*!< record the row of the MB (MBY) under processing       */
      __I  uint32_t  record_the_column_of_the_MBX_under_processing:  7;/*!< record the column of the MB (MBX) under processing */
      __I  uint32_t  PreFetch_Y_Done:  4;           /*!< Pre-Fetch_Y_Done                                                      */
    };
  };
  __I  uint32_t  RESERVED4;
  
  union {
    __IO uint32_t  REG_0x00B0;                      /*!< Frame_Crop_Offset_Syntax                                              */
    
    struct {
      __IO uint32_t  frame_crop_bottom_offset:  7;  /*!< frame_crop_bottom_offset, 7 valid bits for SPS header generation.     */
           uint32_t             :  1;
      __IO uint32_t  frame_crop_top_offset:  7;     /*!< frame_crop_top_offset, 7 valid bits for SPS header generation.        */
           uint32_t             :  1;
      __IO uint32_t  frame_crop_right_offset:  7;   /*!< frame_crop_right_offset, 7 valid bits for SPS header generation.      */
           uint32_t             :  1;
      __IO uint32_t  frame_crop_left_offset:  7;    /*!< frame_crop_left_offset, 7 valid bits for SPS header generation.       */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00B4;                      /*!< Bitstream Bypassed Length Register                                    */
    
    struct {
      __I  uint32_t  Bitstream_Bypassed_Length_Register: 32;/*!< current frame bypassed bitstream length, in BYTE unit.        */
    };
  };
  
  union {
    __I  uint32_t  REG_0x00B8;                      /*!< Bitstream Length without SEI Register                                 */
    
    struct {
      __I  uint32_t  Bitstream_Length_without_SEI_Register: 32;/*!< The bitstream byte-length of an encoding frame. When EnableMSliceInfoSEI
                                                         ( bit-6 of Register 0x94 ) is clear, this register returns a
                                                          value the same as Register 0x98. When EnableMSliceInfoSEI is
                                                          set, this register returns the length of video bitstream only,
                                                          not include the MSlice Info SEI.                                     */
    };
  };
  __I  uint32_t  RESERVED5[5];
  __I  uint32_t  REG_0x00D0;                        /*!< Reserved.(IME Debug Register)                                         */
  __I  uint32_t  REG_0x00D4;                        /*!< Reserved. (FME Debug Register)                                        */
  __I  uint32_t  REG_0x00D8;                        /*!< Reserved. (INTRA Debug Register)                                      */
  __I  uint32_t  REG_0x00DC;                        /*!< Reserved. (EC Debug Register)                                         */
  __I  uint32_t  REG_0x00E0;                        /*!< Reserved. (DB Debug Register)                                         */
  
  union {
    __I  uint32_t  REG_0x00E4;                      /*!< Configuration value of h264_define_dev.v                              */
    
    struct {
      __I  uint32_t  Configuration_Value: 32;       /*!< Configuration value of h264_define_dev.v                              */
    };
  };
} H264_Dec_Type;


/* ================================================================================ */
/* ================                       SEN                      ================ */
/* ================================================================================ */


/**
  * @brief Sensor Interface / ISP (SEN)
  */

typedef struct {                                    /*!< SEN Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x0000;                      /*!< Sensor Control_1                                                      */
    
    struct {
      __IO uint32_t  SEN_CLK_EN :  1;               /*!< 1: Enable sensor clock. (Output to low)                               */
           uint32_t             :  7;
      __IO uint32_t  SEN_RATE   :  8;               /*!< Sensor master clock frequency control. (Range: 2-255) F(sen_clk)=96MHz/SEN
                                                         _RATE/(SEN_DIV2+1) if SYS_DIV2=0. F(sen_clk)=48MHz/SEN_RATE/(SEN_DIV2+1)
                                                         if SYS_DIV2=1.                                                        */
      __IO uint32_t  MIPI_MODE  :  1;               /*!< 1: MIPI sensor interface
                                                         0: parallel sensor interface                                          */
           uint32_t             :  3;
      __IO uint32_t  SYNC_MODE  :  1;               /*!< 0: Hsync-valid mode for PCLK
                                                         1: Free-run mode for PCLK                                             */
      __O  uint32_t  SEN_DSTB_TSEL:  1;             /*!< This bit is valid when SENSOR_MODE=1 
                                                         1: Output 1T type of DSTB 
                                                         0: Output 2T type of DSTB                                             */
      __IO uint32_t  IMG_TX_EN  :  1;               /*!< 1 : Enable Sensor write Image Data to DRAM.                           */
      __IO uint32_t  SENSOR_MODE:  1;               /*!< 0: PCK synchronization mode 
                                                         1: buffer synchronization mode                                        */
      __IO uint32_t  VSYNC_RIS  :  1;               /*!< 1: Change frame at rising edge of VSYNC. 
                                                         0: Change frame at falling edge of VSYNC.                             */
      __IO uint32_t  HSYNC_RIS  :  1;               /*!< 1: Change line at rising edge of HSYNC. 
                                                         0: Change line at falling edge of HSYNC.                              */
      __IO uint32_t  VSYNC_HIGH :  1;               /*!< 1: VSYNC is high active. 
                                                         0: VSYNC is low active.                                               */
      __IO uint32_t  PCK_DLH_RIS:  1;               /*!< 1: Sensor Image Data Latch at PCK rising edge. 
                                                         0: Sensor Image Data Latch at PCK falling edge.
                                                         The setting of PCK_DLH_RIS depends on sensor output timing.
                                                         If sensor image data is latched at PCK rising edge, set PCK_DLH_RIS
                                                          to 1, otherwise set PCK_DLH_RIS to 0.                                */
      __IO uint32_t  HSYNC_PHASE:  3;               /*!< 0: Hsync phase lead PCK 4ns 
                                                         1: Hsync phase lead PCK 2ns 
                                                         2: Hsync phase equal to PCK 
                                                         3: Hsync phase lag PCK 2ns 
                                                         4: Hsync phase lag PCK 4ns                                            */
      __IO uint32_t  SEN_BASE_CLK_SEL:  1;          /*!< For SEN_CLK_GEN source clock 
                                                         0: 96MHz , 1: 120MHz                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0004;                      /*!< Sensor Control_2                                                      */
    
    struct {
      __IO uint32_t  MCK_PHASE  :  3;               /*!< Select MCK output delay. (Range: 0-7) 
                                                         Note: The MCK output delay is MCK_PHASE*2ns                           */
           uint32_t             :  5;
      __O  uint32_t  CLR_PCK_DET:  1;               /*!< 1:Clear PCK_DET for getting new PCK_DET                               */
      __I  uint32_t  PCK_DET    :  1;               /*!< PCK phase detection result. (3.5ns pulse detection) 
                                                         1: represents the uncertainty region 
                                                         0: represents the reliable region                                     */
           uint32_t             :  1;
      __IO uint32_t  HW_END_INT_CLR:  1;            /*!< Write 1 to clear HW_END_INT_FLAG                                      */
      __IO uint32_t  SEN_VSYNC_INT_CLR:  1;         /*!< Write 1 to clear SEN_VSYNC_INT_FLAG                                   */
      __IO uint32_t  SEN_HSYNC_INT_CLR:  1;         /*!< Write 1 to clear SEN_HSYNC_INT_FLAG                                   */
      __IO uint32_t  NR3D_FBC_ENC_INT_CLR:  1;      /*!< Write 1 to clear NR3D_FBC_ENC_INT_FLAG                                */
      __IO uint32_t  NR3D_FBC_DEC_INT_CLR:  1;      /*!< Write 1 to clear NR3D_FBC_DEC_INT_FLAG                                */
      __IO uint32_t  HW_END_INT_EN:  1;             /*!< 1: Enable HW_END interrupt                                            */
      __IO uint32_t  SEN_VSYNC_INT_EN:  1;          /*!< 1: Enable sensor VSYNC interrupt                                      */
      __I  uint32_t  HW_END_INT_FLAG:  1;           /*!< Read for HW_END interrupt event                                       */
      __I  uint32_t  SEN_VSYNC_INT_FLAG:  1;        /*!< Read for VSYNC interrupt event                                        */
      __I  uint32_t  ISP_HMI_ERR_FLAG:  1;          /*!< 1: ISP AMBA interface error                                           */
      __O  uint32_t  ISP_HMI_ERR_CLR:  1;           /*!< Write 1 to clear ISP_HMI_ERR_FLAG                                     */
      __IO uint32_t  SEN_HSYNC_INT_EN:  1;          /*!< 1: Enable sensor HSYNC interrupt                                      */
      __I  uint32_t  SEN_HSYNC_INT_FLAG:  1;        /*!< Read for HSYNC interrupt event                                        */
      __IO uint32_t  NR3D_FBC_ENC_INT_EN:  1;       /*!< 1: Enable 3DNR FBC ENC Interupt                                       */
      __I  uint32_t  NR3D_FBC_ENC_INT_FLAG:  1;     /*!< Read for 3DNR FBC ENC interrupt event                                 */
      __IO uint32_t  NR3D_FBC_DEC_INT_EN:  1;       /*!< 1: Enable 3DNR FBC DEC Interupt                                       */
      __I  uint32_t  NR3D_FBC_DEC_INT_FLAG:  1;     /*!< Read for 3DNR FBC DEC interrupt event                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0008;                      /*!< Sensor Control_3                                                      */
    
    struct {
      __IO uint32_t  H_START    : 11;               /*!< Start pixel number for capturing after HSYNC. 
                                                         (One Unit is 1 pixel)                                                 */
           uint32_t             :  5;
      __IO uint32_t  H_SIZE     : 11;               /*!< Horizontal pixel number for capturing. (One Unit is 2 pixels)
                                                         
                                                         H_SIZE should be set for multiple of 2                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x000C;                      /*!< Sensor Control_4                                                      */
    
    struct {
      __IO uint32_t  V_START    : 11;               /*!< Start line number for capturing after VSYNC. 
                                                         (One Unit is 1 line)                                                  */
           uint32_t             :  5;
      __IO uint32_t  V_SIZE     : 11;               /*!< Vertical line number for capturing. (One Unit is 2 lines) 
                                                         V_SIZE should be set for multiple of 2                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0010;                      /*!< Sensor Control_5                                                      */
    
    struct {
      __IO uint32_t  HO_SIZE    :  8;               /*!< Horizontal pixel number for sensor. (One unit is 32 pixels)
                                                         
                                                         Note: It is sync with VSYNC, used when sensor is slave mode.          */
      __IO uint32_t  VO_SIZE    :  7;               /*!< Vertical pixel number for sensor. (One unit is 32 lines) 
                                                         Note: It is sync with VSYNC, used when sensor is slave mode.          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0014;                      /*!< SEN_ISP_MODE                                                          */
    
    struct {
      __IO uint32_t  ISP_BRIG   :  1;               /*!< Input YUV data, and bypass to PostColor                               */
      __IO uint32_t  ISP_MODE   :  1;               /*!< 0: support sensor output format is Bayer Pattern mode 
                                                         1: support sensor output format is YUYV422 mode                       */
      __IO uint32_t  ISP_LH_SEL :  1;               /*!< 0: Image data selection is D0-D7 
                                                         1: Image data selection is D2-D9 
                                                         Applied in ISP_MODE                                                   */
      __IO uint32_t  TEST_PAT_TYPE:  2;             /*!< 00: Normal, 01: RAW pattern, 10: YUV pattern, 
                                                         11: EMI test pattern                                                  */
      __IO uint32_t  BS_BYPASS  :  1;               /*!< 1: Enable bit-stream bypass mode (for ST58600, BS_BYPASS is
                                                         0 ) 
                                                         The register setting should be followed as: 
                                                         * SENSOR_MODE = 1 
                                                         * SYNC_MODE = 0 
                                                         * HVALID data must be 4 byte alignment 
                                                         * ISP_LH_SEL =0/1 => I_IMG[7:0]/ I_IMG[9:2]                           */
           uint32_t             :  1;
      __IO uint32_t  ISP_HSTART_OFFSET:  1;         /*!< 1: offset 1 component                                                 */
    };
  };
  __IO uint8_t   RAW_REORDER;                       /*!< 0:B, 1:Gb, 2:Gr, 3:R                                                  */
  __I  uint8_t   RESERVED[7];
  
  union {
    __IO uint32_t  REG_0x0020;                      /*!< BL_B_MIN                                                              */
    
    struct {
      __I  uint32_t  BL_B_MIN   :  8;               /*!< Min value of input 10bits B raw data, max report value 255            */
      __I  uint32_t  BL_GB_MIN  :  8;               /*!< Min value of input 10bits Gb raw data, max report value 255           */
      __I  uint32_t  BL_GR_MIN  :  8;               /*!< Min value of input 10bits Gr raw data, max report value 255           */
      __I  uint32_t  BL_R_MIN   :  8;               /*!< Min value of input 10bits R raw data, max report value 255            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0024;                      /*!< CNL_GAIN_B                                                            */
    
    struct {
      __IO uint32_t  CNL_GAIN_B : 14;               /*!< RAW data B channel gain                                               */
           uint32_t             :  2;
      __IO uint32_t  CNL_GAIN_GB: 14;               /*!< RAW data GB channel gain                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0028;                      /*!< CNL_GAIN_GR                                                           */
    
    struct {
      __IO uint32_t  CNL_GAIN_GR: 14;               /*!< RAW data GR channel gain                                              */
           uint32_t             :  2;
      __IO uint32_t  CNL_GAIN_R : 14;               /*!< RAW data R channel gain                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x002C;                      /*!< CNL_OFFSET_B                                                          */
    
    struct {
      __IO uint32_t  CNL_OFFSET_B:  8;              /*!< RAW data B component Level shift offset                               */
      __IO uint32_t  CNL_OFFSET_GB:  8;             /*!< RAW data GB component Level shift offset                              */
      __IO uint32_t  CNL_OFFSET_GR:  8;             /*!< RAW data GR component Level shift offset                              */
      __IO uint32_t  CNL_OFFSET_R:  8;              /*!< RAW data R component Level shift offset                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0030;                      /*!< ISP LSC                                                               */
    
    struct {
      __IO uint32_t  LSC_EN     :  1;               /*!< Enable Lens Shading Compensation function.                            */
      __IO uint32_t  LSC_CIRCLE_EN:  1;             /*!< Enable circle-based Lens shading compensation. 
                                                         * This bit is useful when LSC_EN is 1.                                */
      __IO uint32_t  LSC_BLOCK_EN:  1;              /*!< Enable block-based Lens shading compensation. 
                                                         * This bit is useful when LSC_EN is 1. 
                                                         * This bit can be enable after the LSC_R_GAIN, LSC_G_GAIN, LSC_B_GAIN
                                                         are filled completely.                                                */
           uint32_t             :  4;
      __IO uint32_t  LSC_CG_CHANGE:  1;             /*!< (null)                                                                */
      __IO uint32_t  LSC_RGB_SEL:  2;               /*!< 0:R, 1:G, 2:B, 3:NA                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0034;                      /*!< ISP LSC CENTRE                                                        */
    
    struct {
      __IO uint32_t  LSC_CENTERX: 12;               /*!< Coordinate X of center point of image for lens shading compensation
                                                         function - 11 bits                                                    */
           uint32_t             :  4;
      __IO uint32_t  LSC_CENTERY: 12;               /*!< Coordinate Y of center point of image for lens shading compensation
                                                         function - 11 bits                                                    */
    };
  };
  __I  uint32_t  RESERVED1;
  
  union {
    __IO uint32_t  REG_0x003C;                      /*!< LSC_MValue                                                            */
    
    struct {
      __IO uint32_t  LSC_MVALUE :  8;               /*!< the m value used to compute field                                     */
      __IO uint32_t  LSC_SVALUE :  8;               /*!< the svalue used to compute field                                      */
      __IO uint32_t  LSC_SHIFT  :  2;               /*!< The block size (block-based)                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0040;                      /*!< LSC_OFFSET                                                            */
    
    struct {
      __IO uint32_t  LSC_X_OFFSET: 13;              /*!< the x offset of the block gain table, Range -4096~4095                */
           uint32_t             :  3;
      __IO uint32_t  LSC_Y_OFFSET: 12;              /*!< the y offset of the block gain table, Range -2048 ~2047               */
    };
  };
  __I  uint32_t  RESERVED2[2];
  __IO uint32_t  LSC_GAIN;                          /*!< Input gain table data port 
                                                         1.LSC Circle GAIN[11:0] 
                                                         2.LSC Block {R[10:0],G[10:0]} for even address 
                                                         LSC Block B[10:0] for odd address                                     */
  
  union {
    __IO uint32_t  REG_0x0050;                      /*!< LSC_ADDRESS                                                           */
    
    struct {
      __IO uint32_t  LSC_ADDRESS: 15;               /*!< Start address of gain table 
                                                         LSC_ADDRESS[14:13]: 
                                                         2'b00: CIR0 Gain, Node 0, 2, 4, .......,510, 512 (total 257
                                                         node) 
                                                         2'b01: CIR1 Gain, Node 1, 3, 5, ...... , 511 (total 256 node)
                                                          
                                                         2'b10 : Block Gain, 0, 1, 2, ...... , 255 
                                                         LSC_ADDRESS[12:11]: 
                                                         2'b00: CIR0/CIR1 BGain 
                                                         2'b01: CIR0/CIR1 GBGain 
                                                         2'b10: CIR0/CIR1 GRGain 
                                                         2'b11: CIR0/CIR1 RGain 
                                                         LSC_ADDRESS[10:0]: 
                                                         Address for each t                                                    */
           uint32_t             :  9;
      __IO uint32_t  LSC_GAIN_WIDTH:  5;            /*!< The width of LSC gain table (1~17)                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0054;                      /*!< AWB_RGAIN0                                                            */
    
    struct {
      __IO uint32_t  AWB_RGAIN0 :  9;               /*!< R gain = BAYER_AWB_RGAIN0/128                                         */
           uint32_t             :  7;
      __IO uint32_t  AWB_GGAIN0 :  9;               /*!< G gain = BAYER_AWB_GGAIN0/128                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0058;                      /*!< AWB_BGAIN0                                                            */
    
    struct {
      __IO uint32_t  AWB_BGAIN0 :  9;               /*!< B gain = BAYER_AWB_BGAIN0/128                                         */
           uint32_t             :  7;
      __IO uint32_t  AWB_RGAIN1 :  9;               /*!< R gain = BAYER_AWB_GGAIN1/128                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x005C;                      /*!< AWB_GGAIN1                                                            */
    
    struct {
      __IO uint32_t  AWB_GGAIN1 :  9;               /*!< G gain = BAYER_AWB_GGAIN1/128                                         */
           uint32_t             :  7;
      __IO uint32_t  AWB_BGAIN1 :  9;               /*!< B gain = BAYER_AWB_BGAIN1/128                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0060;                      /*!< AWB_POS_RGAIN                                                         */
    
    struct {
      __IO uint32_t  AWB_POS_RGAIN:  9;             /*!< RGB AWB R post GAIN                                                   */
           uint32_t             :  7;
      __IO uint32_t  AWB_POS_GGAIN:  9;             /*!< RGB AWB G post GAIN                                                   */
    };
  };
  __IO uint16_t  AWB_POS_BGAIN;                     /*!< RGB AWB B post GAIN                                                   */
  __I  uint16_t  RESERVED3;
  
  union {
    __IO uint32_t  REG_0x0068;                      /*!< CCM_MATRIX_INDEX                                                      */
    
    struct {
      __IO uint32_t  CCM_MATRIX_INDEX:  2;          /*!< Select MATRIX_GR[N]~ MATRIX_GB[N]                                     */
           uint32_t             : 14;
      __IO uint32_t  CCM_MATRIX_CP:  9;             /*!< When MATRIX_CP=511                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x006C;                      /*!< CCM_MATRIX_RR                                                         */
    
    struct {
      __IO uint32_t  CCM_MATRIX_RR: 10;             /*!< MATRIX_RR[N] , 0~1023                                                 */
           uint32_t             :  6;
      __IO uint32_t  CCM_MATRIX_GG: 10;             /*!< MATRIX_GG[N] , 0~1023                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0070;                      /*!< CCM_MATRIX_BB                                                         */
    
    struct {
      __IO uint32_t  CCM_MATRIX_BB: 10;             /*!< MATRIX_BB[N] , 0~1023                                                 */
           uint32_t             :  6;
      __IO uint32_t  CCM_MATRIX_GR: 10;             /*!< MATRIX_GR[N], -512~511                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0074;                      /*!< CCM_MATRIX_BR                                                         */
    
    struct {
      __IO uint32_t  CCM_MATRIX_BR: 10;             /*!< MATRIX_BR[N] , -512~511                                               */
           uint32_t             :  6;
      __IO uint32_t  CCM_MATRIX_RG: 10;             /*!< MATRIX_RG[N] , -512~511                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0078;                      /*!< CCM_MATRIX_BG                                                         */
    
    struct {
      __IO uint32_t  CCM_MATRIX_BG: 10;             /*!< MATRIX_BG[N] , -512~511                                               */
           uint32_t             :  6;
      __IO uint32_t  CCM_MATRIX_RB: 10;             /*!< MATRIX_RB[N] , -512~511                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x007C;                      /*!< CCM_MATRIX_GB                                                         */
    
    struct {
      __IO uint32_t  CCM_MATRIX_GB: 10;             /*!< MATRIX_GB[N] , -512~511                                               */
           uint32_t             :  6;
      __IO uint32_t  CCM_MATRIX_ROFFSET:  8;        /*!< MATRIX_ROFFSET [N][7:0] , -128~127                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0080;                      /*!< CCM_MATRIX_GOFFSET                                                    */
    
    struct {
      __IO uint32_t  CCM_MATRIX_GOFFSET:  8;        /*!< MATRIX_GOFFSET [N][7:0] , -128~127                                    */
           uint32_t             :  8;
      __IO uint32_t  CCM_MATRIX_BOFFSET:  8;        /*!< MATRIX_BOFFSET [N][7:0] , -128~127                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0084;                      /*!< NR3D_FBC_MINK                                                         */
    
    struct {
      __IO uint32_t  NR3D_FBC_MINK:  4;             /*!< min. golomb k                                                         */
      __IO uint32_t  NR3D_FBC_MAXK:  4;             /*!< max. golomb k                                                         */
      __IO uint32_t  NR3D_FBC_ENHK:  2;             /*!< Enhanced golomb k step                                                */
           uint32_t             :  6;
      __IO uint32_t  NR3D_FBC_EN:  1;               /*!< 1: enable 3DNR frame compression                                      */
    };
  };
  __I  uint32_t  NR3D_FBC_TOTAL_BITS_SIZE;          /*!< Updated by Vsync                                                      */
  __I  uint32_t  RESERVED4;
  
  union {
    __IO uint32_t  REG_0x0090;                      /*!< RGB_GAMMA_EN                                                          */
    
    struct {
      __IO uint32_t  RGB_GAMMA_EN:  1;              /*!< 1: RGB Gamma function enable                                          */
      __IO uint32_t  RGB_GAMMA_MODE:  2;            /*!< 0: Sync mode; 1: R gamma; 2: G gamma 3: B gamma                       */
      __IO uint32_t  RGB_GAMMA_EXT:  1;             /*!< 0: 0~23 Gamma table, 1: 0~29 Gamma table                              */
      __IO uint32_t  RGB_GAMMA_SEL:  3;             /*!< RGB Gamma Group Selection: 
                                                         0: RGB_GAMMA0 ~ RGB_GAMMA1 
                                                         1: RGB_GAMMA2 ~ RGB_GAMMA3 
                                                         2: RGB_GAMMA4 ~ RGB_GAMMA5 
                                                         3: RGB_GAMMA6 ~ RGB_GAMMA7 
                                                         4: RGB_GAMMA8 ~ RGB_GAMMA9 
                                                         5: RGB_GAMMA10 ~ RGB_GAMMA11 
                                                         6: RGB_GAMMA12 ~ RGB_GAMMA13 
                                                         7: RGB_GAMMA14 ~ RGB_GAMMA15 
                                                         8: RGB_GAMMA16 ~ RGB_GAMMA17 
                                                         9: RGB_GAMMA18 ~ RGB_GAMMA19 
                                                         a: RGB_GAMMA20 ~ RGB_GAMMA21 
                                                         b: RGB_GAMMA22 ~ RGB_GAMMA23 
                                                                                                                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0094;                      /*!< RGB_GAMMA0                                                            */
    
    struct {
      __IO uint32_t  RGB_GAMMA0 : 10;               /*!< Default: 
                                                         (0,16),(32,64),(96,128),(192,256),(320,384),(448,512), 
                                                         (576,640),(704,736),(768,800),(832,864),(896,928),(960,1023)
                                                         
                                                                                                                               */
           uint32_t             :  6;
      __IO uint32_t  RGB_GAMMA1 : 10;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0098;                      /*!< RGB_GAMMA2                                                            */
    
    struct {
      __IO uint32_t  RGB_GAMMA2 : 10;               /*!< Default: 
                                                         (0,16),(32,64),(96,128),(192,256),(320,384),(448,512), 
                                                         (576,640),(704,736),(768,800),(832,864),(896,928),(960,1023)          */
           uint32_t             :  6;
      __IO uint32_t  RGB_GAMMA3 : 10;               /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  REG_0x00A0;                      /*!< DT_MATRIX_YR                                                          */
    
    struct {
      __IO uint32_t  DT_MATRIX_YR:  8;              /*!< (null)                                                                */
      __IO uint32_t  DT_MATRIX_YG:  8;              /*!< (null)                                                                */
      __IO uint32_t  DT_MATRIX_YB:  8;              /*!< (null)                                                                */
      __IO uint32_t  DT_MATRIX_YGAIN:  8;           /*!< Unit = 1/64                                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A4;                      /*!< DT_MATRIX_UR                                                          */
    
    struct {
      __IO uint32_t  DT_MATRIX_UR:  9;              /*!< (null)                                                                */
           uint32_t             :  7;
      __IO uint32_t  DT_MATRIX_UG:  9;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00A8;                      /*!< DT_MATRIX_UB                                                          */
    
    struct {
      __IO uint32_t  DT_MATRIX_UB:  9;              /*!< (null)                                                                */
           uint32_t             :  7;
      __IO uint32_t  DT_MATRIX_VR:  9;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00AC;                      /*!< DT_MATRIX_VG                                                          */
    
    struct {
      __IO uint32_t  DT_MATRIX_VG:  9;              /*!< (null)                                                                */
           uint32_t             :  7;
      __IO uint32_t  DT_MATRIX_VB:  9;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00B0;                      /*!< UV_SLICE                                                              */
    
    struct {
      __IO uint32_t  UV_SLICE   :  7;               /*!< the threshold of the UV slice function. When the chroma value
                                                         is only smaller than UV_SLICE, UV slice function is available.        */
           uint32_t             :  1;
      __IO uint32_t  UV_SLICE_OFFSET:  5;           /*!< the gray boundary of the UV slice function. IF the chroma value
                                                         is smaller than UV_SLICE_OFFSET, the output value is zero.            */
           uint32_t             :  3;
      __IO uint32_t  UV_SLICE_GAIN:  6;             /*!< the slope of the UV slice function.                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00B4;                      /*!< SUVS_EN                                                               */
    
    struct {
      __IO uint32_t  SUVS_EN    :  1;               /*!< Surrounding UV suppress enable                                        */
           uint32_t             :  7;
      __IO uint32_t  SUVS_STR   :  8;               /*!< Surrounding UV suppress enable                                        */
      __IO uint32_t  SUVS_SLP   :  4;               /*!< Gain = 128-(SUVS_SLP*(Distance-SUVS_STR)>>4), limit to 0              */
      __IO uint32_t  SUVS_MVALUE:  8;               /*!< (null)                                                                */
      __IO uint32_t  SUVS_SVALUE:  4;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00B8;                      /*!< NL_MATRIX_SEL                                                         */
    
    struct {
      __IO uint32_t  NL_MATRIX_SEL:  5;             /*!< NL_MATRIX[N][4] 
                                                         N: NL_MATRIX_SEL (0~31)                                               */
           uint32_t             :  3;
      __IO uint32_t  NL_TABLE_SEL:  4;              /*!< Select NL_TABLE; NL_TABLE[4][N] ,N: NL_TABLE_SEL (0~15)               */
           uint32_t             :  4;
      __IO uint32_t  NL_SEGSHIFT_SEL:  2;           /*!< NL_SEGSHIFT [N] , N: NL_SEGSHIFT_SEL (0~3)                            */
           uint32_t             : 13;
      __IO uint32_t  NL_EN      :  1;               /*!< Non linear color mapping enable                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00BC;                      /*!< NL_MATRIX                                                             */
    
    struct {
      __IO uint32_t  NL_MATRIX0 :  8;               /*!< Non linear color mapping matrix In zone N, N = 0~7 
                                                         Uout = (NL_MATRIX[N][0]*Uin+NL_MATRIX[N][1]*Vin)/64 
                                                         Vout = (NL_MATRIX[N][2]*Uin + NL_MATRIX[N][3]*Vin)/64 
                                                                                                                               */
      __IO uint32_t  NL_MATRIX1 :  8;               /*!< (null)                                                                */
      __IO uint32_t  NL_MATRIX2 :  8;               /*!< (null)                                                                */
      __IO uint32_t  NL_MATRIX3 :  8;               /*!< (null)                                                                */
    };
  };
  __IO uint8_t   NL_SEGSHIFT;                       /*!< NL_SEGSHIFT_[N], N=0~3, NL_SEGSHIFT_SEL=0~3                           */
  __I  uint8_t   RESERVED6[3];
  
  union {
    __IO uint32_t  REG_0x00C4;                      /*!< NL_TABLE_0                                                            */
    
    struct {
      __IO uint32_t  NL_TABLE_0 :  5;               /*!< NL_TABLE_SEL=0 ~ 15 
                                                         NL_TABLE_0 = NL_TABLE_0_00 ~ NL_TABLE_0_15 
                                                         NL_TABLE_1 = NL_TABLE_1_00 ~ NL_TABLE_1_15 
                                                         NL_TABLE_2 = NL_TABLE_2_00 ~ NL_TABLE_2_15 
                                                         NL_TABLE_3 = NL_TABLE_3_00 ~ NL_TABLE_3_15                            */
           uint32_t             :  3;
      __IO uint32_t  NL_TABLE_1 :  5;               /*!< (null)                                                                */
           uint32_t             :  3;
      __IO uint32_t  NL_TABLE_2 :  5;               /*!< (null)                                                                */
           uint32_t             :  3;
      __IO uint32_t  NL_TABLE_3 :  5;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00C8;                      /*!< CS_HLCS_EN                                                            */
    
    struct {
      __IO uint32_t  CS_HLCS_EN :  1;               /*!< 1: Enable H/L color suppression                                       */
      __IO uint32_t  CS_FOCUS_B_FLAG:  1;           /*!< Focus on B channel                                                    */
      __IO uint32_t  CS_FOCUS_G_FLAG:  1;           /*!< Focus on G channel                                                    */
      __IO uint32_t  CS_FOCUS_R_FLAG:  1;           /*!< Focus on R channel                                                    */
           uint32_t             :  4;
      __IO uint32_t  CS_L_THD   :  7;               /*!< Low light threshold                                                   */
           uint32_t             :  1;
      __IO uint32_t  CS_H_THD   :  7;               /*!< High light threshold                                                  */
           uint32_t             :  1;
      __IO uint32_t  CS_L_SLOPE :  4;               /*!< Low light suppression slope                                           */
      __IO uint32_t  CS_H_SLOPE :  4;               /*!< high light suppression slope                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00CC;                      /*!< SUVS_CENTER_X                                                         */
    
    struct {
      __IO uint32_t  SUVS_CENTER_X: 12;             /*!< (null)                                                                */
           uint32_t             :  4;
      __IO uint32_t  SUVS_CENTER_Y: 12;             /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00D0;                      /*!< AWB_SIZE_X                                                            */
    
    struct {
      __IO uint32_t  AWB_SIZE_X :  8;               /*!< AWB sample sampled size after skip for H direction                    */
      __IO uint32_t  AWB_SKIP_X :  4;               /*!< AWB sample skip value for H direction                                 */
           uint32_t             :  4;
      __IO uint32_t  AWB_SIZE_Y :  8;               /*!< AWB sample sampled size after skip for V direction                    */
      __IO uint32_t  AWB_SKIP_Y :  4;               /*!< AWB sample skip value for V direction                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00D4;                      /*!< AWB_START                                                             */
    
    struct {
      __IO uint32_t  AWB_START_X: 12;               /*!< Note : 1. Must be even number                                         */
           uint32_t             :  4;
      __IO uint32_t  AWB_START_Y: 11;               /*!< Note : 1. Must be even number                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00D8;                      /*!< AWB_YMAX                                                              */
    
    struct {
      __IO uint32_t  AWB_YMAX   :  8;               /*!< AWB Counter 1 accumulate in report if Y in the range of 
                                                         [AWB_YMIN to AWB_YMAX]                                                */
           uint32_t             :  8;
      __IO uint32_t  AWB_YMIN   :  8;               /*!< AWB Counter 1 accumulate in report if Y in the range of 
                                                         [AWB_YMIN to AWB_YMAX]                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00DC;                      /*!< AWB_YMAX2                                                             */
    
    struct {
      __IO uint32_t  AWB_YMAX2  :  8;               /*!< AWB Counter 2 accumulate in report if Y in the range of 
                                                         [AWB_YMIN2 to AWB_YMAX2]                                              */
           uint32_t             :  8;
      __IO uint32_t  AWB_YMIN2  :  8;               /*!< AWB Counter 2 accumulate in report if Y in the range of 
                                                         [AWB_YMIN2 to AWB_YMAX2]                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00E0;                      /*!< AWB_CTW_YMAX                                                          */
    
    struct {
      __IO uint32_t  AWB_CTW_YMAX:  8;              /*!< AWB Counter 3 accumulate in report if Y,I and Q in the range
                                                         of 
                                                         [AWB_CTW_YMIN to AWB_CTW_YMAX] and 
                                                         [AWB_CTW_IMIN to AWB_CTW_IMAX] and 
                                                         [AWB_CTW_QMIN to AWB_CTW_QMAX]                                        */
      __IO uint32_t  AWB_CTW_YMIN:  8;              /*!< (null)                                                                */
      __IO uint32_t  AWB_CTW_IMAX:  7;              /*!< (null)                                                                */
           uint32_t             :  1;
      __IO uint32_t  AWB_CTW_QMAX:  7;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00E4;                      /*!< AWB_UOFFSET                                                           */
    
    struct {
      __IO uint32_t  AWB_UOFFSET:  6;               /*!< CT original point compensation for U(Range : 31 ~ -32)                */
           uint32_t             : 10;
      __IO uint32_t  AWB_VOFFSET:  6;               /*!< CT original point compensation for V(Range : 31 ~ -32)                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00E8;                      /*!< AWB_CTYMAX                                                            */
    
    struct {
      __IO uint32_t  AWB_CTYMAX :  8;               /*!< Max. Y boundary for CT report                                         */
           uint32_t             :  8;
      __IO uint32_t  AWB_CTYMIN :  8;               /*!< Min. Y boundary for CT report                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00EC;                      /*!< AWB_CWF_S                                                             */
    
    struct {
      __IO uint32_t  AWB_CWF_S  :  9;               /*!< Slop for CWF edge(Range : 255 ~ -256)                                 */
           uint32_t             :  7;
      __IO uint32_t  AWB_CWF_G  :  1;               /*!< Select sign 0:1,1:-1                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00F0;                      /*!< AWB_LEFTA                                                             */
    
    struct {
      __IO uint32_t  AWB_LEFTA  :  7;               /*!< Parameter for the left edge                                           */
           uint32_t             :  1;
      __IO uint32_t  AWB_LEFTB  :  7;               /*!< Parameter for the left edge                                           */
           uint32_t             :  1;
      __IO uint32_t  AWB_RIGHTA :  7;               /*!< Parameter for the right edge                                          */
           uint32_t             :  1;
      __IO uint32_t  AWB_RIGHTB :  7;               /*!< Parameter for the right edge                                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00F4;                      /*!< AWB_LEFTC0                                                            */
    
    struct {
      __IO uint32_t  AWB_LEFTC0 :  8;               /*!< (null)                                                                */
      __IO uint32_t  AWB_LEFTC1 :  8;               /*!< (null)                                                                */
      __IO uint32_t  AWB_RIGHTC0:  8;               /*!< (null)                                                                */
      __IO uint32_t  AWB_RIGHTC1:  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00F8;                      /*!< AWB_INDEX_HB                                                          */
    
    struct {
      __IO uint32_t  AWB_INDEX_HB:  6;              /*!< High boundary for CT report                                           */
           uint32_t             : 10;
      __IO uint32_t  AWB_INDEX_LB:  6;              /*!< Low boundary for CT report                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x00FC;                      /*!< AWB_HIST_RPT_RDY                                                      */
    
    struct {
      __I  uint32_t  AWB_HIST_RPT_RDY:  1;          /*!< Read 1: HIST report is ready to read.                                 */
      __I  uint32_t  AWB_RPT_RDY:  1;               /*!< Read 1: AWB report is ready to read.                                  */
      __IO uint32_t  AWB_CTWINDOWEN:  1;            /*!< CT window enable                                                      */
      __IO uint32_t  AWB_SOURCESEL:  1;             /*!< 0 : AWB report point (raw domain) 
                                                         1 : CTW report point (RGB domain)                                     */
      __IO uint32_t  AWB_HIST_EN:  1;               /*!< Write 1:Trigger HIST report generation and clear ready flag           */
      __IO uint32_t  AWB_RPT_EN :  1;               /*!< Write 1:Trigger AWB report generation and clear ready flag            */
      __IO uint32_t  YHISTOGRAMSEL:  1;             /*!< 0 : Y histogram from RAW domain
                                                         1 : Y histogram from RGB domain                                       */
      __IO uint32_t  AWB_CTWRPT_SEL:  1;            /*!< 0 : RGB CTW report from VLDC output 
                                                         1 : RGB CTW report from GAMMA output                                  */
      __IO uint32_t  AWB_YHIS_INDEX:  4;            /*!< Histogram index of YHISTOGRAM                                         */
    };
  };
  __I  uint16_t  AWB_YHISTOGRAM;                    /*!< AWB Y histogram report                                                */
  __I  uint16_t  RESERVED7;
  __I  uint32_t  AWB_RSUM;                          /*!< AWB R sum report. AWB_RSUM[2~0][23:0] are selected by setting
                                                         AWB_RPT_SEL[1:0].                                                     */
  __I  uint32_t  AWB_GSUM;                          /*!< AWB G sum report. AWB_GSUM[2~0][23:0] are selected by setting
                                                         AWB_RPT_SEL[1:0].                                                     */
  __I  uint32_t  AWB_BSUM;                          /*!< AWB B sum report. AWB_BSUM[2~0][23:0] are selected by setting
                                                         AWB_RPT_SEL[1:0].                                                     */
  __I  uint32_t  AWB_CTRSUM;                        /*!< CT R sum. AWB_CTRSUM[7~0][23:0] are selected by setting AWB_CTINDEX[2:0]. */
  __I  uint32_t  AWB_CTGSUM;                        /*!< CT G sum. AWB_CTGSUM[7~0][23:0] are selected by setting AWB_CTINDEX[2:0]. */
  __I  uint32_t  AWB_CTBSUM;                        /*!< CT B sum. AWB_CTBSUM[7~0][23:0] are selected by setting AWB_CTINDEX[2:0]. */
  __I  uint32_t  RESERVED8[3];
  
  union {
    __IO uint32_t  REG_0x0128;                      /*!< AWB_CTINDEX                                                           */
    
    struct {
      __IO uint32_t  AWB_CTINDEX:  3;               /*!< CT report 
                                                         0~7:In the order of the max to min value in CT counter 
                                                         (0:max , 7:min)                                                       */
           uint32_t             :  3;
      __IO uint32_t  AWB_RPT_SEL:  2;               /*!< 0 : AWB average 1 , 1 : AWB average 2 , 2 : CTW sum, 3: CTW1
                                                         sum                                                                   */
      __IO uint32_t  CT_FL_SEL  :  1;               /*!< 0 : full CT Report , 1: L CT Report                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x012C;                      /*!< AWB_CTREGION                                                          */
    
    struct {
      __I  uint32_t  AWB_CTREGION:  6;              /*!< Record index in CT report                                             */
           uint32_t             : 10;
      __I  uint32_t  AWB_COUNT  : 16;               /*!< AWB counter accumulation report for full IQ window. AWB_COUNT[1~0]
                                                         
                                                         [15:0] are selected by setting AWB_RPT_SEL[1:0].                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0130;                      /*!< AWB_CTCOUNTS                                                          */
    
    struct {
      __I  uint32_t  AWB_CTCOUNTS: 16;              /*!< Counter values in CT. AWB_CTCOUNTS[7~0][15:0] are selected by
                                                         setting AWB_CTINDEX[2:0]. 
                                                                                                                               */
           uint32_t             :  8;
      __I  uint32_t  AWB_CTDIST_H:  2;              /*!< The status flags of the CT reports                                    */
    };
  };
  __I  uint32_t  AWB_CTDIST_L;                      /*!< The status flags of the CT reports.[31:0]                             */
  
  union {
    __IO uint32_t  REG_0x0138;                      /*!< AWB_VOI0                                                              */
    
    struct {
      __IO uint32_t  AWB_VOI0   :  6;               /*!< The index selection of the user-defined outputs                       */
           uint32_t             :  2;
      __IO uint32_t  AWB_VOI1   :  6;               /*!< The index selection of the user-defined outputs                       */
           uint32_t             :  2;
      __IO uint32_t  AWB_VOI2   :  6;               /*!< The index selection of the user-defined outputs                       */
           uint32_t             :  2;
      __IO uint32_t  AWB_VOI3   :  6;               /*!< The index selection of the user-defined outputs                       */
           uint32_t             :  1;
      __IO uint32_t  AWB_VOIEN  :  1;               /*!< Enable the user-defined output of the CT reports                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x013C;                      /*!< BL_TRG                                                                */
    
    struct {
      __I  uint32_t  BL_TRG     :  1;               /*!< Read 1: Black level report ready                                      */
      __IO uint32_t  SEN_TRIG_0 :  1;               /*!< B/GB/GR/R OFFSET[7:0] frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_1 :  1;               /*!< RAW B/GB/GR/R GAIN[9:0] frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_2 :  1;               /*!< LSC frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_3 :  1;               /*!< AWB GAIN 0 and GAIN 1 frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  BL_TRG_CLR :  1;               /*!< Write 1: trigger BL report and clear ready flag 
                                                         Auto clear 0 by next vsync                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0140;                      /*!< SEN_TRIG_4                                                            */
    
    struct {
      __IO uint32_t  SEN_TRIG_4 :  1;               /*!< RGB Post GAIN frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_5 :  1;               /*!< Multi Color Correction Matrix (CCM)frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_6 :  1;               /*!< GAMMA Curve frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_7 :  1;               /*!< Domain Transfer Matrix frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_8 :  1;               /*!< UV_SLICE, UV_SLICE_(OFFSET/GAIN) frame sync tigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_9 :  1;               /*!< Non-linear Color Mapping frame sync trigger 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_10:  1;               /*!< Surrounding UV Suppression 
                                                         Auto clear 0 by vsync                                                 */
      __IO uint32_t  SEN_TRIG_11:  1;               /*!< H/L Light Color Suppression 
                                                         Auto clear 0 by next vsync                                            */
      __IO uint32_t  SEN_TRIG_12:  1;               /*!< DRC_GAMMA 
                                                         Auto clear 0 by next vsync                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0144;                      /*!< DMY_INSERT                                                            */
    
    struct {
      __IO uint32_t  DMY_INSERT :  1;               /*!< 1: Dummy line/pixel insertion                                         */
           uint32_t             :  2;
      __IO uint32_t  NUM_DMY_LN :  5;               /*!< Set how many dummy lines inserted                                     */
      __IO uint32_t  NUM_DMY_DSTB: 11;              /*!< Set how many dummy pixels inserted                                    */
      __IO uint32_t  DMY_DIV    :  3;               /*!< 0: dummy clock rate = SYS_CLK / 16 
                                                         1: dummy clock rate = SYS_CLK / 8 
                                                         2: dummy clock rate = SYS_CLK / 4 
                                                         3: dummy clock rate = SYS_CLK / 2 
                                                         4: dummy clock rate = SYS_CLK 
                                                         7:5 don't used                                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0148;                      /*!< EMI_Y1                                                                */
    
    struct {
      __IO uint32_t  EMI_Y1     :  8;               /*!< Test pattern for EMI test (MSB: sign bit) Y1                          */
      __IO uint32_t  EMI_Y2     :  8;               /*!< Test pattern for EMI test (MSB: sign bit) Y2                          */
      __IO uint32_t  EMI_UV1    :  8;               /*!< Test pattern for EMI test (MSB: sign bit) UV1                         */
      __IO uint32_t  EMI_UV2    :  8;               /*!< Test pattern for EMI test (MSB: sign bit) UV2                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x014C;                      /*!< HVALID_MODE                                                           */
    
    struct {
      __IO uint32_t  HVALID_MODE:  1;               /*!< 1: set sensor interface on H-valid mode,
                                                         (PCK is valid when Hsync active)                                      */
      __IO uint32_t  N4B        :  1;               /*!< 1: Support H_END is not 4-byte alignment 
                                                         For Bayer sensor H_END = H_START + H_SIZE*4 
                                                         For YUV sensor H_END = (H_START + H_SIZE*4)*2 + ISP_HSTART_OFFSET
                                                         
                                                         This bit is reserved for sensor interface test.                       */
    };
  };
  __I  uint32_t  CT_FULL_L_RSUM;                    /*!< Full CT Report / L CT Report, by selecting CT_FL_SEL                  */
  __I  uint32_t  CT_FULL_L_GSUM;                    /*!< Full CT Report / L CT Report, by selecting CT_FL_SEL                  */
  __I  uint32_t  CT_FULL_L_BSUM;                    /*!< Full CT Report / L CT Report, by selecting CT_FL_SEL                  */
  __I  uint16_t  CT_FULL_L_CNT;                     /*!< Full CT Report / L CT Report, by selecting CT_FL_SEL                  */
  __I  uint16_t  RESERVED9;
  
  union {
    __IO uint32_t  REG_0x0160;                      /*!< BAYER_SUM_SEL                                                         */
    
    struct {
      __IO uint32_t  BAYER_SUM_SEL:  3;             /*!< 0: Select 3DNR output BAYER_SUM 
                                                         1: Select NR output BAYER_SUM 
                                                         2: Select DRC output BAYER_SUM 
                                                         3,4,5,6,7: reserved                                                   */
           uint32_t             :  5;
      __IO uint32_t  RGB_SUM_SEL:  4;               /*!< 0: Select CI output R_SUM 
                                                         1: Select CI output G_SUM 
                                                         2: Select CI output B_SUM 
                                                         3: Select RGB VLDC output R_SUM 
                                                         4: Select RGB VLDC output G_SUM 
                                                         5: Select RGB VLDC output B_SUM 
                                                         6: Select RGB gamma curve output R_SUM 
                                                         7: Select RGB gamma curve output G_SUM 
                                                         8: Select RGB gamma curve output B_SUM                                */
    };
  };
  __I  uint32_t  BAYER_SUM;                         /*!< Check sum in BAYER domain, each BAYER component in a frame was
                                                         taken into account.                                                   */
  __I  uint32_t  RGB_SUM;                           /*!< Check sum in RGB domain, each RGB component in a frame was taken
                                                         into account.                                                         */
  __I  uint32_t  RESERVED10;
  
  union {
    __IO uint32_t  REG_0x0170;                      /*!< HSYNC_DEL_NT_CHGAIN1                                                  */
    
    struct {
      __IO uint32_t  HSYNC_DEL_NT_CHGAIN1:  8;      /*!< Last pck to HSYNC delay nT for CHGAIN1                                */
      __IO uint32_t  HSYNC_DEL_NT_CI:  8;           /*!< Last pck to HSYNC delay nT for CI                                     */
      __IO uint32_t  HSYNC_DEL_NT_VLDC:  8;         /*!< Last pck to HSYNC delay nT for VLDC                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0174;                      /*!< AWB_CTW1_YMAX                                                         */
    
    struct {
      __IO uint32_t  AWB_CTW1_YMAX:  8;             /*!< AWB Counter 4 accumulate in report if Y,I and Q in the range
                                                         of 
                                                         [AWB_CTW_YMIN to AWB_CTW_YMAX] and 
                                                         [AWB_CTW_IMIN to AWB_CTW_IMAX] and 
                                                         [AWB_CTW_QMIN to AWB_CTW_QMAX]                                        */
      __IO uint32_t  AWB_CTW1_YMIN:  8;             /*!< (null)                                                                */
      __IO uint32_t  AWB_CTW1_IMAX:  7;             /*!< (null)                                                                */
           uint32_t             :  1;
      __IO uint32_t  AWB_CTW1_QMAX:  7;             /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0178;                      /*!< AWB_SIDE_LC                                                           */
    
    struct {
      __IO uint32_t  AWB_SIDE_LC:  8;               /*!< Threshold for L left side                                             */
      __IO uint32_t  AWB_SIDE_LG:  1;               /*!< Sign bit:0:1 1:-1                                                     */
           uint32_t             :  7;
      __IO uint32_t  AWB_SIDE_LS:  9;               /*!< Slope for L left side                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x017C;                      /*!< AWB_SIDE_RC                                                           */
    
    struct {
      __IO uint32_t  AWB_SIDE_RC:  8;               /*!< Threshold for L left side                                             */
      __IO uint32_t  AWB_SIDE_RG:  1;               /*!< Sign bit:0:1 1:-1                                                     */
           uint32_t             :  7;
      __IO uint32_t  AWB_SIDE_RS:  9;               /*!< Slope for L left side                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0180;                      /*!< VLDC_EN                                                               */
    
    struct {
      __IO uint32_t  VLDC_EN    :  1;               /*!< VLDC Enable (RGB VLDC)                                                */
      __IO uint32_t  VLDC_NTSEL :  2;               /*!< VLDC_NTSEL: output DSTB type , 0:1T, 1:2T                             */
           uint32_t             :  5;
      __IO uint32_t  VLDC_DUMM_BLANK:  8;           /*!< Total number of DUMMY DSTB, unit: 16 pixel                            */
      __IO uint32_t  VLDC_DUMM_START:  8;           /*!< Start blank of DUMMY DSTB, unit: 8 pixel                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0184;                      /*!< VLDC_SW                                                               */
    
    struct {
      __IO uint32_t  VLDC_SW    : 13;               /*!< (null)                                                                */
           uint32_t             :  3;
      __IO uint32_t  VLDC_SH    : 13;               /*!< (null)                                                                */
    };
  };
  __IO uint16_t  VLDC_INVSW;                        /*!< Image_width/640 shift left 4                                          */
  __I  uint16_t  RESERVED11;
  
  union {
    __IO uint32_t  REG_0x018C;                      /*!< VLDC_W0                                                               */
    
    struct {
      __IO uint32_t  VLDC_W0    : 10;               /*!< Distortion parameter                                                  */
           uint32_t             :  6;
      __IO uint32_t  VLDC_W1    : 10;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0190;                      /*!< VLDC_W2                                                               */
    
    struct {
      __IO uint32_t  VLDC_W2    : 10;               /*!< Distortion parameter                                                  */
           uint32_t             :  6;
      __IO uint32_t  VLDC_W3    : 10;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0194;                      /*!< VLDC_W4                                                               */
    
    struct {
      __IO uint32_t  VLDC_W4    : 10;               /*!< Distortion parameter                                                  */
           uint32_t             :  6;
      __IO uint32_t  VLDC_W5    : 10;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0198;                      /*!< VLDC_KMIN                                                             */
    
    struct {
      __IO uint32_t  VLDC_KMIN  :  9;               /*!< Adaptive scaling parameter                                            */
           uint32_t             :  7;
      __IO uint32_t  VLDC_C1    : 10;               /*!< Adaptive scaling parameter 
                                                         (512+W0-KMIN)                                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x019C;                      /*!< VLDC_F0                                                               */
    
    struct {
      __IO uint32_t  VLDC_F0    : 10;               /*!< Focal length (x-direction)                                            */
           uint32_t             :  6;
      __IO uint32_t  VLDC_U0    :  9;               /*!< Principal point x                                                     */
    };
  };
  __I  uint32_t  RESERVED12[2];
  __IO uint8_t   VLDC_Trigger;                      /*!< Write 1 to clear ready flag, and will be auto cleared to 0 by
                                                         next vsync                                                            */
  __I  uint8_t   RESERVED13[3];
  
  union {
    __IO uint32_t  REG_0x01AC;                      /*!< REG_RES0                                                              */
    
    struct {
      __IO uint32_t  REG_RES0   :  8;               /*!< Reserve register0                                                     */
      __IO uint32_t  REG_RES1   :  8;               /*!< Reserve register1                                                     */
      __IO uint32_t  REG_RES2   :  8;               /*!< Reserve register2                                                     */
      __IO uint32_t  REG_RES3   :  8;               /*!< Reserve register31                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x01B0;                      /*!< VLDC_INVF0                                                            */
    
    struct {
      __IO uint32_t  VLDC_INVF0 : 12;               /*!< Inverse focal length (x-deirtection)                                  */
           uint32_t             :  4;
      __IO uint32_t  VLDC_INVF1 : 12;               /*!< Inverse focal length (y-direction)                                    */
    };
  };
  __IO uint32_t  VLDC_INVU0;                        /*!< Inverse principle point x                                             */
  __IO uint32_t  VLDC_INVV0;                        /*!< Inverse principal point y                                             */
  __I  uint32_t  RESERVED14[17];
  
  union {
    __IO uint32_t  REG_0x0200;                      /*!< HSYNC_M                                                               */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  HSYNC_M    :  1;               /*!< CI_CR[1]: HSYNC_M                                                     */
           uint32_t             :  1;
      __IO uint32_t  DO_LL_MODE :  2;               /*!< CI_CR[4:3]: DO_LL_MODE[1:0]: Last Line Mode 
                                                         0x: LL insert/de-assert by HSYNC_O 
                                                         01: LL de-assert by HSYNC_O 
                                                         11: Original mode                                                     */
      __IO uint32_t  DO_BYPASS_MODE:  1;            /*!< CI_CR[5]: Bypass mode 
                                                         0: No bypass valid after last line 
                                                         1: Bypass valid after last line                                       */
      __IO uint32_t  CI_HV_CAL_M:  1;               /*!< CI_CR[6]: 0: Enable HV_CAL(default) 
                                                         1: Disable HV_CAL
                                                         (H/V = Delta_H/V)                                                     */
    };
  };
  __IO uint8_t   CI_THDC;                           /*!< CIThdC                                                                */
  __I  uint8_t   RESERVED15[3];
  __IO uint8_t   CI_THDHV;                          /*!< CIThdHV                                                               */
  __I  uint8_t   RESERVED16[3];
  __IO uint8_t   CI_THDD;                           /*!< CIThdD                                                                */
  __I  uint8_t   RESERVED17[3];
  __IO uint8_t   CI_THDSGH;                         /*!< CIThdSGh                                                              */
  __I  uint8_t   RESERVED18[3];
  __IO uint8_t   CI_SLPSGH;                         /*!< CISlpSGh                                                              */
  __I  uint8_t   RESERVED19[3];
  __IO uint8_t   CI_GRATIOHV;                       /*!< CIRatioHV                                                             */
  __I  uint8_t   RESERVED20[3];
  __IO uint8_t   CI_GRATIOD;                        /*!< CIRatioD                                                              */
  __I  uint8_t   RESERVED21[3];
  __IO uint8_t   CI_GREFSTR;                        /*!< CIRefStr                                                              */
  __I  uint8_t   RESERVED22[3];
  __IO uint8_t   CI_GBWEIGHT;                       /*!< CIGbWeight                                                            */
  __I  uint8_t   RESERVED23[3];
  __IO uint8_t   CI_GRWEIGHT;                       /*!< CIGrWeight                                                            */
  __I  uint8_t   RESERVED24[3];
  
  union {
    __IO uint32_t  REG_0x022C;                      /*!< CI_DE_ALIAS_LV                                                        */
    
    struct {
      __IO uint32_t  CI_DE_ALIAS_LV:  4;            /*!< CI_DE_ALIAS_CR[3:0]: DE_ALIAS_LV                                      */
      __IO uint32_t  CI_DE_ALIAS_MODE0:  1;         /*!< CI_DE_ALIAS_CR[4]: DE_ALIAS_MODE0                                     */
      __IO uint32_t  CI_DE_ALIAS_MODE1:  1;         /*!< CI_DE_ALIAS_CR[5]: DE_ALIAS_MODE1                                     */
           uint32_t             :  1;
      __IO uint32_t  CI_DE_ALIAS_EN:  1;            /*!< CI_DE_ALIAS_CR[7]: DE_ALIAS_EN                                        */
    };
  };
  __IO uint8_t   CI_EDGE_GAIN_THD;                  /*!< Threshold of edge value (CI_THD)                                      */
  __I  uint8_t   RESERVED25[3];
  __IO uint8_t   CI_EDGE_HGAIN;                     /*!< Horizontal edge gain                                                  */
  __I  uint8_t   RESERVED26[3];
  __IO uint8_t   CI_EDGE_VGAIN;                     /*!< Vertical edge gain                                                    */
  __I  uint8_t   RESERVED27[3];
  __IO uint8_t   CI_EDGE_GRADLB;                    /*!< Gradient filter lower bound                                           */
  __I  uint8_t   RESERVED28[3];
  __IO uint8_t   CI_EDGE_HB;                        /*!< Positive edge value limit                                             */
  __I  uint8_t   RESERVED29[3];
  __IO uint8_t   CI_EDGE_LB;                        /*!< Negative edge value limit                                             */
  __I  uint8_t   RESERVED30[3];
  __IO uint8_t   CI_EDGE_THD;                       /*!< Edge threshold                                                        */
  __I  uint8_t   RESERVED31[3];
  __IO uint8_t   CI_EDGE_STR;                       /*!< CI_EDGE_STR                                                           */
  __I  uint8_t   RESERVED32[3];
  __IO uint8_t   CI_EDGE_SLP;                       /*!< CI_EDGE_SLP                                                           */
  __I  uint8_t   RESERVED33[3];
  
  union {
    __IO uint32_t  REG_0x0254;                      /*!< CI_EDGE_MODE                                                          */
    
    struct {
           uint32_t             :  7;
      __IO uint32_t  CI_EDGE_MODE:  1;              /*!< CI_EDGE_CR[7]: EDGE_MODE                                              */
    };
  };
  __I  uint32_t  RESERVED34[7];
  __IO uint8_t   CI_CEDGE_SRG;                      /*!< do not set 0                                                          */
  __I  uint8_t   RESERVED35[3];
  
  union {
    __IO uint32_t  REG_0x0278;                      /*!< CI_CEDGE_RSLC                                                         */
    
    struct {
      __IO uint32_t  CI_CEDGE_RSLC:  2;             /*!< CI_CEDGE_CR[1:0]: CEDGE_RSLC                                          */
      __IO uint32_t  CI_CEDGE_BSLC:  2;             /*!< CI_CEDGE_CR[3:2]: CEDGE_BSLC                                          */
           uint32_t             :  3;
      __IO uint32_t  CI_CEDGE_MODE:  1;             /*!< CI_CEDGE_CR[7]: CEDGE_MODE                                            */
    };
  };
  __I  uint8_t   CI_SR;                             /*!< CI_SR                                                                 */
  __I  uint8_t   RESERVED36[3];
  
  union {
    __IO uint32_t  REG_0x0280;                      /*!< AF_W0_DONE                                                            */
    
    struct {
      __I  uint32_t  AF_W0_DONE :  1;               /*!< AF_CR[0]: AF_W0_DONE                                                  */
      __I  uint32_t  AF_W1_DONE :  1;               /*!< AF_CR[1]: AF_W1_DONE                                                  */
      __IO uint32_t  AF_W0_EN   :  1;               /*!< AF_CR[2]: AF_W0_EN                                                    */
      __IO uint32_t  AF_W1_EN   :  1;               /*!< AF_CR[3]: AF_W1_EN                                                    */
    };
  };
  __IO uint8_t   AF_W0_START_X;                     /*!< AF_W0_START_X smaller than INPUT _SIZE_X/16                           */
  __I  uint8_t   RESERVED37[3];
  __IO uint8_t   AF_W0_START_Y;                     /*!< AF_W0_START_Y smaller than INPUT _SIZE_Y/16                           */
  __I  uint8_t   RESERVED38[3];
  __IO uint8_t   AF_W0_END_X;                       /*!< AF_W0_START_X smaller than AF_W0_END_X and AF_W0_END_X smaller
                                                         than INPUT _SIZE_X/16                                                 */
  __I  uint8_t   RESERVED39[3];
  __IO uint8_t   AF_W0_END_Y;                       /*!< AF_W0_START_Y smaller than AF_W0_END_Y and AF_W0_END_Y smaller
                                                         than INPUT _SIZE_Y/16                                                 */
  __I  uint8_t   RESERVED40[3];
  __IO uint8_t   AF_W0_THD;                         /*!< AF_W0_THD                                                             */
  __I  uint8_t   RESERVED41[3];
  __IO uint8_t   AF_W1_START_X;                     /*!< AF_W1_START_X smaller than INPUT _SIZE_X/16                           */
  __I  uint8_t   RESERVED42[3];
  __IO uint8_t   AF_W1_START_Y;                     /*!< AF_W1_START_Y smaller than INPUT _SIZE_Y/16                           */
  __I  uint8_t   RESERVED43[3];
  __IO uint8_t   AF_W1_END_X;                       /*!< AF_W1_START_X smaller than AF_W1_END_X and AF_W1_END_X smaller
                                                         than INPUT _SIZE_X/16                                                 */
  __I  uint8_t   RESERVED44[3];
  __IO uint8_t   AF_W1_END_Y;                       /*!< AF_W1_START_Y smaller than AF_W1_END_Y and AF_W1_END_Y smaller
                                                         than INPUT _SIZE_Y/16                                                 */
  __I  uint8_t   RESERVED45[3];
  __IO uint8_t   AF_W1_THD;                         /*!< AF_W1_THD                                                             */
  __I  uint8_t   RESERVED46[23];
  __IO uint32_t  AF_W0_SUM;                         /*!< AF_W0_SUM                                                             */
  __IO uint32_t  AF_W1_SUM;                         /*!< AF_W1_SUM                                                             */
  __I  uint32_t  RESERVED47[14];
  
  union {
    __IO uint32_t  REG_0x0300;                      /*!< CI_CEG_EN                                                             */
    
    struct {
           uint32_t             :  7;
      __IO uint32_t  CI_CEG_EN  :  1;               /*!< (null)                                                                */
    };
  };
  __IO uint8_t   CI_CEG_PS;                         /*!< CI_CEG_PS                                                             */
  __I  uint8_t   RESERVED48[3];
  __IO uint8_t   CI_CEG_PC;                         /*!< CI_CEG_PC not less than CI_CEG_PS                                     */
  __I  uint8_t   RESERVED49[3];
  __IO uint8_t   CI_CEG_PC_GAIN;                    /*!< CI_CEG_PC_GAIN                                                        */
  __I  uint8_t   RESERVED50[3];
  __IO uint8_t   CI_CEG_SLP0;                       /*!< CI_CEG_SLP0                                                           */
  __I  uint8_t   RESERVED51[3];
  __IO uint8_t   CI_CEG_SLP1;                       /*!< CI_CEG_SLP1                                                           */
  __I  uint8_t   RESERVED52[3];
  __IO uint8_t   CI_CEG_MVALUE;                     /*!< CI_CEG_MVALUE                                                         */
  __I  uint8_t   RESERVED53[3];
  __IO uint8_t   CI_CEG_SVALUE;                     /*!< CI_CEG_SVALUE                                                         */
  __I  uint8_t   RESERVED54[3];
  __IO uint16_t  CI_CEG_CENTER_X;                   /*!< CI_CEG_CENTER_X                                                       */
  __I  uint16_t  RESERVED55[3];
  __IO uint16_t  CI_CEG_CENTER_Y;                   /*!< CI_CEG_CENTER_Y                                                       */
  __I  uint16_t  RESERVED56[11];
  __IO uint32_t  CI_CEG_SQT_X;                      /*!< CI CEG SQT X                                                          */
  __I  uint32_t  RESERVED57[3];
  __IO uint32_t  CI_CEG_SQT_Y;                      /*!< CI_CEG_SQT_Y                                                          */
  __I  uint32_t  RESERVED58[43];
  __IO uint16_t  F_VALUE_00;                        /*!< 0 F_VALUE                                                             */
  __I  uint16_t  RESERVED59;
  __IO uint16_t  F_VALUE_01;                        /*!< 1 F_VALUE                                                             */
  __I  uint16_t  RESERVED60;
  __IO uint16_t  F_VALUE_02;                        /*!< 2 F_VALUE                                                             */
  __I  uint16_t  RESERVED61;
  __IO uint16_t  F_VALUE_03;                        /*!< 3 F_VALUE                                                             */
  __I  uint16_t  RESERVED62;
  __IO uint16_t  F_VALUE_04;                        /*!< 4 F_VALUE                                                             */
  __I  uint16_t  RESERVED63;
  __IO uint16_t  F_VALUE_05;                        /*!< 5 F_VALUE                                                             */
  __I  uint16_t  RESERVED64;
  __IO uint16_t  F_VALUE_06;                        /*!< 6 F_VALUE                                                             */
  __I  uint16_t  RESERVED65;
  __IO uint16_t  F_VALUE_07;                        /*!< 7 F_VALUE                                                             */
  __I  uint16_t  RESERVED66;
  __IO uint16_t  F_VALUE_08;                        /*!< 8 F_VALUE                                                             */
  __I  uint16_t  RESERVED67;
  __IO uint16_t  F_VALUE_09;                        /*!< 9 F_VALUE                                                             */
  __I  uint16_t  RESERVED68;
  __IO uint16_t  F_VALUE_0A;                        /*!< 10 F_VALUE                                                            */
  __I  uint16_t  RESERVED69;
  __IO uint16_t  F_VALUE_0B;                        /*!< 11 F_VALUE                                                            */
  __I  uint16_t  RESERVED70;
  __IO uint16_t  F_VALUE_0C;                        /*!< 12 F_VALUE                                                            */
  __I  uint16_t  RESERVED71;
  __IO uint16_t  F_VALUE_0D;                        /*!< 13 F_VALUE                                                            */
  __I  uint16_t  RESERVED72;
  __IO uint16_t  F_VALUE_0E;                        /*!< 14 F_VALUE                                                            */
  __I  uint16_t  RESERVED73;
  __IO uint16_t  F_VALUE_0F;                        /*!< 15 F_VALUE                                                            */
  __I  uint16_t  RESERVED74;
  __IO uint16_t  F_VALUE_10;                        /*!< 16 F_VALUE                                                            */
  __I  uint16_t  RESERVED75;
  __IO uint16_t  F_VALUE_11;                        /*!< 17 F_VALUE                                                            */
  __I  uint16_t  RESERVED76;
  __IO uint16_t  F_VALUE_12;                        /*!< 18 F_VALUE                                                            */
  __I  uint16_t  RESERVED77;
  __IO uint16_t  F_VALUE_13;                        /*!< 19 F_VALUE                                                            */
  __I  uint16_t  RESERVED78;
  __IO uint16_t  F_VALUE_14;                        /*!< 20 F_VALUE                                                            */
  __I  uint16_t  RESERVED79;
  __IO uint16_t  F_VALUE_15;                        /*!< 21 F_VALUE                                                            */
  __I  uint16_t  RESERVED80;
  __IO uint16_t  F_VALUE_16;                        /*!< 22 F_VALUE                                                            */
  __I  uint16_t  RESERVED81;
  __IO uint16_t  F_VALUE_17;                        /*!< 23 F_VALUE                                                            */
  __I  uint16_t  RESERVED82;
  __IO uint16_t  F_VALUE_18;                        /*!< 24 F_VALUE                                                            */
  __I  uint16_t  RESERVED83;
  __IO uint16_t  F_VALUE_19;                        /*!< 25 F_VALUE                                                            */
  __I  uint16_t  RESERVED84;
  __IO uint16_t  F_VALUE_1A;                        /*!< 26 F_VALUE                                                            */
  __I  uint16_t  RESERVED85;
  __IO uint16_t  F_VALUE_1B;                        /*!< 27 F_VALUE                                                            */
  __I  uint16_t  RESERVED86;
  __IO uint16_t  F_VALUE_1C;                        /*!< 28 F_VALUE                                                            */
  __I  uint16_t  RESERVED87;
  __IO uint16_t  F_VALUE_1D;                        /*!< 29 F_VALUE                                                            */
  __I  uint16_t  RESERVED88;
  __IO uint16_t  F_VALUE_1E;                        /*!< 30 F_VALUE                                                            */
  __I  uint16_t  RESERVED89;
  __IO uint16_t  F_VALUE_1F;                        /*!< 31 F_VALUE                                                            */
  __I  uint16_t  RESERVED90;
  __IO uint8_t   BOX_W;                             /*!< Box width, Bgw2                                                       */
  __I  uint8_t   RESERVED91[3];
  __IO uint8_t   BOX_H;                             /*!< Box high, Bgh2                                                        */
  __I  uint8_t   RESERVED92[3];
  __IO uint8_t   BOX_SCOOR_X;                       /*!< Box Start Coordinate X, Bghsov                                        */
  __I  uint8_t   RESERVED93[3];
  __IO uint8_t   BOX_SCOOR_Y;                       /*!< Box Start Coordinate Y, Bgvsov                                        */
  __I  uint8_t   RESERVED94[3];
  __IO uint8_t   BOX_NUM_X;                         /*!< Box number X-1(0~15: 1~16)                                            */
  __I  uint8_t   RESERVED95[3];
  __IO uint8_t   BOX_NUM_Y;                         /*!< Box number Y-1(0:15: 1~16)                                            */
  __I  uint8_t   RESERVED96[3];
  __IO uint16_t  BOX_DIS_X;                         /*!< Box distance X, Bgho                                                  */
  __I  uint16_t  RESERVED97;
  __IO uint16_t  BOX_DIS_Y;                         /*!< Box distance Y, Bgvo                                                  */
  __I  uint16_t  RESERVED98;
  __IO uint16_t  BOX_OL_X;                          /*!< Box Overlap X, Bghol                                                  */
  __I  uint16_t  RESERVED99;
  __IO uint16_t  BOX_OL_Y;                          /*!< Box Overlap Y, Bgvol                                                  */
  __I  uint16_t  RESERVED100;
  __IO uint16_t  DIS_X_POWN1;                       /*!< BOX_DIS_X ^ -1, BglPmultiplierH                                       */
  __I  uint16_t  RESERVED101;
  __IO uint16_t  DIS_Y_POWN1;                       /*!< BOX_DIS_Y ^ -1, BglPmultiplierV                                       */
  __I  uint16_t  RESERVED102;
  __IO uint16_t  DELTA_X_1ST;                       /*!< Delta X first value                                                   */
  __I  uint16_t  RESERVED103;
  __IO uint16_t  DELTA_Y_1ST;                       /*!< Delta Y first value                                                   */
  __I  uint16_t  RESERVED104;
  __IO uint8_t   AVEBG;                             /*!< Total number of average background                                    */
  __I  uint8_t   RESERVED105[3];
  __IO uint8_t   AE_GAIN_RATIO;                     /*!< Group 3                                                               */
  __I  uint8_t   RESERVED106[3];
  
  union {
    __IO uint32_t  REG_0x04C0;                      /*!< F_SPLIT_0                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_0:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_0  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04C4;                      /*!< F_SPLIT_1                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_1:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_1  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04C8;                      /*!< F_SPLIT_2                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_2:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_2  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04CC;                      /*!< F_SPLIT_3                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_3:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_3  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04D0;                      /*!< F_SPLIT_4                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_4:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_4  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04D4;                      /*!< F_SPLIT_5                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_5:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_5  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04D8;                      /*!< F_SPLIT_6                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_6:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_6  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04DC;                      /*!< F_SPLIT_7                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_7:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_7  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04E0;                      /*!< F_SPLIT_8                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_8:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_8  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04E4;                      /*!< F_SPLIT_9                                                             */
    
    struct {
      __IO uint32_t  F_START_IDX_9:  5;             /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_9  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04E8;                      /*!< F_SPLIT_10                                                            */
    
    struct {
      __IO uint32_t  F_START_IDX_10:  5;            /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_10 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04EC;                      /*!< F_SPLIT_11                                                            */
    
    struct {
      __IO uint32_t  F_START_IDX_11:  5;            /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_11 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04F0;                      /*!< F_SPLIT_12                                                            */
    
    struct {
      __IO uint32_t  F_START_IDX_12:  5;            /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_12 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04F4;                      /*!< F_SPLIT_13                                                            */
    
    struct {
      __IO uint32_t  F_START_IDX_13:  5;            /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_13 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04F8;                      /*!< F_SPLIT_14                                                            */
    
    struct {
      __IO uint32_t  F_START_IDX_14:  5;            /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_14 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x04FC;                      /*!< F_SPLIT_15                                                            */
    
    struct {
      __IO uint32_t  F_START_IDX_15:  5;            /*!< 16 Start index                                                        */
           uint32_t             :  3;
      __IO uint32_t  F_SPLIT_15 :  2;               /*!< 16 Splits                                                             */
    };
  };
  __IO uint16_t  G_VALUE_00;                        /*!< G_VALUE_0                                                             */
  __I  uint16_t  RESERVED107;
  __IO uint16_t  G_VALUE_01;                        /*!< G_VALUE_1                                                             */
  __I  uint16_t  RESERVED108;
  __IO uint16_t  G_VALUE_02;                        /*!< G_VALUE_2                                                             */
  __I  uint16_t  RESERVED109;
  __IO uint16_t  G_VALUE_03;                        /*!< G_VALUE_3                                                             */
  __I  uint16_t  RESERVED110;
  __IO uint16_t  G_VALUE_04;                        /*!< G_VALUE_4                                                             */
  __I  uint16_t  RESERVED111;
  __IO uint16_t  G_VALUE_05;                        /*!< G_VALUE_5                                                             */
  __I  uint16_t  RESERVED112;
  __IO uint16_t  G_VALUE_06;                        /*!< G_VALUE_6                                                             */
  __I  uint16_t  RESERVED113;
  __IO uint16_t  G_VALUE_07;                        /*!< G_VALUE_7                                                             */
  __I  uint16_t  RESERVED114;
  __IO uint16_t  G_VALUE_08;                        /*!< G_VALUE_8                                                             */
  __I  uint16_t  RESERVED115;
  __IO uint16_t  G_VALUE_09;                        /*!< G_VALUE_9                                                             */
  __I  uint16_t  RESERVED116;
  __IO uint16_t  G_VALUE_0A;                        /*!< G_VALUE_10                                                            */
  __I  uint16_t  RESERVED117;
  __IO uint16_t  G_VALUE_0B;                        /*!< G_VALUE_11                                                            */
  __I  uint16_t  RESERVED118;
  __IO uint16_t  G_VALUE_0C;                        /*!< G_VALUE_12                                                            */
  __I  uint16_t  RESERVED119;
  __IO uint16_t  G_VALUE_0D;                        /*!< G_VALUE_13                                                            */
  __I  uint16_t  RESERVED120;
  __IO uint16_t  G_VALUE_0E;                        /*!< G_VALUE_14                                                            */
  __I  uint16_t  RESERVED121;
  __IO uint16_t  G_VALUE_0F;                        /*!< G_VALUE_15                                                            */
  __I  uint16_t  RESERVED122;
  __IO uint16_t  G_VALUE_10;                        /*!< G_VALUE_16                                                            */
  __I  uint16_t  RESERVED123;
  __IO uint16_t  G_VALUE_11;                        /*!< G_VALUE_17                                                            */
  __I  uint16_t  RESERVED124;
  __IO uint16_t  G_VALUE_12;                        /*!< G_VALUE_18                                                            */
  __I  uint16_t  RESERVED125;
  __IO uint16_t  G_VALUE_13;                        /*!< G_VALUE_19                                                            */
  __I  uint16_t  RESERVED126;
  __IO uint16_t  G_VALUE_14;                        /*!< G_VALUE_20                                                            */
  __I  uint16_t  RESERVED127;
  __IO uint16_t  G_VALUE_15;                        /*!< G_VALUE_21                                                            */
  __I  uint16_t  RESERVED128;
  __IO uint16_t  G_VALUE_16;                        /*!< G_VALUE_22                                                            */
  __I  uint16_t  RESERVED129;
  __IO uint16_t  G_VALUE_17;                        /*!< G_VALUE_23                                                            */
  __I  uint16_t  RESERVED130;
  __IO uint16_t  G_VALUE_18;                        /*!< G_VALUE_24                                                            */
  __I  uint16_t  RESERVED131;
  __IO uint16_t  G_VALUE_19;                        /*!< G_VALUE_25                                                            */
  __I  uint16_t  RESERVED132;
  __IO uint16_t  G_VALUE_1A;                        /*!< G_VALUE_26                                                            */
  __I  uint16_t  RESERVED133;
  __IO uint16_t  G_VALUE_1B;                        /*!< G_VALUE_27                                                            */
  __I  uint16_t  RESERVED134;
  __IO uint16_t  G_VALUE_1C;                        /*!< G_VALUE_28                                                            */
  __I  uint16_t  RESERVED135;
  __IO uint16_t  G_VALUE_1D;                        /*!< G_VALUE_29                                                            */
  __I  uint16_t  RESERVED136;
  __IO uint16_t  G_VALUE_1E;                        /*!< G_VALUE_30                                                            */
  __I  uint16_t  RESERVED137;
  __IO uint16_t  G_VALUE_1F;                        /*!< G_VALUE_31                                                            */
  __I  uint16_t  RESERVED138;
  __IO uint16_t  G_VALUE_20;                        /*!< G_VALUE_32                                                            */
  __I  uint16_t  RESERVED139[11];
  
  union {
    __IO uint32_t  REG_0x0598;                      /*!< TRIGGER                                                               */
    
    struct {
      __IO uint32_t  TRIGGER0   :  1;               /*!< load DRC0 (BOX)                                                       */
      __IO uint32_t  TRIGGER1   :  1;               /*!< load DRC1 (F Table)                                                   */
      __IO uint32_t  TRIGGER2   :  1;               /*!< load DRC2 (G Table)                                                   */
      __IO uint32_t  TRIGGER3   :  1;               /*!< load DRC_EN, AE_GAIN_RATIO, INTENSITY_VAR                             */
    };
  };
  __I  uint32_t  RESERVED140;
  __IO uint16_t  DARK_AMP_LMT;                      /*!< DARK_AMP_LMT                                                          */
  __I  uint16_t  RESERVED141;
  __IO uint16_t  BRIGHT_AMP_LMT;                    /*!< BRIGHT_AMP_LMT                                                        */
  __I  uint16_t  RESERVED142;
  __IO uint8_t   INTENSITY_VAR;                     /*!< INTENSITY_VAR                                                         */
  __I  uint8_t   RESERVED143[3];
  __IO uint16_t  DRC_CR;                            /*!< DRC_CR[15]: DRC_EN 
                                                         DRC_CR[0]: D2I_MODE 
                                                         0: MAX 
                                                         1: Average 
                                                         DRC_CR[8]: AUTO_DUMMY_DIS 
                                                         0: Enable 
                                                         1: Disable 
                                                         DRC_CR[9]: DO_LL_MODE 
                                                         0: DO_LAST_LINE de-assert by HSYNC_O 
                                                         1: DO_LAST_LINE is the original one 
                                                                                                                               */
  __I  uint16_t  RESERVED144;
  __IO uint16_t  Q1GAIN;                            /*!< Polynomial Q1 gain                                                    */
  __I  uint16_t  RESERVED145;
  __IO uint16_t  Q2GAIN;                            /*!< Polynomial Q2 gain                                                    */
  __I  uint16_t  RESERVED146;
  __IO uint16_t  Q3GAIN;                            /*!< Polynomial Q3 gain                                                    */
  __I  uint16_t  RESERVED147;
  __IO uint16_t  Q4GAIN;                            /*!< Polynomial Q4 gain                                                    */
  __I  uint16_t  RESERVED148;
  
  union {
    __IO uint32_t  REG_0x05C0;                      /*!< G_SPLIT_0                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_0:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_0  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05C4;                      /*!< G_SPLIT_1                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_1:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_1  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05C8;                      /*!< G_SPLIT_2                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_2:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_2  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05CC;                      /*!< G_SPLIT_3                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_3:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_3  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05D0;                      /*!< G_SPLIT_4                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_4:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_4  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05D4;                      /*!< G_SPLIT_5                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_5:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_5  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05D8;                      /*!< G_SPLIT_6                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_6:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_6  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05DC;                      /*!< G_SPLIT_7                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_7:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_7  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05E0;                      /*!< G_SPLIT_8                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_8:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_8  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05E4;                      /*!< G_SPLIT_9                                                             */
    
    struct {
      __IO uint32_t  G_START_IDX_9:  6;             /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_9  :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05E8;                      /*!< G_SPLIT_10                                                            */
    
    struct {
      __IO uint32_t  G_START_IDX_10:  6;            /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_10 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05EC;                      /*!< G_SPLIT_11                                                            */
    
    struct {
      __IO uint32_t  G_START_IDX_11:  6;            /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_11 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05F0;                      /*!< G_SPLIT_12                                                            */
    
    struct {
      __IO uint32_t  G_START_IDX_12:  6;            /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_12 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05F4;                      /*!< G_SPLIT_13                                                            */
    
    struct {
      __IO uint32_t  G_START_IDX_13:  6;            /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_13 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05F8;                      /*!< G_SPLIT_14                                                            */
    
    struct {
      __IO uint32_t  G_START_IDX_14:  6;            /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_14 :  2;               /*!< 16 Splits                                                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x05FC;                      /*!< G_SPLIT_15                                                            */
    
    struct {
      __IO uint32_t  G_START_IDX_15:  6;            /*!< 16 Start index                                                        */
           uint32_t             :  2;
      __IO uint32_t  G_SPLIT_15 :  2;               /*!< 16 Splits                                                             */
    };
  };
  __I  uint32_t  RESERVED149[64];
  
  union {
    __IO uint32_t  REG_0x0700;                      /*!< SRCSEL                                                                */
    
    struct {
      __IO uint32_t  SRCSEL     :  2;               /*!< 00: 3DNR, 01: NR, 10: CI, 11: YUV filter                              */
      __IO uint32_t  RBREF      :  1;               /*!< Reference RB: 0 for GG and 1 for RGGB                                 */
      __IO uint32_t  CAL_EN     :  1;               /*!< The CAL_EN is cleared when the start of the vsync.                    */
    };
  };
  __IO uint8_t   WNDSEL;                            /*!< Window Select, only used in AF report                                 */
  __I  uint8_t   RESERVED150[3];
  __IO uint8_t   W0_HBEG;                           /*!< W0 horizontal begin. 16 pixels each unit.                             */
  __I  uint8_t   RESERVED151[3];
  __IO uint8_t   W0_VBEG;                           /*!< W0 vertical begin. 16 pixels each unit.                               */
  __I  uint8_t   RESERVED152[3];
  __IO uint8_t   W0_HSZ;                            /*!< W0 horizontal size. 16 pixels each unit.                              */
  __I  uint8_t   RESERVED153[3];
  __IO uint8_t   W0_VSZ;                            /*!< W0 vertical size. 16 pixels each unit.                                */
  __I  uint8_t   RESERVED154[3];
  __IO uint8_t   WN_HBEG;                           /*!< WN (1~9) horizontal begin. 16 pixels each unit.                       */
  __I  uint8_t   RESERVED155[3];
  __IO uint8_t   WN_VBEG;                           /*!< WN (1~9) vertical begin. 16 pixels each unit                          */
  __I  uint8_t   RESERVED156[3];
  __IO uint8_t   WN_HSZ;                            /*!< WN (1~9) horizontal size. 16 pixels each unit                         */
  __I  uint8_t   RESERVED157[3];
  __IO uint8_t   WN_VSZ;                            /*!< WN (1~9) vertical size. 16 pixels each unit.                          */
  __I  uint8_t   RESERVED158[3];
  __IO uint8_t   WN_HOFF0;                          /*!< WN (1~9) horizontal offset 0. 16 pixels each unit.                    */
  __I  uint8_t   RESERVED159[3];
  __IO uint8_t   WN_HOFF1;                          /*!< WN (1~9) horizontal offset 1. 16 pixels each unit.                    */
  __I  uint8_t   RESERVED160[3];
  __IO uint8_t   WN_VOFF0;                          /*!< WN (1~9) vertical offset 0. 16 pixels each unit                       */
  __I  uint8_t   RESERVED161[3];
  __IO uint8_t   WN_VOFF1;                          /*!< WN (1~9) vertical offset 1. 16 pixels each unit                       */
  __I  uint8_t   RESERVED162[7];
  __IO uint8_t   FIRSEL;                            /*!< FIR select                                                            */
  __I  uint8_t   RESERVED163[3];
  
  union {
    __IO uint32_t  REG_0x0740;                      /*!< FIRCOEF_0                                                             */
    
    struct {
      __IO uint32_t  FIRCOEF_0  :  7;               /*!< FIR coefficient 0[2:0]                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0744;                      /*!< FIRCOEF_1                                                             */
    
    struct {
      __IO uint32_t  FIRCOEF_1  :  7;               /*!< FIR coefficient 1[2:0]                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0748;                      /*!< FIRCOEF_2                                                             */
    
    struct {
      __IO uint32_t  FIRCOEF_2  :  7;               /*!< FIR coefficient 2[2:0]                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x074C;                      /*!< FIRCOEF_3                                                             */
    
    struct {
      __IO uint32_t  FIRCOEF_3  :  7;               /*!< FIR coefficient 3[2:0]                                                */
    };
  };
  __IO uint8_t   FIRREV_R;                          /*!< FIR reverse                                                           */
  __I  uint8_t   RESERVED164[3];
  __IO uint8_t   SH;                                /*!< Shift                                                                 */
  __I  uint8_t   RESERVED165[3];
  __IO uint8_t   THD;                               /*!< Threshold                                                             */
  __I  uint8_t   RESERVED166[3];
  
  union {
    __IO uint32_t  REG_0x075C;                      /*!< W0_RPT_RDY                                                            */
    
    struct {
      __I  uint32_t  W0_RPT_RDY :  1;               /*!< (null)                                                                */
      __I  uint32_t  WN_RPT_RDY :  1;               /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED167[8];
  __I  uint32_t  REPORT_H1;                         /*!< Report H1                                                             */
  __I  uint32_t  REPORT_H2;                         /*!< Report H2                                                             */
  __I  uint32_t  REPORT_V;                          /*!< Report V                                                              */
  __I  uint32_t  REPORT_SUM;                        /*!< Report Sum                                                            */
  __I  uint32_t  RESERVED168[28];
  __IO uint8_t   NR_CR;                             /*!< 7: NR Enable 
                                                         6: CB_EN (Circle base enable) 
                                                         5: NR_FLAT_WB_EN 
                                                         4: DO_LL_MODE (Last Line Mode) 
                                                         3: DO_EN_MODE (enable mode) 
                                                         1: HSYNC_MODE                                                         */
  __I  uint8_t   RESERVED169[3];
  __IO uint8_t   CB_S;                              /*!< The s value to get dist2 for CBNR                                     */
  __I  uint8_t   RESERVED170[3];
  __IO uint8_t   CB_M;                              /*!< The m value to get dist2 for CBNR                                     */
  __I  uint8_t   RESERVED171[7];
  __IO uint16_t  CB_CX;                             /*!< Center X, for CBNR                                                    */
  __I  uint16_t  RESERVED172;
  __IO uint16_t  CB_CY;                             /*!< Center Y, for CBNR                                                    */
  __I  uint16_t  RESERVED173;
  __IO uint32_t  CB_DX_SQU_1ST;                     /*!< 32-bit: DX_SQU_1ST[31:0]                                              */
  __I  uint32_t  RESERVED174;
  __IO uint32_t  CB_DY_SQU_1ST;                     /*!< 32-bit: DY_SQU_1ST[31:0]                                              */
  __I  uint32_t  RESERVED175;
  __IO uint8_t   CB_PC1;                            /*!< 1st control point for CBNR                                            */
  __I  uint8_t   RESERVED176[3];
  __IO uint8_t   CB_PC2;                            /*!< 2nd control point for CBNR                                            */
  __I  uint8_t   RESERVED177[3];
  __IO uint16_t  CB_EO0;                            /*!< High bound of edge gain for CBNR                                      */
  __I  uint16_t  RESERVED178;
  __IO uint16_t  CB_EO1;                            /*!< Edge gain of PC1 for CBNR                                             */
  __I  uint16_t  RESERVED179;
  __IO uint16_t  CB_EO2;                            /*!< Low bound of edge gain for CBNR                                       */
  __I  uint16_t  RESERVED180;
  __IO uint16_t  CB_H2O0;                           /*!< High bound of H2 gain for CBNR                                        */
  __I  uint16_t  RESERVED181;
  __IO uint16_t  CB_H2O1;                           /*!< H2 gain of PC for CBNR                                                */
  __I  uint16_t  RESERVED182;
  __IO uint16_t  CB_H2O2;                           /*!< Low bound of H2 gain for CBNR                                         */
  __I  uint16_t  RESERVED183;
  __IO uint16_t  CB_ES0;                            /*!< Edge gain slope for left of PC1 to present a negative slope
                                                         for CBNR                                                              */
  __I  uint16_t  RESERVED184;
  __IO uint16_t  CB_ES1;                            /*!< Edge gain slope for right of PC1 to present a negative slope
                                                         for CBNR                                                              */
  __I  uint16_t  RESERVED185;
  __IO uint16_t  CB_H2S0;                           /*!< H2 gain slope for left of PC1 to present a negative slope for
                                                         CBNR                                                                  */
  __I  uint16_t  RESERVED186;
  __IO uint16_t  CB_H2S1;                           /*!< H2 gain slope for right of PC1 to present a negative slope for
                                                         CBNR                                                                  */
  __I  uint16_t  RESERVED187;
  __IO uint16_t  GL2E_PC1;                          /*!< 1st control point for gain of level to edge(gL2E in short)            */
  __I  uint16_t  RESERVED188;
  __IO uint16_t  GL2E_PC2;                          /*!< 2nd control point for gL2E                                            */
  __I  uint16_t  RESERVED189;
  __IO uint16_t  GL2E_PC3;                          /*!< 3rd control point for gL2E                                            */
  __I  uint16_t  RESERVED190;
  __IO uint16_t  GL2H2_PC1;                         /*!< 1st control point for gain of level to H2 (gL2H2 in short)            */
  __I  uint16_t  RESERVED191;
  __IO uint16_t  GL2H2_PC2;                         /*!< 2nd control point for gL2H2                                           */
  __I  uint16_t  RESERVED192;
  __IO uint16_t  GL2H2_PC3;                         /*!< 3rd control point for gL2H2                                           */
  __I  uint16_t  RESERVED193;
  __IO uint8_t   GL2E_S0;                           /*!< 0th slope for gL2E                                                    */
  __I  uint8_t   RESERVED194[3];
  __IO uint8_t   GL2E_S1;                           /*!< 1th slope for gL2E                                                    */
  __I  uint8_t   RESERVED195[3];
  __IO uint8_t   GL2E_S2;                           /*!< 2nd slope for gL2E                                                    */
  __I  uint8_t   RESERVED196[3];
  __IO uint8_t   GL2E_S3;                           /*!< 3th slope for gL2E                                                    */
  __I  uint8_t   RESERVED197[3];
  __IO uint16_t  GL2H2_S0;                          /*!< 0th slope for gL2H2                                                   */
  __I  uint16_t  RESERVED198;
  __IO uint16_t  GL2H2_S1;                          /*!< 1st slope for gL2H2                                                   */
  __I  uint16_t  RESERVED199;
  __IO uint16_t  GL2H2_S2;                          /*!< 2nd slope for gL2H2                                                   */
  __I  uint16_t  RESERVED200;
  __IO uint16_t  GL2H2_S3;                          /*!< 3th slope for gL2H2                                                   */
  __I  uint16_t  RESERVED201;
  __IO uint8_t   GL2E_O0;                           /*!< 0th offset for gL2E                                                   */
  __I  uint8_t   RESERVED202[3];
  __IO uint8_t   GL2E_O1;                           /*!< 1st offset for gL2E                                                   */
  __I  uint8_t   RESERVED203[3];
  __IO uint8_t   GL2E_O3;                           /*!< 3rd offset for gL2E                                                   */
  __I  uint8_t   RESERVED204[3];
  __IO uint8_t   GL2E_O4;                           /*!< 4th offset for gL2E                                                   */
  __I  uint8_t   RESERVED205[3];
  __IO uint8_t   GL2H2_O0;                          /*!< 0th offset for gL2H2                                                  */
  __I  uint8_t   RESERVED206[3];
  __IO uint8_t   GL2H2_O1;                          /*!< 1st offset for gL2H2                                                  */
  __I  uint8_t   RESERVED207[3];
  __IO uint8_t   GL2H2_O3;                          /*!< 3rd offset for gL2H2                                                  */
  __I  uint8_t   RESERVED208[3];
  __IO uint8_t   GL2H2_O4;                          /*!< 4th offset for gL2H2                                                  */
  __I  uint8_t   RESERVED209[3];
  __IO uint16_t  GE2H2_PC1;                         /*!< 1st control point for gain of Edge to H2                              */
  __I  uint16_t  RESERVED210;
  __IO uint16_t  GE2H2_PC2;                         /*!< 2nd control point for gE2H2                                           */
  __I  uint16_t  RESERVED211;
  __IO uint16_t  GE2H2_O0;                          /*!< 0th offset for gE2H2                                                  */
  __I  uint16_t  RESERVED212;
  __IO uint16_t  GE2H2_O1;                          /*!< 1st offset for gE2H2                                                  */
  __I  uint16_t  RESERVED213;
  __IO uint16_t  GE2H2_O2;                          /*!< 2nd offset for gE2H2                                                  */
  __I  uint16_t  RESERVED214;
  __IO uint16_t  GE2H2_S1;                          /*!< 1st slope for gE2H2                                                   */
  __I  uint16_t  RESERVED215;
  __IO uint16_t  GE2H2_S2;                          /*!< 2nd slope for gE2H2                                                   */
  __I  uint16_t  RESERVED216;
  __IO uint8_t   CC_INIT;                           /*!< Initial threshold to be candidate in edge mode                        */
  __I  uint8_t   RESERVED217[3];
  __IO uint8_t   CC_SLP;                            /*!< Threshold slope to be a candidate in edge mode                        */
  __I  uint8_t   RESERVED218[3];
  __IO uint8_t   CC_OFFLIMIT;                       /*!< Offset limit for threshold to be a candidate in edge mode, 
                                                         But cc_init + cc_offlimit never larger than 255                       */
  __I  uint8_t   RESERVED219[3];
  __IO uint8_t   NS_SLP_B;                          /*!< SAD slope of noise for B channel                                      */
  __I  uint8_t   RESERVED220[3];
  __IO uint8_t   NS_SLP_G;                          /*!< SAD slope of noise for G channel                                      */
  __I  uint8_t   RESERVED221[3];
  __IO uint8_t   NS_SLP_R;                          /*!< SAD slope of noise for R channel                                      */
  __I  uint8_t   RESERVED222[3];
  __IO uint8_t   NS_OFF_B;                          /*!< SAD offset of noise for B channel                                     */
  __I  uint8_t   RESERVED223[3];
  __IO uint8_t   NS_OFF_G;                          /*!< SAD offset of noise for G channel                                     */
  __I  uint8_t   RESERVED224[3];
  __IO uint8_t   NS_OFF_R;                          /*!< SAD offset of noise for R channel                                     */
  __I  uint8_t   RESERVED225[3];
  __IO uint8_t   BD_THD;                            /*!< Threshold to be a candidate in flat mode for extended weighting       */
  __I  uint8_t   RESERVED226[3];
  __IO uint8_t   W_PC1;                             /*!< 1st control point for weighting gain                                  */
  __I  uint8_t   RESERVED227[3];
  __IO uint8_t   W_PC2;                             /*!< 2nd control point for weighting gain                                  */
  __I  uint8_t   RESERVED228[3];
  __IO uint8_t   W_O1;                              /*!< 1st offset for weighting gain                                         */
  __I  uint8_t   RESERVED229[3];
  __IO uint8_t   W_O2;                              /*!< 2nd offset for weighting gain                                         */
  __I  uint8_t   RESERVED230[3];
  __IO uint8_t   W_S0;                              /*!< 0th slope for weighting gain to present a negative slope              */
  __I  uint8_t   RESERVED231[3];
  __IO uint8_t   W_S1;                              /*!< 1st slope for weighting gain to present a negative slope              */
  __I  uint8_t   RESERVED232[3];
  __IO uint8_t   W_S2;                              /*!< 2nd slope for weighting gain to present a negative slope              */
  __I  uint8_t   RESERVED233[3];
  __IO uint8_t   BD_HALFEW;                         /*!< Half extended weighting                                               */
  __I  uint8_t   RESERVED234[3];
  __IO uint16_t  EDGE_THD;                          /*!< Edge threshold for Edge/Flat mode                                     */
  __I  uint16_t  RESERVED235;
  __IO uint16_t  FLAT_SLP_B;                        /*!< B slope for Very-Flat area                                            */
  __I  uint16_t  RESERVED236;
  __IO uint16_t  FLAT_SLP_G;                        /*!< G slope for Very-Flat area                                            */
  __I  uint16_t  RESERVED237;
  __IO uint16_t  FLAT_SLP_R;                        /*!< R slope for Very-Flat area                                            */
  __I  uint16_t  RESERVED238;
  __IO uint8_t   FLAT_GAIN0_B;                      /*!< B gain0 for very-flat area                                            */
  __I  uint8_t   RESERVED239[3];
  __IO uint8_t   FLAT_GAIN0_G;                      /*!< G gain0 for very-flat area                                            */
  __I  uint8_t   RESERVED240[3];
  __IO uint8_t   FLAT_GAIN0_R;                      /*!< R gain0 for very-flat area                                            */
  __I  uint8_t   RESERVED241[3];
  __IO uint8_t   FLAT_GAIN1_B;                      /*!< B gain1 for very-flat area                                            */
  __I  uint8_t   RESERVED242[3];
  __IO uint8_t   FLAT_GAIN1_G;                      /*!< G gain1 for very-flat area                                            */
  __I  uint8_t   RESERVED243[3];
  __IO uint8_t   FLAT_GAIN1_R;                      /*!< R gain1 for very-flat area                                            */
  __I  uint8_t   RESERVED244[3];
  __IO uint8_t   FLAT_GAIN2_B;                      /*!< B gain2 for very-flat area                                            */
  __I  uint8_t   RESERVED245[3];
  __IO uint8_t   FLAT_GAIN2_G;                      /*!< G gain2 for very-flat area                                            */
  __I  uint8_t   RESERVED246[3];
  __IO uint8_t   FLAT_GAIN2_R;                      /*!< R gain2 for very-flat area                                            */
  __I  uint8_t   RESERVED247[3];
  __IO uint16_t  IP_SLP;                            /*!< Interpolation slope for flat/very-flat mode                           */
  __I  uint16_t  RESERVED248;
  __IO uint8_t   IP_LOW;                            /*!< Edge low bound for flat/very-flat mode                                */
  __I  uint8_t   RESERVED249[3];
  __IO uint8_t   IP_HIGH;                           /*!< Edge high bound for flat/very-flat mode                               */
  __I  uint8_t   RESERVED250[3];
  __IO uint8_t   EDGE_OFF_B;                        /*!< Edge offset for Edge value to present a negative value                */
  __I  uint8_t   RESERVED251[3];
  __IO uint8_t   EDGE_OFF_G;                        /*!< Edge offset for Edge value to present a negative value                */
  __I  uint8_t   RESERVED252[3];
  __IO uint8_t   EDGE_OFF_R;                        /*!< Edge offset for Edge value to present a negative value                */
  __I  uint8_t   RESERVED253[3];
  __IO uint8_t   FLAT_AC_RB;                        /*!< R/B ac gain when meet very-flat area                                  */
  __I  uint8_t   RESERVED254[3];
  __IO uint8_t   FLAT_AC_G;                         /*!< Gb/Gr ac gain when meet very-flat area                                */
  __I  uint8_t   RESERVED255[3];
  __IO uint8_t   AJ_EDGE_THD;                       /*!< Edge threshold for anti-jaggy                                         */
  __I  uint8_t   RESERVED256[3];
  __IO uint8_t   AJ_WEIGHT_THD;                     /*!< Weight threshold for anti-jaggy                                       */
  __I  uint8_t   RESERVED257[3];
  __IO uint8_t   W_SFT0;                            /*!< W_s0~2 Q-format specification: 
                                                         Q2.5 if 0, Q3.4 if 1 
                                                         Q4.3 if 2, Q5.2 if 3                                                  */
  __I  uint8_t   RESERVED258[3];
  __IO uint8_t   W_SFT1;                            /*!< W_SFT1                                                                */
  __I  uint8_t   RESERVED259[3];
  __IO uint8_t   W_SFT2;                            /*!< W_SFT2                                                                */
  __I  uint8_t   RESERVED260[3];
  
  union {
    __IO uint32_t  REG_0x097C;                      /*!< CNLM_EN                                                               */
    
    struct {
      __IO uint32_t  CNLM_EN    :  1;               /*!< CNLM_CR 
                                                         Bit 0: CNLM_EN 
                                                         Bit 1: EDM_EN Bit 2: EDM_MODE                                         */
      __IO uint32_t  EDM_EN     :  1;               /*!< (null)                                                                */
      __IO uint32_t  EDM_MODE   :  1;               /*!< (null)                                                                */
    };
  };
  __IO uint8_t   DBG_MODE;                          /*!< Debug Mode 
                                                         0: RNRout (Raw NR output) 
                                                         1: NR_FLAT? 0 : RNRout 
                                                         2: EDGE_MAX 
                                                         3: NR_FLAT? 0 : EDGE_MAX 
                                                         4: Weight_delta 
                                                         5: NR_FLAT? 0 : Weight_delta 
                                                         6: level between R_HB and R_LB 
                                                         7: edge between R_HB and R_LB 
                                                         8: edge bigger than edgethd                                           */
  __I  uint8_t   RESERVED261[3];
  __IO uint16_t  R_HB;                              /*!< R_HB                                                                  */
  __I  uint16_t  RESERVED262;
  __IO uint16_t  R_LB;                              /*!< R_LB                                                                  */
  __I  uint16_t  RESERVED263;
  __IO uint8_t   USER_HGAIN_EN;                     /*!< USER_HGAIN_EN                                                         */
  __I  uint8_t   RESERVED264[3];
  __IO uint16_t  USER_HGAIN;                        /*!< USER_HGAIN                                                            */
  __I  uint16_t  RESERVED265[23];
  
  union {
    __IO uint32_t  REG_0x09C0;                      /*!< DPC_CR                                                                */
    
    struct {
      __IO uint32_t  DPC_BLK_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  DPC_WHT_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  DPC_CLS_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  DPC_CLS3_EN:  1;               /*!< (null)                                                                */
      __IO uint32_t  DPC_WB_EN  :  1;               /*!< (null)                                                                */
      __IO uint32_t  DPC_MAN_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  DPC_DET_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  ADDR_AUTO_ADD1_EN:  1;         /*!< (null)                                                                */
    };
  };
  __IO uint8_t   DPC_BLK_THD;                       /*!< DPC_BLK_THD                                                           */
  __I  uint8_t   RESERVED266[3];
  __IO uint8_t   DPC_WHT_THD;                       /*!< DPC_WHT_THD                                                           */
  __I  uint8_t   RESERVED267[3];
  __IO uint8_t   DPC_BLK_SLP;                       /*!< DPC_BLK_SLP                                                           */
  __I  uint8_t   RESERVED268[3];
  __IO uint8_t   DPC_WHT_SLP;                       /*!< DPC_WHT_SLP                                                           */
  __I  uint8_t   RESERVED269[3];
  __IO uint8_t   DPC_EDGE_THD;                      /*!< DPC_EDGE_THD                                                          */
  __I  uint8_t   RESERVED270[3];
  __IO uint8_t   DPC_EDGE_GAIN;                     /*!< DPC_EDGE_GAIN                                                         */
  __I  uint8_t   RESERVED271[3];
  __O  uint32_t  TRIGGER_PULSE;                     /*!< 0: Trigger for DPC (0x9060_09c4~0x9060_09d8) 
                                                         1: Trigger for DPC_DET_EN(0x9060_09c0[6]) 
                                                         3: Trigger for DPC_BLK_EN, DPC_WHT_EN, NR_EN, and GBAL_EN             */
  __IO uint8_t   GBAL_CR;                           /*!< 0: GBAL_EN (GbGr_en, 1: Enable, 0: Disable)                           */
  __I  uint8_t   RESERVED272[3];
  __IO uint8_t   GBAL_THD_L;                        /*!< Adaptive edge threshold low bound, smaller keeps the edge strong      */
  __I  uint8_t   RESERVED273[3];
  __IO uint8_t   GBAL_THD_H;                        /*!< Adaptive edge threshold high bound, smaller keeps the edge strong     */
  __I  uint8_t   RESERVED274[3];
  __IO uint8_t   GBAL_THD_SLP;                      /*!< Adaptive edge threshold slope, smaller keeps the edge strong          */
  __I  uint8_t   RESERVED275[3];
  __IO uint8_t   GBAL_WE_SLP;                       /*!< Initial slope of filter coefficient for edge                          */
  __I  uint8_t   RESERVED276[3];
  __IO uint8_t   GBAL_WF_SLP;                       /*!< Initial slope of filter coefficient for flat                          */
  __I  uint8_t   RESERVED277[3];
  __IO uint8_t   GBAL_SLP_GAIN;                     /*!< Gain of slope for adaptive filter coefficient slope                   */
  __I  uint8_t   RESERVED278[7];
  __IO uint32_t  DPC_TABLE;                         /*!< Data length from 19~31bit                                             */
  __I  uint16_t  DPC_SCOUNT;                        /*!< DPC_SCOUNT                                                            */
  __I  uint16_t  RESERVED279;
  __IO uint8_t   DPC_TABLE_ADDR;                    /*!< DPC_TABLE_ADDR                                                        */
  __I  uint8_t   RESERVED280[3];
  __I  uint8_t   DPC_CONFIGURE0;                    /*!< Value = DPC data length(9~14)                                         */
  __I  uint8_t   RESERVED281[3];
  __I  uint8_t   DPC_CONFIGURE1;                    /*!< Value = {DPC_X_ADDR_LEN, 
                                                         DPC_Y_ADDR_LEN}                                                       */
  __I  uint8_t   RESERVED282[3];
  __I  uint32_t  DPC_CONFIGURE2;                    /*!< Value = DPC Table length                                              */
  __I  uint32_t  RESERVED283[10];
  __IO uint8_t   CGCNR_EN;                          /*!< CGCNR_EN                                                              */
  __I  uint8_t   RESERVED284[3];
  __IO uint8_t   CGCNR_CB_EN;                       /*!< Cycle-base enable for CGC                                             */
  __I  uint8_t   RESERVED285[3];
  __IO uint8_t   CGCNR_CB_PC1;                      /*!< CB_PC1                                                                */
  __I  uint8_t   RESERVED286[3];
  __IO uint8_t   CGCNR_CB_PC2;                      /*!< CGCNR_CB_PC2                                                          */
  __I  uint8_t   RESERVED287[3];
  __IO uint16_t  CGCNR_CB_ES0;                      /*!< CGCNR_CB_ES0                                                          */
  __I  uint16_t  RESERVED288;
  __IO uint16_t  CGCNR_CB_ES1;                      /*!< CGCNR_CB_ES1                                                          */
  __I  uint16_t  RESERVED289;
  __IO uint16_t  CGCNR_CB_EO0;                      /*!< Range ~256                                                            */
  __I  uint16_t  RESERVED290;
  __IO uint16_t  CGCNR_CB_EO1;                      /*!< Range ~256                                                            */
  __I  uint16_t  RESERVED291;
  __IO uint16_t  CGCNR_CB_EO2;                      /*!< Range ~256                                                            */
  __I  uint16_t  RESERVED292;
  __IO uint8_t   CGCNR_THD_OFF_R;                   /*!< CGCNR_THD_OFF_R                                                       */
  __I  uint8_t   RESERVED293[3];
  __IO uint8_t   CGCNR_THD_OFF_G;                   /*!< CGCNR_THD_OFF_G                                                       */
  __I  uint8_t   RESERVED294[3];
  __IO uint8_t   CGCNR_THD_OFF_B;                   /*!< CGCNR_THD_OFF_B                                                       */
  __I  uint8_t   RESERVED295[3];
  __IO uint8_t   CGCNR_THD_SLP_R;                   /*!< CGCNR_THD_SLP_R                                                       */
  __I  uint8_t   RESERVED296[3];
  __IO uint8_t   CGCNR_THD_SLP_G;                   /*!< CGCNR_THD_SLP_G                                                       */
  __I  uint8_t   RESERVED297[3];
  __IO uint8_t   CGCNR_THD_SLP_B;                   /*!< CGCNR_THD_SLP_B                                                       */
  __I  uint8_t   RESERVED298[3];
  __IO uint8_t   CGCNR_THD_OFF_RL;                  /*!< CGCNR_THD_OFF_RL                                                      */
  __I  uint8_t   RESERVED299[3];
  __IO uint8_t   CGCNR_THD_OFF_GL;                  /*!< CGCNR_THD_OFF_GL                                                      */
  __I  uint8_t   RESERVED300[3];
  __IO uint8_t   CGCNR_THD_OFF_BL;                  /*!< CGCNR_THD_OFF_BL                                                      */
  __I  uint8_t   RESERVED301[3];
  __IO uint8_t   CGCNR_THD_SLP_RL;                  /*!< CGCNR_THD_SLP_RL                                                      */
  __I  uint8_t   RESERVED302[3];
  __IO uint8_t   CGCNR_THD_SLP_GL;                  /*!< CGCNR_THD_SLP_GL                                                      */
  __I  uint8_t   RESERVED303[3];
  __IO uint8_t   CGCNR_THD_SLP_BL;                  /*!< CGCNR_THD_SLP_BL                                                      */
  __I  uint8_t   RESERVED304[3];
  __IO uint8_t   CGCNR_THD_HIGH_R;                  /*!< CGCNR_THD_HIGH_R                                                      */
  __I  uint8_t   RESERVED305[3];
  __IO uint8_t   CGCNR_THD_HIGH_G;                  /*!< CGCNR_THD_HIGH_G                                                      */
  __I  uint8_t   RESERVED306[3];
  __IO uint8_t   CGCNR_THD_HIGH_B;                  /*!< CGCNR_THD_HIGH_B                                                      */
  __I  uint8_t   RESERVED307[3];
  __IO uint8_t   CGCNR_HCNT_MAX;                    /*!< CGCNR_HCNT_MAX                                                        */
  __I  uint8_t   RESERVED308[3];
  __IO uint8_t   CGCNR_VCNT_MAX;                    /*!< CGCNR_VCNT_MAX                                                        */
  __I  uint8_t   RESERVED309[3];
  __IO uint8_t   CGCNR_WEAKNESS;                    /*!< CGCNR_WEAKNESS                                                        */
  __I  uint8_t   RESERVED310[3];
  __IO uint8_t   CGCNR_THD_COMP_G;                  /*!< CGCNR_THD_COMP_G                                                      */
  __I  uint8_t   RESERVED311[851];
  
  union {
    __IO uint32_t  REG_0x0E00;                      /*!< RAW_3DNR_EN                                                           */
    
    struct {
      __IO uint32_t  RAW_3DNR_EN:  1;               /*!< Control 3DNR on or off                                                */
      __IO uint32_t  INT_PRE_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  INT_CUR_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  HPC_PRE_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  HPC_CUR_EN :  1;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_PREV_GAUS:  1;            /*!< Control LPF or not at previous frame                                  */
      __IO uint32_t  NR3D_CURR_GAUS:  1;            /*!< Control LPF or not at current frame                                   */
      __I  uint32_t  NR3D_STATUS:  1;               /*!< Record the status of previous frame                                   */
      __IO uint32_t  NR3D_DEBUG :  1;               /*!< NR3D debug used                                                       */
      __IO uint32_t  NR3D_2DEN  :  1;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_DPC_BLK_EN:  1;           /*!< ON/OFF for block defect pixel compensation. 
                                                         0: OFF. 1: ON.                                                        */
      __IO uint32_t  NR3D_DPC_WHT_EN:  1;           /*!< ON/OFF for white defect pixel compensation. 
                                                         0: OFF, 1: ON                                                         */
      __IO uint32_t  NR3D_DPC_CLS_EN:  1;           /*!< ON/OFF for cluster defect pixel compensation. 
                                                         0: OFF, 1: ON                                                         */
      __IO uint32_t  NR3D_DPC_CLS3_EN:  1;          /*!< ON/OFF for cluster 3 defect pixel compensation 
                                                         0: OFF, 1: ON                                                         */
      __IO uint32_t  NR3D_RAW_DNS_EN:  1;           /*!< ON/OFF for de-noise in bayer pattern. 
                                                         0: OFF, 1: ON                                                         */
      __IO uint32_t  NR3D_RAW_DNS_EWB_EN:  1;       /*!< ON/OFF for edge denoise value write back to SRAM                      */
      __IO uint32_t  NR3D_RAW_DNS_FWB_EN:  1;       /*!< ON/OFF for flat donoise value write back to SRAM                      */
      __IO uint32_t  NR3D_RAW_DNS_MODE:  1;         /*!< 0:powerful donoise, 1: weak but low latency                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E04;                      /*!< HPC_PRE_OFFSET                                                        */
    
    struct {
      __IO uint32_t  HPC_PRE_OFFSET:  8;            /*!< (null)                                                                */
      __IO uint32_t  HPC_PRE_SRG:  5;               /*!< (null)                                                                */
      __IO uint32_t  HPC_CUR_OFFSET:  8;            /*!< (null)                                                                */
      __IO uint32_t  HPC_CUR_SRG:  5;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E08;                      /*!< NR3D_COEF1                                                            */
    
    struct {
      __IO uint32_t  NR3D_COEF1 :  8;               /*!< NR3D_COEF3+NR3D_COEF2*4+NR3D_COEF1*4=1024                             */
      __IO uint32_t  NR3D_COEF2 :  8;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_COEF3 :  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E0C;                      /*!< NR3D_RSLOP0                                                           */
    
    struct {
      __IO uint32_t  NR3D_RSLOP0:  8;               /*!< Slope of R which is small than NR3D_RP                                */
      __IO uint32_t  NR3D_GSLOP0:  8;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_BSLOP0:  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E10;                      /*!< NR3D_RSLOP1                                                           */
    
    struct {
      __IO uint32_t  NR3D_RSLOP1:  8;               /*!< Slope of R which is small than NR3D_RP                                */
      __IO uint32_t  NR3D_GSLOP1:  8;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_BSLOP1:  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E14;                      /*!< NR3D_RP                                                               */
    
    struct {
      __IO uint32_t  NR3D_RP    : 10;               /*!< X coordinates of transition point of R                                */
      __IO uint32_t  NR3D_GP    : 10;               /*!< X coordinates of transition point of G                                */
      __IO uint32_t  NR3D_BP    : 10;               /*!< X coordinates of transition point of B                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E18;                      /*!< NR3D_ROFFSET                                                          */
    
    struct {
      __IO uint32_t  NR3D_ROFFSET: 10;              /*!< Y coordinates of transition point of R                                */
      __IO uint32_t  NR3D_GOFFSET: 10;              /*!< Y coordinates of transition point of G                                */
      __IO uint32_t  NR3D_BOFFSET: 10;              /*!< Y coordinates of transition point of B                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E1C;                      /*!< NR3D_MOTION_HB                                                        */
    
    struct {
      __IO uint32_t  NR3D_MOTION_HB: 12;            /*!< High bound of motion, to control the weighting of current pixel       */
      __IO uint32_t  NR3D_MOTION_LB: 12;            /*!< Low bound of motion, to control the weighting of current pixel        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E20;                      /*!< NR3D_W0                                                               */
    
    struct {
      __IO uint32_t  NR3D_W0    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W1    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W2    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W3    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W4    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W5    :  5;               /*!< The weighting of current frame                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E24;                      /*!< NR3D_W6                                                               */
    
    struct {
      __IO uint32_t  NR3D_W6    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W7    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W8    :  5;               /*!< The weighting of current frame                                        */
      __IO uint32_t  NR3D_W9    :  5;               /*!< The weighting of current frame                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E28;                      /*!< NR3D_2D_W0                                                            */
    
    struct {
      __IO uint32_t  NR3D_2D_W0 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W1 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W2 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W3 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W4 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W5 :  5;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E2C;                      /*!< NR3D_2D_W6                                                            */
    
    struct {
      __IO uint32_t  NR3D_2D_W6 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W7 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W8 :  5;               /*!< (null)                                                                */
      __IO uint32_t  NR3D_2D_W9 :  5;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E30;                      /*!< NR3D_DPC_WHT_THD                                                      */
    
    struct {
      __IO uint32_t  NR3D_DPC_WHT_THD:  8;          /*!< Initial threshold to compare to neighbor for single white defect
                                                         pixel 
                                                         Compensation, less value makes more compensation possibility.
                                                          (unit:2)                                                             */
      __IO uint32_t  NR3D_DPC_BLK_THD:  8;          /*!< Initial threshold to compare to neighbor for single black defect
                                                         pixel 
                                                         Compensation, less value makes more compensation possibility.
                                                          (unit:2)                                                             */
      __IO uint32_t  NR3D_DPC_EDG_THD:  8;          /*!< Threshold of edge value for double defect pixel compensation.
                                                         
                                                         Less value makes less compensation possibility. Unit:2                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E34;                      /*!< NR3D_DPC_BLK_SLOPE                                                    */
    
    struct {
      __IO uint32_t  NR3D_DPC_BLK_SLOPE:  6;        /*!< Blk_Thd = (Lum*DFT_(WHT)BLK_SLOPE)>>6) + DFT_(WHT)BLK_THD             */
      __IO uint32_t  NR3D_DPC_WHT_SLOPE:  6;        /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_YINT:  8;         /*!< Initial threshold of edge value to do de-noise in flat area.
                                                         
                                                         Less value makes less possibility to de-noise.                        */
      __IO uint32_t  NR3D_RAW_DNS_YSLP:  6;         /*!< Threshold slope in lowLux(0~64). Range: (0~63)/16. 
                                                         Less value makes less possibility to de-noise.                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E38;                      /*!< NR3D_RAW_DNS_RB_AC                                                    */
    
    struct {
      __IO uint32_t  NR3D_RAW_DNS_RB_AC:  7;        /*!< R/B AC gain. Range: (0~127)/128                                       */
      __IO uint32_t  NR3D_RAW_DNS_G_AC:  7;         /*!< Gb/Gr AC gain. Range: (0~127)/128                                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E3C;                      /*!< NR3D_RAW_DNS_B_SLOPE                                                  */
    
    struct {
      __IO uint32_t  NR3D_RAW_DNS_B_SLOPE: 10;      /*!< The slope of the coefficient of the B/G/R. 
                                                         Range: 0~1024.                                                        */
      __IO uint32_t  NR3D_RAW_DNS_G_SLOP: 10;       /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_R_SLOPE: 10;      /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E40;                      /*!< NR3D_RAW_DNS_B_GAIN_0                                                 */
    
    struct {
      __IO uint32_t  NR3D_RAW_DNS_B_GAIN_0:  6;     /*!< RAW_DNS_B(G,R)_GAIN0~3, are used to interpolate the suppress
                                                         gain 
                                                         Of RAW_DNS_B(G,R)_SLOPE, which can control the denoise level
                                                          in different luminance value.                                        */
      __IO uint32_t  NR3D_RAW_DNS_B_GAIN_1:  6;     /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_B_GAIN_2:  6;     /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_G_GAIN_0:  6;     /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_G_GAIN_1:  6;     /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x0E44;                      /*!< NR3D_RAW_DNS_G_GAIN_2                                                 */
    
    struct {
      __IO uint32_t  NR3D_RAW_DNS_G_GAIN_2:  6;     /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_R_GAIN_0:  6;     /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_R_GAIN_1:  6;     /*!< (null)                                                                */
      __IO uint32_t  NR3D_RAW_DNS_R_GAIN_2:  6;     /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED312[110];
  
  union {
    __IO uint32_t  REG_0x1000;                      /*!< IMG_FMT                                                               */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  RAW_BP_MODE:  1;               /*!< 0:8 bits RAW bypass mode. 
                                                         1:10 bits RAW bypass mode.                                            */
      __IO uint32_t  RAW_BP_EN  :  1;               /*!< 1:Enable RAW bypass mode.                                             */
      __IO uint32_t  VIDEO_STR_EN_1:  1;            /*!< 1:Enable USB video stream pipe(EP1)                                   */
      __IO uint32_t  STILL_IMG_EN_1:  1;            /*!< Write 1 to transfer a still image (EP1) 
                                                         If the capture action is completed, write 0 to clear this bit
                                                         for the next transaction.                                             */
      __I  uint32_t  STILL_IMG_FLG_1:  1;           /*!< 1:Capture a still image(EP1) 
                                                         This bit is cleared automatically when the capture action is
                                                         completed                                                             */
      __IO uint32_t  VIDEO_STR_EN_2:  1;            /*!< 1:Enable video stream2                                                */
      __IO uint32_t  VIDEO_STR_EN_3:  1;            /*!< 1:Enable video stream3                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1004;                      /*!< MIRROR_FLIP_MODE                                                      */
    
    struct {
      __IO uint32_t  MIRROR_FLIP_MODE:  4;          /*!< [1:0] is for stream1, [3:2] is for stream2                            */
      __IO uint32_t  STR3_IMG_FORMAT:  4;           /*!< ISP stream3 image output format 
                                                         0000: Sonix420 
                                                         0001: Y only 
                                                         0010: YUYV (YUY2) 
                                                         0100: Packed: RGB888 
                                                         0101: Packed: BGR888 
                                                         0110: Packed: RGB565 
                                                         0111: Packed: BGR565 
                                                         1000: Planar: RGB888 
                                                         1001: Planar: BGR888 
                                                         1010: Planar: I420 
                                                         Others: Reserved                                                      */
    };
  };
  __I  uint32_t  RESERVED313[2];
  
  union {
    __IO uint32_t  REG_0x1010;                      /*!< AE_SIZE_X                                                             */
    
    struct {
      __IO uint32_t  AE_SIZE_X  :  7;               /*!< AE sample sampled size after skip for H direction 
                                                         (AE_SIZE_X: 1~85)                                                     */
           uint32_t             :  1;
      __IO uint32_t  AE_SIZE_Y  :  7;               /*!< AE sample sampled size after skip for V direction 
                                                         (AE_SIZE_Y: 1~85).                                                    */
           uint32_t             :  1;
      __IO uint32_t  AE_SKIP_X  :  4;               /*!< AE sample skip value for H direction, must > 1 for correct SRAM
                                                         access. (AE_SKIP_X: 2~15)                                             */
      __IO uint32_t  AE_SKIP_Y  :  4;               /*!< AE sample skip value for V direction 
                                                         (AE_SKIP_Y:1~15)                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1014;                      /*!< AE_SIZE_X                                                             */
    
    struct {
      __IO uint32_t  AE_START_X : 12;               /*!< AE window start value for H direction                                 */
           uint32_t             :  4;
      __IO uint32_t  AE_START_Y : 11;               /*!< AE window start value for V direction                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1018;                      /*!< AE_YHIST                                                              */
    
    struct {
      __I  uint32_t  AE_YHIST   : 16;               /*!< Y histogram array data                                                */
      __IO uint32_t  AE_YHIST_IDX:  5;              /*!< Y histogram array index from 0 to 31, and only used in AE_YHIST       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x101C;                      /*!< AE_YHIST_MODE                                                         */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  AE_YHIST_MODE:  4;             /*!< The index of the table contains the combination of range 4 and
                                                         range 8                                                               */
      __IO uint32_t  AE_PATH_SEL:  2;               /*!< 0: YUV path, 1: RGB path, 2: DRC path                                 */
           uint32_t             :  3;
      __I  uint32_t  AE_RPT_RDY :  1;               /*!< 1:AE report can be read 
                                                         0:not ready                                                           */
           uint32_t             :  1;
      __IO uint32_t  AE_RPT_EN  :  1;               /*!< 1: AE report enable, and clear AE_RPT_RDY                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1020;                      /*!< AE_YREPORT                                                            */
    
    struct {
      __I  uint32_t  AE_YREPORT : 21;               /*!< Y sum report                                                          */
           uint32_t             :  3;
      __IO uint32_t  AE_Y_REPORT_IDX:  4;           /*!< AE Y report section selection from 0 to 8, and only used in
                                                         AE_YREPORT                                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1024;                      /*!< AE_YMAX                                                               */
    
    struct {
      __I  uint32_t  AE_YMAX    :  8;               /*!< Y max value report                                                    */
           uint32_t             :  8;
      __I  uint32_t  AE_YMIN    :  8;               /*!< Y min value report                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1028;                      /*!< AB_RPT_RDY                                                            */
    
    struct {
      __I  uint32_t  AB_RPT_RDY :  1;               /*!< 1: AB report can be read 
                                                         0: not ready                                                          */
           uint32_t             :  1;
      __IO uint32_t  AB_RPT_EN  :  1;               /*!< 1: Auto Banding report enable and clear AB_RRT_RDY                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x102C;                      /*!< AB_SKIP_X                                                             */
    
    struct {
      __IO uint32_t  AB_SKIP_X  :  4;               /*!< Auto banding sample skip value for H direction                        */
           uint32_t             :  4;
      __IO uint32_t  AB_SKIP_Y  :  9;               /*!< Auto banding sample skip value for V direction                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1030;                      /*!< AB_START_X                                                            */
    
    struct {
      __IO uint32_t  AB_START_X : 12;               /*!< Auto banding window start value for H direction                       */
           uint32_t             :  4;
      __IO uint32_t  AB_START_Y : 11;               /*!< Auto banding window start value for V direction                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1034;                      /*!< AB_RPT0                                                               */
    
    struct {
      __I  uint32_t  AB_RPT0    :  8;               /*!< Auto banding report for 1st line                                      */
      __I  uint32_t  AB_RPT1    :  8;               /*!< Auto banding report for 2nd line                                      */
      __I  uint32_t  AB_RPT2    :  8;               /*!< Auto banding report for 3rd line                                      */
      __I  uint32_t  AB_RPT3    :  8;               /*!< Auto banding report for 4th line                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1038;                      /*!< AB_RPT4                                                               */
    
    struct {
      __I  uint32_t  AB_RPT4    :  8;               /*!< Auto banding report for 4th line                                      */
      __I  uint32_t  AB_RPT5    :  8;               /*!< Auto banding report for 5th line                                      */
      __I  uint32_t  AB_RPT6    :  8;               /*!< Auto banding report for 6th line                                      */
      __I  uint32_t  AB_RPT7    :  8;               /*!< Auto banding report for 7th line                                      */
    };
  };
  __I  uint32_t  RESERVED314[2];
  
  union {
    __IO uint32_t  REG_0x1044;                      /*!< AYF_YF_EN                                                             */
    
    struct {
      __IO uint32_t  AYF_YF_EN  :  1;               /*!< 1:enable Y filter, 0:disable Y filter                                 */
      __IO uint32_t  AYF_UVF_EN :  1;               /*!< 1:enable UV filter, 0:disable UV filter                               */
      __IO uint32_t  AYF_YEE_EN :  1;               /*!< 1:enable edge enhancement, 0:disable edge enhancement                 */
      __IO uint32_t  AYF_YF_MODE:  1;               /*!< 1:strong denoise level, 0: weak denoise level                         */
      __IO uint32_t  DSTB_TYPE_SEL:  2;             /*!< YUV Filter dummy line output strobe type 
                                                         3: dummy data strobe produce 1 pulse each 4 cycles. 
                                                         2: dummy data strobe produce 1 pulse each 3 cycles. 
                                                         1: dummy data strobe is toggle signal 
                                                         0: Continuous data strobe strobe                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1048;                      /*!< AYF_YF_SLP                                                            */
    
    struct {
      __IO uint32_t  AYF_YF_SLP :  6;               /*!< The slope of the coefficient of the Y filter.                         */
           uint32_t             :  2;
      __IO uint32_t  AYF_YF_WEIGHT:  4;             /*!< The weight of 2 different direction filter results. Smaller
                                                         value gives weak denoise level.                                       */
           uint32_t             :  4;
      __IO uint32_t  AYF_YF_THD_LB:  3;             /*!< The threshold of Y denoise filter low bound                           */
           uint32_t             :  1;
      __IO uint32_t  AYF_YF_THD_SLP:  4;            /*!< The slope of threshold used in Y denoise filter                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x104C;                      /*!< AYF_YEEB_SRG                                                          */
    
    struct {
      __IO uint32_t  AYF_YEEB_SRG:  4;              /*!< Strength of Yb edge enhancement                                       */
      __IO uint32_t  AYF_YEEM_HGAIN_S0:  4;         /*!< Weight of Ym HGAIN (higher frequence part)                            */
      __IO uint32_t  AYF_YEEM_HGAIN_S1:  4;         /*!< Weight of Ym HGAIN (lower frequence part)                             */
      __IO uint32_t  AYF_YEEM_VGAIN_S0:  4;         /*!< Weight of Ym VGAIN (higher frequence part)                            */
      __IO uint32_t  AYF_YEEM_VGAIN_S1:  4;         /*!< Weight of Ym VGAIN (lower frequence part)                             */
      __IO uint32_t  AYF_YEEM_GAIN_LB:  5;          /*!< Low bound of Ym edge enhancement gain                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1050;                      /*!< AYF_YEEM_HGAIN                                                        */
    
    struct {
      __IO uint32_t  AYF_YEEM_HGAIN:  8;            /*!< Horizontal gain of Ym edge enhancement                                */
      __IO uint32_t  AYF_YEEM_VGAIN:  8;            /*!< Vertical gain of Ym edge enhancement                                  */
      __IO uint32_t  AYF_YEEM_THD:  8;              /*!< Threshold of Ym edge enhancement                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1054;                      /*!< AYF_YEEM_HB                                                           */
    
    struct {
      __IO uint32_t  AYF_YEEM_HB:  8;               /*!< High bound of Ym edge enhancement                                     */
      __IO uint32_t  AYF_YEEM_LB:  8;               /*!< Low bound of Ym edge enhancement                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1058;                      /*!< AYF_YEEM_STR                                                          */
    
    struct {
      __IO uint32_t  AYF_YEEM_STR:  8;              /*!< The edge value output = 
                                                          sign(input)*(YEDGE_STR+(abs(input)-YEDGE_STR)*YEDGE_SLP/8).          */
      __IO uint32_t  AYF_YEEM_SLP:  3;              /*!< (null)                                                                */
    };
  };
  __IO uint16_t  DUMMY_PCK;                         /*!< Dummy pck number in blanking zone of dummy line for YUV filter.
                                                         Unit: 16 pixels.                                                      */
  __I  uint16_t  RESERVED315;
  
  union {
    __IO uint32_t  REG_0x1060;                      /*!< UI_UVGAIN1                                                            */
    
    struct {
      __IO uint32_t  UI_UVGAIN1 :  8;               /*!< The edge value output =
                                                          sign(input)*(YEDGE_STR+(abs(input)-YEDGE_STR)*YEDGE_SLP/8).          */
      __IO uint32_t  UI_UVGAIN2 :  8;               /*!< (null)                                                                */
      __IO uint32_t  UI_UVGAIN3 :  8;               /*!< (null)                                                                */
      __IO uint32_t  UI_UVGAIN4 :  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1064;                      /*!< YGAMMA_0                                                              */
    
    struct {
      __IO uint32_t  YGAMMA_0   :  8;               /*!< Gamma Curve Output Segment 0, while input is 0                        */
      __IO uint32_t  YGAMMA_1   :  8;               /*!< Gamma Curve Output Segment 1, while input is 8                        */
      __IO uint32_t  YGAMMA_2   :  8;               /*!< Gamma Curve Output Segment 2, while input is 16                       */
      __IO uint32_t  YGAMMA_3   :  8;               /*!< Gamma Curve Output Segment 3, while input is 24                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1068;                      /*!< YGAMMA_4                                                              */
    
    struct {
      __IO uint32_t  YGAMMA_4   :  8;               /*!< Gamma Curve Output Segment 4, while input is 32                       */
      __IO uint32_t  YGAMMA_5   :  8;               /*!< Gamma Curve Output Segment 5, while input is 48                       */
      __IO uint32_t  YGAMMA_6   :  8;               /*!< Gamma Curve Output Segment 6, while input is 64                       */
      __IO uint32_t  YGAMMA_7   :  8;               /*!< Gamma Curve Output Segment 7, while input is 80                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x106C;                      /*!< YGAMMA_8                                                              */
    
    struct {
      __IO uint32_t  YGAMMA_8   :  8;               /*!< Gamma Curve Output Segment 8, while input is 96                       */
      __IO uint32_t  YGAMMA_9   :  8;               /*!< Gamma Curve Output Segment 9, while input is 128                      */
      __IO uint32_t  YGAMMA_10  :  8;               /*!< Gamma Curve Output Segment 10, while input is 160                     */
      __IO uint32_t  YGAMMA_11  :  8;               /*!< Gamma Curve Output Segment 11, while input is 192                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1070;                      /*!< YGAMMA_12                                                             */
    
    struct {
      __IO uint32_t  YGAMMA_12  :  8;               /*!< Gamma Curve Output Segment 12, while input is 208                     */
      __IO uint32_t  YGAMMA_13  :  8;               /*!< Gamma Curve Output Segment 13, while input is 224                     */
      __IO uint32_t  YGAMMA_14  :  8;               /*!< Gamma Curve Output Segment 14, while input is 232                     */
      __IO uint32_t  YGAMMA_15  :  8;               /*!< Gamma Curve Output Segment 15, while input is 240                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1074;                      /*!< YGAMMA_16                                                             */
    
    struct {
      __IO uint32_t  YGAMMA_16  :  8;               /*!< Gamma Curve Output Segment 16, while input is 248                     */
      __IO uint32_t  YGAMMA_17  :  8;               /*!< Gamma Curve Output Segment 17, while input is 255                     */
           uint32_t             : 15;
      __IO uint32_t  YGAMMA_EN  :  1;               /*!< 0:Disable 1: Enable Y Gamma                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1078;                      /*!< UI_Y_OFFSET                                                           */
    
    struct {
      __IO uint32_t  UI_Y_OFFSET:  7;               /*!< Let the Y (luminance) value to have a offset from -64 ~ 63            */
           uint32_t             :  1;
      __IO uint32_t  UI_Y_GAIN  :  8;               /*!< Let the Y (luminance) value to be multiplied by the gain for
                                                         
                                                         enhancement or reduction 
                                                         Range : 0 ~ 255                                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x107C;                      /*!< HSYNC_DEL_NT_YUVF                                                     */
    
    struct {
      __IO uint32_t  HSYNC_DEL_NT_YUVF:  8;         /*!< (null)                                                                */
      __IO uint32_t  YUVF_RC_V_SIZE: 11;            /*!< (null)                                                                */
           uint32_t             :  5;
      __IO uint32_t  YUVF_V_SIZE_SEL:  1;           /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1080;                      /*!< MD0_STA                                                               */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  MD0_STA    : 24;               /*!< MD W0 frame buffer DRAM start address, unit :256byte                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1084;                      /*!< MD1_STA                                                               */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  MD1_STA    : 24;               /*!< MD W1 frame buffer DRAM start address, unit :256byte                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1088;                      /*!< MD2_STA                                                               */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  MD2_STA    : 24;               /*!< MD W2 frame buffer DRAM start address, unit :256byte                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x108C;                      /*!< SC1_DUMMY_BLANK                                                       */
    
    struct {
      __IO uint32_t  SC1_DUMMY_BLANK: 10;           /*!< Dummy line blank for scaler11,12. (unit: 16 ISP_CLK cycle)            */
      __IO uint32_t  SC2_DUMMY_BLANK: 10;           /*!< Dummy line blank for scaler21,22. (unit: 16 ISP_CLK cycle)            */
      __IO uint32_t  SC3_DUMMY_BLANK: 10;           /*!< Dummy line blank for scaler31,32. (unit: 16 ISP_CLK cycle)            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1090;                      /*!< SCALE1_YUV_FIR_MODE                                                   */
    
    struct {
      __IO uint32_t  SCALE1_YUV_FIR_MODE:  3;       /*!< FIR Filter type: 
                                                         0: disable FIR, 1: Tap3, 2: Tap5, 3: Tap7, 4: Tap9                    */
      __IO uint32_t  LB_SKIP1   :  3;               /*!< Line Buffer Skip number for Scaler 1: 
                                                         Ceil (Scaler output size / Buffer Length) 
                                                         Scaler1 Line Buffer Length 768 Pixels,                                */
           uint32_t             :  2;
      __IO uint32_t  SCALE1_YUV_FIR_0:  9;          /*!< (null)                                                                */
      __IO uint32_t  SCALE1_YUV_FIR_1:  9;          /*!< Scaler 1 FIR coefficients, 
                                                         D0, ... , Dc, ... , Dn 
                                                         FIR_0 is the center data Dc coefficient, range:-64~63                 */
           uint32_t             :  3;
      __IO uint32_t  SCALE1_PULSE_INTV:  2;         /*!< YUV scaler dummy line output DSTB interval: 
                                                         0: 1T burst output, 1: 2T DSTB output 
                                                         2: 3T burst output, 3: 4T DSTB output                                 */
      __IO uint32_t  SCALE1_YUV_SCAL_EN:  1;        /*!< 1: Scaler1 Enable, 0: Bypass Scaler1                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1094;                      /*!< SCALE1_YUV_FIR_2                                                      */
    
    struct {
      __IO uint32_t  SCALE1_YUV_FIR_2:  9;          /*!< (null)                                                                */
      __IO uint32_t  SCALE1_YUV_FIR_3:  9;          /*!< (null)                                                                */
      __IO uint32_t  SCALE1_YUV_FIR_4:  9;          /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1098;                      /*!< SCALE1_YUV_RATIO_H                                                    */
    
    struct {
      __IO uint32_t  SCALE1_YUV_RATIO_H: 11;        /*!< Scaling ratio on width for Scaler1 
                                                         Range:128/(128~2047) 
                                                         FIR Line buffer size and Tap# must be considered before setting
                                                         scaling ratio.                                                        */
           uint32_t             :  5;
      __IO uint32_t  SCALE1_YUV_RATIO_V: 11;        /*!< Scaling ratio on height for Scaler1 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x109C;                      /*!< SCALE1_YUV_OUT_HSTART                                                 */
    
    struct {
      __IO uint32_t  SCALE1_YUV_OUT_HSTART: 13;     /*!< Window out horizontal start point for Scaler1(Unit:1pixel)            */
           uint32_t             :  3;
      __IO uint32_t  SCALE1_YUV_OUT_VSTART: 12;     /*!< Window out vertical start point for Scaler1(Unit:1line)               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10A0;                      /*!< SCALE1_YUV_OUT_HSIZE                                                  */
    
    struct {
      __IO uint32_t  SCALE1_YUV_OUT_HSIZE: 12;      /*!< Window out horizontal size for Scaler1(Unit:16pixel)                  */
           uint32_t             :  4;
      __IO uint32_t  SCALE1_YUV_OUT_VSIZE: 11;      /*!< Window out vertical size for Scaler1(Unit:2line)                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10A4;                      /*!< SCALE2_YUV_FIR_MODE                                                   */
    
    struct {
      __IO uint32_t  SCALE2_YUV_FIR_MODE:  3;       /*!< FIR Filter type: 
                                                         0: disable FIR, 1: Tap3, 2: Tap5, 3: Tap7, 4: Tap9                    */
      __IO uint32_t  LB_SKIP2   :  3;               /*!< Line Buffer Skip number for Scaler 2: 
                                                         Ceil (Scaler output size / Buffer Length) 
                                                         Scaler2 Line Buffer Length 320 Pixels,                                */
           uint32_t             :  2;
      __IO uint32_t  SCALE2_YUV_FIR_0:  9;          /*!< (null)                                                                */
      __IO uint32_t  SCALE2_YUV_FIR_1:  9;          /*!< Scaler 2 FIR coefficients, 
                                                         D0, ... , Dc, ... , Dn 
                                                         FIR_0 is the center data Dc coefficient, range:-64~63 
                                                         FIR_1 is the (D0 + Dn) coefficient, range:-64~63 
                                                          FIR_2 is the (D1 + Dn-1) coefficient, range:-64~63 
                                                         n: 2,4 by setting FIR_MODE                                            */
           uint32_t             :  3;
      __IO uint32_t  SCALE2_PULSE_INTV:  2;         /*!< YUV scaler dummy line output DSTB interval: 
                                                         0: 1T burst output, 1: 2T DSTB output 
                                                         2: 3T burst output, 3: 4T DSTB output                                 */
      __IO uint32_t  SCALE2_YUV_SCAL_EN:  1;        /*!< 1: Scaler2 Enable, 0: Bypass Scaler2                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10A8;                      /*!< SCALE2_YUV_FIR_2                                                      */
    
    struct {
      __IO uint32_t  SCALE2_YUV_FIR_2:  9;          /*!< (null)                                                                */
      __IO uint32_t  SCALE2_YUV_FIR_3:  9;          /*!< (null)                                                                */
      __IO uint32_t  SCALE2_YUV_FIR_4:  9;          /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10AC;                      /*!< SCALE2_YUV_RATIO_H                                                    */
    
    struct {
      __IO uint32_t  SCALE2_YUV_RATIO_H: 11;        /*!< Scaling ratio on width for Scaler2 
                                                         Range:128/(128~2047) 
                                                          FIR Line buffer size and Tap# must be considered before setting
                                                         scaling ratio.                                                        */
           uint32_t             :  5;
      __IO uint32_t  SCALE2_YUV_RATIO_V: 11;        /*!< Scaling ratio on height for Scaler2 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10B0;                      /*!< SCALE2_YUV_OUT_HSTART                                                 */
    
    struct {
      __IO uint32_t  SCALE2_YUV_OUT_HSTART: 12;     /*!< Window out horizontal start point ro Scaler2(Unit:1pixel)             */
           uint32_t             :  4;
      __IO uint32_t  SCALE2_YUV_OUT_VSTART: 12;     /*!< Window out vertical start point for Scaler2(Unit:1line)               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10B4;                      /*!< SCALE2_YUV_OUT_HSIZE                                                  */
    
    struct {
      __IO uint32_t  SCALE2_YUV_OUT_HSIZE: 11;      /*!< Window out horizontal size for Scaler2(Unit:16pixel)                  */
           uint32_t             :  5;
      __IO uint32_t  SCALE2_YUV_OUT_VSIZE: 11;      /*!< Window out vertical size for Scaler1(Unit:2line)                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10B8;                      /*!< SCALE12_YUV_FIR_MODE                                                  */
    
    struct {
      __IO uint32_t  SCALE12_YUV_FIR_MODE:  3;      /*!< FIR Filter type: 
                                                         0: disable FIR, 1: Tap3, 2: Tap5, 3: Tap7, 4: Tap9                    */
      __IO uint32_t  LB_SKIP12  :  3;               /*!< Line Buffer Skip number for Scaler 12: 
                                                         Ceil (Scaler output size / Buffer Length) 
                                                         Scaler12 Line Buffer Length 320 Pixels,                               */
           uint32_t             :  2;
      __IO uint32_t  SCALE12_YUV_FIR_0:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE12_YUV_FIR_1:  9;         /*!< Scaler 12 FIR coefficients, 
                                                         D0, ... , Dc, ... , Dn 
                                                         FIR_0 is the center data Dc coefficient, range:-64~63                 */
           uint32_t             :  5;
      __IO uint32_t  SCALE12_YUV_SCAL_EN:  1;       /*!< 1: Scaler12 Enable, 0: Bypass Scaler12                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10BC;                      /*!< SCALE12_YUV_FIR_2                                                     */
    
    struct {
      __IO uint32_t  SCALE12_YUV_FIR_2:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE12_YUV_FIR_3:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE12_YUV_FIR_4:  9;         /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10C0;                      /*!< SCALE12_YUV_RATIO_H                                                   */
    
    struct {
      __IO uint32_t  SCALE12_YUV_RATIO_H: 11;       /*!< Scaling ratio on width for Scaler12 
                                                         Range:128/(128~2047) 
                                                         FIR Line buffer size and Tap# must be considered before setting
                                                         scaling ratio.                                                        */
           uint32_t             :  5;
      __IO uint32_t  SCALE12_YUV_RATIO_V: 11;       /*!< Scaling ratio on height for Scaler12 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10C4;                      /*!< SCALE12_YUV_OUT_HSTART                                                */
    
    struct {
      __IO uint32_t  SCALE12_YUV_OUT_HSTART: 12;    /*!< Window out horizontal start point for Scaler12(Unit:1pixel)           */
           uint32_t             :  4;
      __IO uint32_t  SCALE12_YUV_OUT_VSTART: 12;    /*!< Window out vertical start point for Scaler12(Unit:1line)              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10C8;                      /*!< SCALE12_YUV_OUT_HSIZE                                                 */
    
    struct {
      __IO uint32_t  SCALE12_YUV_OUT_HSIZE: 11;     /*!< Window out horizontal size for Scaler12(Unit:16pixel)                 */
           uint32_t             :  5;
      __IO uint32_t  SCALE12_YUV_OUT_VSIZE: 11;     /*!< Window out vertical size for Scaler12(Unit:2line)                     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10CC;                      /*!< SCALE22_YUV_FIR_MODE                                                  */
    
    struct {
      __IO uint32_t  SCALE22_YUV_FIR_MODE:  3;      /*!< FIR Filter type: 
                                                         0: disable FIR, 1: Tap3, 2: Tap5, 3: Tap7, 4: Tap9                    */
      __IO uint32_t  LB_SKIP22  :  3;               /*!< Line Buffer Skip number for Scaler 22: 
                                                         Ceil (Scaler output size / Buffer Length) 
                                                         Scaler12 Line Buffer Length 320 Pixels,                               */
           uint32_t             :  2;
      __IO uint32_t  SCALE22_YUV_FIR_0:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE22_YUV_FIR_1:  9;         /*!< Scaler 22 FIR coefficients, 
                                                         D0, ... , Dc, ... , Dn 
                                                         FIR_0 is the center data Dc coefficient, range:-64~63                 */
           uint32_t             :  5;
      __IO uint32_t  SCALE22_YUV_SCAL_EN:  1;       /*!< 1: Scaler22 Enable, 0: Bypass Scaler22                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10D0;                      /*!< SCALE22_YUV_FIR_2                                                     */
    
    struct {
      __IO uint32_t  SCALE22_YUV_FIR_2:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE22_YUV_FIR_3:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE22_YUV_FIR_4:  9;         /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10D4;                      /*!< SCALE22_YUV_RATIO_H                                                   */
    
    struct {
      __IO uint32_t  SCALE22_YUV_RATIO_H: 11;       /*!< Scaling ratio on width for Scaler22 
                                                         Range:128/(128~2047) 
                                                         FIR Line buffer size and Tap# must be considered before setting
                                                         scaling ratio.                                                        */
           uint32_t             :  5;
      __IO uint32_t  SCALE22_YUV_RATIO_V: 11;       /*!< Scaling ratio on height for Scaler22 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10D8;                      /*!< SCALE22_YUV_OUT_HSTART                                                */
    
    struct {
      __IO uint32_t  SCALE22_YUV_OUT_HSTART: 12;    /*!< Window out horizontal start point for Scaler22(Unit:1pixel)           */
           uint32_t             :  4;
      __IO uint32_t  SCALE22_YUV_OUT_VSTART: 12;    /*!< Window out vertical start point for Scaler22(Unit:1line)              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10DC;                      /*!< SCALE22_YUV_OUT_HSIZE                                                 */
    
    struct {
      __IO uint32_t  SCALE22_YUV_OUT_HSIZE: 11;     /*!< Window out horizontal size for Scaler22(Unit:16pixel)                 */
           uint32_t             :  5;
      __IO uint32_t  SCALE22_YUV_OUT_VSIZE: 11;     /*!< Window out vertical size for Scaler22(Unit:2line)                     */
    };
  };
  __I  uint32_t  RESERVED316[4];
  
  union {
    __IO uint32_t  REG_0x10F0;                      /*!< SC_BUF_FULL                                                           */
    
    struct {
      __I  uint32_t  SC_BUF_FULL:  1;               /*!< SCALE1 buffer full flag, only asserted as H_RATIO small than
                                                         128                                                                   */
      __I  uint32_t  SC_OVER_HSYNC:  1;             /*!< SCALE1 buffer reschedule timing error , only asserted as H_RATIO
                                                         small than 128.                                                       */
      __IO uint32_t  SC_BUF_FULL_CLR:  1;           /*!< Write 1 to clear SC_BUF_FULL flag                                     */
      __IO uint32_t  SC_OVER_HSYNC_CLR:  1;         /*!< Write 1 to clear SC_OVER_HSYNC flag                                   */
      __IO uint32_t  SCALE3_YUV_UVCBYPASSSEL:  1;   /*!< 1: Scaler3 input bypass UV gain, Y gamma, Y level shift, Y gain,
                                                         privateMask                                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x10F4;                      /*!< ISP_FBC_MINK                                                          */
    
    struct {
      __IO uint32_t  ISP_FBC_MINK:  3;              /*!< min. golomb k                                                         */
           uint32_t             :  1;
      __IO uint32_t  ISP_FBC_MAXK:  3;              /*!< max. golomb k                                                         */
           uint32_t             :  1;
      __IO uint32_t  ISP_FBC_ENHK:  2;              /*!< Enhanced golomb k step                                                */
           uint32_t             :  6;
      __IO uint32_t  ISP_FBC_EN :  1;               /*!< 1: Enable isp frame compression                                       */
    };
  };
  __I  uint32_t  RESERVED317;
  
  union {
    __IO uint32_t  REG_0x10FC;                      /*!< SCALE31_YUV_FIR_MODE                                                  */
    
    struct {
      __IO uint32_t  SCALE31_YUV_FIR_MODE:  3;      /*!< FIR Filter type: 
                                                         0: Tap3, 1: Tap5, 2: Tap7, 3: Tap9                                    */
      __IO uint32_t  LB_SKIP31  :  3;               /*!< Line Buffer Skip number for Scaler 31: 
                                                         Ceil (Scaler output size / Buffer Length) 
                                                         Scaler31 Line Buffer Length 768 Pixels,                               */
           uint32_t             :  2;
      __IO uint32_t  SCALE31_YUV_FIR_0:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE31_YUV_FIR_1:  9;         /*!< Scaler 31 FIR coefficients, 
                                                         D0, ... , Dc, ... , Dn 
                                                         FIR_0 is the center data Dc coefficient, range:-64~63                 */
           uint32_t             :  3;
      __IO uint32_t  SCALE3_PULSE_INTV:  2;         /*!< YUV scaler dummy line output DSTB interval: 
                                                         0: 1T burst output, 1: 2T DSTB output 
                                                         2: 3T burst output, 3: 4T DSTB output                                 */
      __IO uint32_t  SCALE31_YUV_SCAL_EN:  1;       /*!< 1: Scaler31 Enable, 0: Bypass Scaler31                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1100;                      /*!< SCALE31_YUV_FIR_1                                                     */
    
    struct {
      __IO uint32_t  SCALE31_YUV_FIR_2:  9;         /*!< FIR_1 is the (D0 + Dn) coefficient, range:-64~63                      */
      __IO uint32_t  SCALE31_YUV_FIR_3:  9;         /*!< FIR_2 is the (D1 + Dn-1) coefficient, range:-64~63                    */
      __IO uint32_t  SCALE31_YUV_FIR_4:  9;         /*!< FIR_3 is the (D2 + Dn-2) coefficient, range:-64~63                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1104;                      /*!< SCALE31_YUV_RATIO_H                                                   */
    
    struct {
      __IO uint32_t  SCALE31_YUV_RATIO_H: 11;       /*!< Scaling ratio on width for Scaler3-1 
                                                         Range:128/(128~2047)                                                  */
           uint32_t             :  5;
      __IO uint32_t  SCALE31_YUV_RATIO_V: 11;       /*!< Scaling ratio on height for Scaler3-1 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1108;                      /*!< SCALE31_YUV_OUT_HSTART                                                */
    
    struct {
      __IO uint32_t  SCALE31_YUV_OUT_HSTART: 12;    /*!< Window out horizontal start point ro Scaler3-1(Unit:1pixel)           */
           uint32_t             :  4;
      __IO uint32_t  SCALE31_YUV_OUT_VSTART: 12;    /*!< Window out vertical start point for Scaler3-1(Unit:1line)             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x110C;                      /*!< SCALE31_YUV_OUT_HSIZE                                                 */
    
    struct {
      __IO uint32_t  SCALE31_YUV_OUT_HSIZE: 11;     /*!< Window out horizontal size for Scaler3-1(Unit:16pixel)                */
           uint32_t             :  5;
      __IO uint32_t  SCALE31_YUV_OUT_VSIZE: 11;     /*!< Window out vertical size for Scaler3-1(Unit:2line)                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1110;                      /*!< SCALE32_YUV_FIR_MODE                                                  */
    
    struct {
      __IO uint32_t  SCALE32_YUV_FIR_MODE:  3;      /*!< FIR Filter type: 
                                                         0: Tap3, 1: Tap5, 2: Tap7, 3: Tap9                                    */
      __IO uint32_t  LB_SKIP32  :  3;               /*!< Line Buffer Skip number for Scaler 31: 
                                                         Ceil (Scaler output size / Buffer Length) 
                                                         Scaler31 Line Buffer Length 768 Pixels,                               */
           uint32_t             :  2;
      __IO uint32_t  SCALE32_YUV_FIR_0:  9;         /*!< (null)                                                                */
      __IO uint32_t  SCALE32_YUV_FIR_1:  9;         /*!< Scaler 32 FIR coefficients, 
                                                         D0, ... , Dc, ... , Dn 
                                                         FIR_0 is the center data Dc coefficient, range:-64~63                 */
           uint32_t             :  5;
      __IO uint32_t  SCALE32_YUV_SCAL_EN:  1;       /*!< 1: Scaler32 Enable, 0: Bypass Scaler31                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1114;                      /*!< SCALE32_YUV_FIR_2                                                     */
    
    struct {
      __IO uint32_t  SCALE32_YUV_FIR_2:  9;         /*!< FIR_1 is the (D0 + Dn) coefficient, range:-64~63                      */
      __IO uint32_t  SCALE32_YUV_FIR_3:  9;         /*!< FIR_2 is the (D1 + Dn-1) coefficient, range:-64~63                    */
      __IO uint32_t  SCALE32_YUV_FIR_4:  9;         /*!< FIR_3 is the (D2 + Dn-2) coefficient, range:-64~63                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1118;                      /*!< SCALE32_YUV_RATIO_H                                                   */
    
    struct {
      __IO uint32_t  SCALE32_YUV_RATIO_H: 11;       /*!< Scaling ratio on width for Scaler3-2 
                                                         Range:128/(128~2047)                                                  */
           uint32_t             :  5;
      __IO uint32_t  SCALE32_YUV_RATIO_V: 11;       /*!< Scaling ratio on height for Scaler3-2 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x111C;                      /*!< SCALE32_YUV_OUT_HSTART                                                */
    
    struct {
      __IO uint32_t  SCALE32_YUV_OUT_HSTART: 12;    /*!< Window out horizontal start point ro Scaler3-1(Unit:1pixel)           */
           uint32_t             :  4;
      __IO uint32_t  SCALE32_YUV_OUT_VSTART: 12;    /*!< Window out vertical start point for Scaler3-1(Unit:1line)             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1120;                      /*!< SCALE32_YUV_OUT_HSIZE                                                 */
    
    struct {
      __IO uint32_t  SCALE32_YUV_OUT_HSIZE: 11;     /*!< Window out horizontal size for Scaler3-2(Unit:16pixel)                */
           uint32_t             :  5;
      __IO uint32_t  SCALE32_YUV_OUT_VSIZE: 11;     /*!< Window out vertical size for Scaler3-2(Unit:2line)                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1124;                      /*!< NR3D_STA                                                              */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  NR3D_STA   : 24;               /*!< 3D-NR frame ring buffer DRAM start address, unit :256byte             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1128;                      /*!< NR3D_EDA                                                              */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  NR3D_EDA   : 24;               /*!< 3D-NR frame ring buffer DRAM end address, unit :256byte               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x112C;                      /*!< STR1_STA                                                              */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  STR1_STA   : 24;               /*!< Video Stream1 DRAM start address, unit :256byte                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1130;                      /*!< STR2_STA                                                              */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  STR2_STA   : 24;               /*!< Video Stream2 DRAM start address, unit :256byte                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1134;                      /*!< STR3_STA                                                              */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  STR3_STA   : 24;               /*!< Video Stream3 DRAM start address, unit :256byte                       */
    };
  };
  __I  uint32_t  RESERVED318[2];
  
  union {
    __IO uint32_t  REG_0x1140;                      /*!< PRI_MASK_EN                                                           */
    
    struct {
      __IO uint32_t  PRI_MASK_EN:  1;               /*!< 1: Enable private mask 
                                                         0: Disable private mask                                               */
           uint32_t             :  3;
      __IO uint32_t  PRI_Y_COLOR_SEL:  4;           /*!< 0: select 8'h00, 1: select 8'h10, 2: select 8'h20, 3: select
                                                         8'h30, 
                                                         4: select 8'h40, 5: select 8'h50, 6: select 8'h60, 7: select
                                                          8'h70, 
                                                         8: select 8'h80, 9: select 8'h90, 10: select 8'ha0, 11: select
                                                          8'hb0, 
                                                         12: select 8'hc0, 13: select 8'hd0, 14: select 8'he0, 15: select
                                                          8'hf0                                                                */
      __IO uint32_t  PRI_U_COLOR_SEL:  4;           /*!< 0: select 8'h00, 1: select 8'h10, 2: select 8'h20, 3: select
                                                         8'h30, 
                                                         4: select 8'h40, 5: select 8'h50, 6: select 8'h60, 7: select
                                                          8'h70, 
                                                         8: select 8'h80, 9: select 8'h90, 10: select 8'ha0, 11: select
                                                          8'hb0, 
                                                         12: select 8'hc0, 13: select 8'hd0, 14: select 8'he0, 15: select
                                                          8'hf0                                                                */
      __IO uint32_t  PRI_V_COLOR_SEL:  4;           /*!< 0: select 8'h00, 1: select 8'h10, 2: select 8'h20, 3: select
                                                         8'h30, 
                                                         4: select 8'h40, 5: select 8'h50, 6: select 8'h60, 7: select
                                                          8'h70, 
                                                         8: select 8'h80, 9: select 8'h90, 10: select 8'ha0, 11: select
                                                          8'hb0, 
                                                         12: select 8'hc0, 13: select 8'hd0, 14: select 8'he0, 15: select
                                                          8'hf0                                                                */
      __IO uint32_t  PRI_MASK_H_SIZE:  8;           /*!< Horizontal size of a block. 1~255, 
                                                         PRI_MASK_H_SIZE = H_SIZE/16, 
                                                         Unit: 1 pixel.                                                        */
      __IO uint32_t  PRI_MASK_V_SIZE:  8;           /*!< Vertical size of a block. 1~255, 
                                                         PRI_MASK_V_SIZE = V_SIZE/12, 
                                                         Unit: 1 line.                                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1144;                      /*!< ROW0_BLK_MASK                                                         */
    
    struct {
      __IO uint32_t  ROW0_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
      __IO uint32_t  ROW1_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1148;                      /*!< ROW2_BLK_MASK                                                         */
    
    struct {
      __IO uint32_t  ROW2_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
      __IO uint32_t  ROW3_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x114C;                      /*!< ROW4_BLK_MASK                                                         */
    
    struct {
      __IO uint32_t  ROW4_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
      __IO uint32_t  ROW5_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1150;                      /*!< ROW6_BLK_MASK                                                         */
    
    struct {
      __IO uint32_t  ROW6_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
      __IO uint32_t  ROW7_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1154;                      /*!< ROW8_BLK_MASK                                                         */
    
    struct {
      __IO uint32_t  ROW8_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
      __IO uint32_t  ROW9_BLK_MASK: 16;             /*!< Each bit corresponds to a row. 1 disables private mask.               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1158;                      /*!< ROW10_BLK_MASK                                                        */
    
    struct {
      __IO uint32_t  ROW10_BLK_MASK: 16;            /*!< Each bit corresponds to a row. 1 disables private mask.               */
      __IO uint32_t  ROW11_BLK_MASK: 16;            /*!< Each bit corresponds to a row. 1 disables private mask.               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x115C;                      /*!< FRM_DROP_SCALER1_EN                                                   */
    
    struct {
      __IO uint32_t  FRM_DROP_SCALER1_EN:  1;       /*!< Frame drop scaler1 enable                                             */
      __IO uint32_t  FRM_DROP_SCALER2_EN:  1;       /*!< Frame drop scaler2 enable                                             */
      __IO uint32_t  FRM_DROP_SCALER3_EN:  1;       /*!< Frame drop scaler3 enable                                             */
           uint32_t             : 13;
      __IO uint32_t  FRM_DROP_SCALER3_M:  8;        /*!< Frame rate x N/M for video stream 3 
                                                         M bigger than N when FRM_DROP_SCALER3_EN = 1                          */
      __IO uint32_t  FRM_DROP_SCALER3_N:  8;        /*!< Frame rate x N/M for video stream 3 
                                                         M bigger than N when FRM_DROP_SCALER3_EN = 1                          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1160;                      /*!< FRM_DROP_SCALER1_M                                                    */
    
    struct {
      __IO uint32_t  FRM_DROP_SCALER1_M:  8;        /*!< (null)                                                                */
      __IO uint32_t  FRM_DROP_SCALER1_N:  8;        /*!< (null)                                                                */
      __IO uint32_t  FRM_DROP_SCALER2_M:  8;        /*!< (null)                                                                */
      __IO uint32_t  FRM_DROP_SCALER2_N:  8;        /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1164;                      /*!< FRM_DROP0_INF                                                         */
    
    struct {
      __I  uint32_t  FRM_DROP1_INF:  1;             /*!< 1: The frame isn't dropped, 0: The frame is dropped                   */
      __I  uint32_t  FRM_DROP2_INF:  1;             /*!< 1: The frame isn't dropped, 0: The frame is dropped                   */
      __I  uint32_t  FRM_DROP3_INF:  1;             /*!< 1: The frame isn't dropped, 0: The frame is dropped                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1168;                      /*!< COLOR_TRIG_1                                                          */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  COLOR_TRIG_1:  1;              /*!< Fill 1 to update the register values for 
                                                         Y Gamma function, Y OFFSET, Y GAIN                                    */
      __IO uint32_t  COLOR_TRIG_2:  1;              /*!< Fill 1 to update the register values for 
                                                         UV Gain function[7:0]                                                 */
      __IO uint32_t  COLOR_TRIG_3:  1;              /*!< Fill 1 to update the register values for 
                                                         AYF_YF_SLP, AYF_YF_WEIGHT, AYF_YF_THD_LB, 
                                                         and AYF_YF_THD_SLP                                                    */
      __IO uint32_t  COLOR_TRIG_4:  1;              /*!< Fill 1 to update the register values for 
                                                         PRIVATE_MASK                                                          */
      __IO uint32_t  COLOR_TRIG_5:  1;              /*!< Fill 1 to update the register values for 
                                                         MIRROR_FLIP_MODE[1:0] 
                                                         STR1_STA 
                                                         STR2_STA 
                                                         NR3D_STA, NR3D_EDA                                                    */
      __IO uint32_t  COLOR_TRIG_6:  1;              /*!< Fill 1 to update the register values for 
                                                         Path 1/2 YEE registers 
                                                         YEE_HGAIN, YEE_VGAIN, YEE_THD, YEE_STR                                */
    };
  };
  __I  uint32_t  CHK_Y_SUM;                         /*!< The Y check sum is calculated at each module output we selected.
                                                         Reference CHK_YUV_SUM_SEL[1:0] at 9060_10e8h.                         */
  __I  uint32_t  CHK_U_SUM;                         /*!< The U check sum is calculated at each module output we selected.
                                                         Reference CHK_YUV_SUM_SEL[1:0] at 9060_10e8h.                         */
  __I  uint32_t  CHK_V_SUM;                         /*!< The V check sum is calculated at each module output we selected.
                                                         Reference CHK_YUV_SUM_SEL[1:0] at 9060_10e8h.                         */
  __I  uint32_t  CLR_Y_SUM_1;                       /*!< Check sum in Y domain, which is calculated at the end of video
                                                         pipe1, each Y component in a frame was taken into account.            */
  __I  uint32_t  CLR_U_SUM_1;                       /*!< Check sum in U domain, which is calculated at the end of video
                                                         pipe1, each U component in a frame was taken into account.            */
  __I  uint32_t  CLR_V_SUM_1;                       /*!< Check sum in V domain, which is calculated at the end of video
                                                         pipe1, each V component in a frame was taken into account.            */
  __I  uint32_t  CLR_Y_SUM_2;                       /*!< Check sum in Y domain, which is calculated at the end of video
                                                         pipe2, each Y component in a frame was taken into account.            */
  __I  uint32_t  CLR_U_SUM_2;                       /*!< Check sum in U domain, which is calculated at the end of video
                                                         pipe2, each U component in a frame was taken into account.            */
  __I  uint32_t  CLR_V_SUM_2;                       /*!< Check sum in V domain, which is calculated at the end of video
                                                         pipe2, each V component in a frame was taken into account.            */
  __IO uint8_t   CHK_YUV_SUM_SEL;                   /*!< 0: Select YUV filter output CHK_Y_SUM ~ CHK_V_SUM 
                                                         1: Select scaler 1 output CHK_Y_SUM ~ CHK_V_SUM 
                                                         2: Select scaler 2 output CHK_Y_SUM ~ CHK_V_SUM 
                                                         3: Select FIFO0 input CHK_Y_SUM ~ CHK_V_SUM 
                                                         4: Select FIFO1 input CHK_Y_SUM ~ CHK_V_SUM                           */
  __I  uint8_t   RESERVED319[3];
  
  union {
    __IO uint32_t  REG_0x1194;                      /*!< RES_REG0                                                              */
    
    struct {
      __IO uint32_t  RES_REG0   :  8;               /*!< (null)                                                                */
      __IO uint32_t  RES_REG1   :  8;               /*!< (null)                                                                */
      __IO uint32_t  RES_REG2   :  8;               /*!< (null)                                                                */
      __IO uint32_t  RES_REG3   :  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1198;                      /*!< RES_REG4                                                              */
    
    struct {
      __IO uint32_t  RES_REG4   :  8;               /*!< (null)                                                                */
      __IO uint32_t  RES_REG5   :  8;               /*!< (null)                                                                */
      __IO uint32_t  RES_REG6   :  8;               /*!< (null)                                                                */
      __IO uint32_t  RES_REG7   :  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x119C;                      /*!< YEE_1_EN                                                              */
    
    struct {
      __IO uint32_t  YEE_1_EN   :  1;               /*!< (null)                                                                */
      __IO uint32_t  YEE_2_EN   :  1;               /*!< (null)                                                                */
      __IO uint32_t  YEE_1_NTSEL:  2;               /*!< Path1 YEE dummy line output DSTB interval:0: 1T burst output,
                                                         1: 2T DSTB output2: 3T burst output, 3: 4T DSTB output                */
      __IO uint32_t  YEE_2_NTSEL:  2;               /*!< Path1 YEE dummy line output DSTB interval:0: 1T burst output,
                                                         1: 2T DSTB output2: 3T burst output, 3: 4T DSTB output                */
           uint32_t             :  2;
      __IO uint32_t  YEE_1_DUMM_BLANK:  8;          /*!< Dummy line blank for path1 YEE. (unit: 16 ISP_CLK cycle)              */
      __IO uint32_t  YEE_2_DUMM_BLANK:  8;          /*!< OSD1 Pixel Mapping Gain for column 0. (0: Gain=8, 1-7: Gain=1-7)      */
      __IO uint32_t  YEE_1_SLP  :  3;               /*!< (null)                                                                */
      __IO uint32_t  YEE_2_SLP  :  3;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x11A0;                      /*!< YEE_1_HGAIN                                                           */
    
    struct {
      __IO uint32_t  YEE_1_HGAIN:  8;               /*!< (null)                                                                */
      __IO uint32_t  YEE_1_VGAIN:  8;               /*!< (null)                                                                */
      __IO uint32_t  YEE_1_THD  :  8;               /*!< (null)                                                                */
      __IO uint32_t  YEE_1_STR  :  8;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x11A4;                      /*!< YEE_2_HGAIN                                                           */
    
    struct {
      __IO uint32_t  YEE_2_HGAIN:  8;               /*!< (null)                                                                */
      __IO uint32_t  YEE_2_VGAIN:  8;               /*!< (null)                                                                */
      __IO uint32_t  YEE_2_THD  :  8;               /*!< (null)                                                                */
      __IO uint32_t  YEE_2_STR  :  8;               /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED320[6];
  __I  uint32_t  BAYER_R_NUM;                       /*!< Bayer R Number after NR                                               */
  __I  uint32_t  BAYER_R_SUM;                       /*!< Bayer R Sum after NR                                                  */
  __I  uint32_t  BAYER_G_NUM;                       /*!< Bayer G Number after NR                                               */
  __I  uint32_t  BAYER_G_SUM;                       /*!< Bayer G Sum after NR                                                  */
  __I  uint32_t  BAYER_B_NUM;                       /*!< Bayer B Number after NR                                               */
  __I  uint32_t  BAYER_B_SUM;                       /*!< Bayer B Sum after NR                                                  */
  
  union {
    __IO uint32_t  REG_0x11D8;                      /*!< AGC_YOFFSET                                                           */
    
    struct {
      __IO uint32_t  AGC_YOFFSET:  7;               /*!< Y (luminance) Gain of AGC 
                                                         Range : signed value : -64 ~ 63                                       */
      __IO uint32_t  AGC_EN     :  1;               /*!< Auto Gain Control(AGC) enable                                         */
      __IO uint32_t  AGC_YGAIN  :  8;               /*!< Y (luminance) Offset of AGC 
                                                         Range : unsigned value : 0 ~ 255 map x0 ~ x(255/128)                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x11DC;                      /*!< AGC_UGAIN                                                             */
    
    struct {
      __IO uint32_t  AGC_UGAIN  :  8;               /*!< U(Cb) Offset of AGC 
                                                         Range : unsigned value : 0 ~ 255 map x0 ~ x(255/128)                  */
      __IO uint32_t  AGC_VGAIN  :  8;               /*!< V(Cr) Offset of AGC 
                                                         Range : unsigned value : 0 ~ 255 map x0 ~ x(255/128)                  */
           uint32_t             : 15;
      __IO uint32_t  AGC_TRIG   :  1;               /*!< AGC parameter trigger bit Auto clear 0 by next vsync                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x11E0;                      /*!< AGC_HSTART                                                            */
    
    struct {
      __IO uint32_t  AGC_HSTART : 12;               /*!< Window horizontal start of Y_SUM                                      */
           uint32_t             :  4;
      __IO uint32_t  AGC_VSTART : 12;               /*!< Window vertical start of Y_SUM                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x11E4;                      /*!< AGC_HSIZE                                                             */
    
    struct {
      __IO uint32_t  AGC_HSIZE  : 12;               /*!< Window horizontal size of Y_SUM                                       */
           uint32_t             :  4;
      __IO uint32_t  AGC_VSIZE  : 12;               /*!< Window vertical size of Y_SUM                                         */
    };
  };
  __I  uint32_t  Y_SUM;                             /*!< Y SUM (luminance) after AGC                                           */
  __I  uint32_t  Y_NUM;                             /*!< Y NUM (luminance) after AGC                                           */
  __I  uint32_t  RESERVED321[4];
  
  union {
    __IO uint32_t  REG_0x1200;                      /*!< OSD2_EN                                                               */
    
    struct {
      __IO uint32_t  OSD2_EN    :  1;               /*!< OSD2 Show Enable.                                                     */
      __IO uint32_t  OSD2_INDEX_UPD:  1;            /*!< Update OSD2 Line Text index. 
                                                         This bit is set by FW when finish to write the Line text index
                                                         and clear by HW at video frame start.                                 */
           uint32_t             :  1;
      __IO uint32_t  OSD2_SEL_RD:  1;               /*!< 1: Select to read OSD SRAM when OSD2_EN=0.                            */
      __IO uint32_t  OSD2_SIZE  :  2;               /*!< OSD2 font size. (0:8x16, 1:12x16, 2:16x16, 3:reserved)                */
           uint32_t             :  2;
      __IO uint32_t  OSD20_PIX_GAIN:  3;            /*!< OSD2 Pixel Mapping Gain for column 0.                                 */
           uint32_t             :  1;
      __IO uint32_t  OSD21_PIX_GAIN:  3;            /*!< OSD2 Pixel Mapping Gain for column 1.                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1204;                      /*!< OSD20_COL_NUM                                                         */
    
    struct {
      __IO uint32_t  OSD20_COL_NUM:  6;             /*!< OSD2 Column Number for column 0.                                      */
           uint32_t             :  2;
      __IO uint32_t  OSD21_COL_NUM:  6;             /*!< OSD2 Column Number for column 1.                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1208;                      /*!< OSD20_ROW_STA                                                         */
    
    struct {
      __IO uint32_t  OSD20_ROW_STA: 10;             /*!< OSD2 Row Start Address for column 0. (unit: 2 lines)                  */
           uint32_t             :  6;
      __IO uint32_t  OSD20_COL_STA: 11;             /*!< OSD2 Column Start Address for column 0. (unit: 2 pixels)              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x120C;                      /*!< OSD21_ROW_STA                                                         */
    
    struct {
      __IO uint32_t  OSD21_ROW_STA: 10;             /*!< OSD2 Row Start Address for column 1.                                  */
           uint32_t             :  6;
      __IO uint32_t  OSD21_COL_STA: 11;             /*!< OSD2 Column Start Address for column 1. (unit: 2 pixels)              */
    };
  };
  __I  uint32_t  RESERVED322[4];
  
  union {
    __IO uint32_t  REG_0x1220;                      /*!< OSD2_Y1                                                               */
    
    struct {
      __IO uint32_t  OSD2_Y1    :  8;               /*!< OSD2 Text Color-1 Y                                                   */
      __IO uint32_t  OSD2_CB1   :  8;               /*!< OSD2 Text Color-1 CB                                                  */
      __IO uint32_t  OSD2_CR1   :  8;               /*!< OSD2 Text Color-1 CR.                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1224;                      /*!< OSD2_Y2                                                               */
    
    struct {
      __IO uint32_t  OSD2_Y2    :  8;               /*!< OSD2 Text Color-2 Y                                                   */
      __IO uint32_t  OSD2_CB2   :  8;               /*!< OSD2 Text Color-2 CB                                                  */
      __IO uint32_t  OSD2_CR2   :  8;               /*!< OSD2 Text Color-2 CR.                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1228;                      /*!< OSD2_Y3                                                               */
    
    struct {
      __IO uint32_t  OSD2_Y3    :  8;               /*!< OSD2 Text Color-3 Y                                                   */
      __IO uint32_t  OSD2_CB3   :  8;               /*!< OSD2 Text Color-3 CB                                                  */
      __IO uint32_t  OSD2_CR3   :  8;               /*!< OSD2 Text Color-3 CR.                                                 */
    };
  };
  __I  uint32_t  RESERVED323;
  __O  uint16_t  OSD2_FONT_INIT_ADR;                /*!< Start address for read/write OSD2 SRAM when OSD2_EN=0. 
                                                         Note: If interrupt by CPU writing OSD-index, you must to write
                                                         this OSD-font address before writing OSD-font data.                   */
  __I  uint16_t  RESERVED324;
  __IO uint32_t  OSD2_FONT_DATA;                    /*!< SRAM read/write data Port for OSD2 SRAM. (544x32 bits) 
                                                         OSD font: 0-511. 
                                                         Row0 index buffer after sync: 512-519. 
                                                         Row1 index buffer after sync: 520-527. 
                                                         Row0 index buffer: 528-535. 
                                                         Row1 index buffer: 536-543.                                           */
  __I  uint32_t  RESERVED325[2];
  
  union {
    __IO uint32_t  REG_0x1240;                      /*!< OSD2_LINE0_TEXT1                                                      */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT1:  6;          /*!< OSD2 Line 1 Text 1                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT2:  6;          /*!< OSD2 Line 1 Text 2                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT3:  6;          /*!< OSD2 Line 1 Text 3                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT4:  6;          /*!< OSD2 Line 1 Text 4                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1244;                      /*!< OSD2_LINE0_TEXT5                                                      */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT5:  6;          /*!< OSD2 Line 1 Text 5                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT6:  6;          /*!< OSD2 Line 1 Text 6                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT7:  6;          /*!< OSD2 Line 1 Text 7                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT8:  6;          /*!< OSD2 Line 1 Text 8                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1248;                      /*!< OSD2_LINE0_TEXT9                                                      */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT9:  6;          /*!< OSD2 Line 1 Text 9                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT10:  6;         /*!< OSD2 Line 1 Text 10                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT11:  6;         /*!< OSD2 Line 1 Text 11                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT12:  6;         /*!< OSD2 Line 1 Text 12                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x124C;                      /*!< OSD2_LINE0_TEXT13                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT13:  6;         /*!< OSD2 Line 1 Text 13                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT14:  6;         /*!< OSD2 Line 1 Text 14                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT15:  6;         /*!< OSD2 Line 1 Text 15                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT16:  6;         /*!< OSD2 Line 1 Text 16                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1250;                      /*!< OSD2_LINE0_TEXT17                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT17:  6;         /*!< OSD2 Line 1 Text 17                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT18:  6;         /*!< OSD2 Line 1 Text 18                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT19:  6;         /*!< OSD2 Line 1 Text 19                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT20:  6;         /*!< OSD2 Line 1 Text 20                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1254;                      /*!< OSD2_LINE0_TEXT21                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT21:  6;         /*!< OSD2 Line 1 Text 21                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT22:  6;         /*!< OSD2 Line 1 Text 22                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT23:  6;         /*!< OSD2 Line 1 Text 23                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT24:  6;         /*!< OSD2 Line 1 Text 24                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1258;                      /*!< OSD2_LINE0_TEXT25                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT25:  6;         /*!< OSD2 Line 1 Text 25                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT26:  6;         /*!< OSD2 Line 1 Text 26                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT27:  6;         /*!< OSD2 Line 1 Text 27                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT28:  6;         /*!< OSD2 Line 1 Text 28                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x125C;                      /*!< OSD2_LINE0_TEXT29                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE0_TEXT29:  6;         /*!< OSD2 Line 1 Text 29                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT30:  6;         /*!< OSD2 Line 1 Text 30                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT31:  6;         /*!< OSD2 Line 1 Text 31                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE0_TEXT32:  6;         /*!< OSD2 Line 1 Text 32                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1260;                      /*!< OSD2_LINE1_TEXT1                                                      */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT1:  6;          /*!< OSD2 Line 2 Text 1                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT2:  6;          /*!< OSD2 Line 2 Text 2                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT3:  6;          /*!< OSD2 Line 2 Text 3                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT4:  6;          /*!< OSD2 Line 2 Text 4                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1264;                      /*!< OSD2_LINE1_TEXT5                                                      */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT5:  6;          /*!< OSD2 Line 2 Text 5                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT6:  6;          /*!< OSD2 Line 2 Text 6                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT7:  6;          /*!< OSD2 Line 2 Text 7                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT8:  6;          /*!< OSD2 Line 2 Text 8                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1268;                      /*!< OSD2_LINE1_TEXT9                                                      */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT9:  6;          /*!< OSD2 Line 2 Text 9                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT10:  6;         /*!< OSD2 Line 2 Text 10                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT11:  6;         /*!< OSD2 Line 2 Text 11                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT12:  6;         /*!< OSD2 Line 2 Text 12                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x126C;                      /*!< OSD2_LINE1_TEXT13                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT13:  6;         /*!< OSD2 Line 2 Text 13                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT14:  6;         /*!< OSD2 Line 2 Text 14                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT15:  6;         /*!< OSD2 Line 2 Text 15                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT16:  6;         /*!< OSD2 Line 2 Text 16                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1270;                      /*!< OSD2_LINE1_TEXT17                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT17:  6;         /*!< OSD2 Line 2 Text 17                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT18:  6;         /*!< OSD2 Line 2 Text 18                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT19:  6;         /*!< OSD2 Line 2 Text 19                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT20:  6;         /*!< OSD2 Line 2 Text 20                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1274;                      /*!< OSD2_LINE1_TEXT21                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT21:  6;         /*!< OSD2 Line 2 Text 21                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT22:  6;         /*!< OSD2 Line 2 Text 22                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT23:  6;         /*!< OSD2 Line 2 Text 23                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT24:  6;         /*!< OSD2 Line 2 Text 24                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1278;                      /*!< OSD2_LINE1_TEXT25                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT25:  6;         /*!< OSD2 Line 2 Text 25                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT26:  6;         /*!< OSD2 Line 2 Text 26                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT27:  6;         /*!< OSD2 Line 2 Text 27                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT28:  6;         /*!< OSD2 Line 2 Text 28                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x127C;                      /*!< OSD2_LINE1_TEXT29                                                     */
    
    struct {
      __O  uint32_t  OSD2_LINE1_TEXT29:  6;         /*!< OSD2 Line 2 Text 29                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT30:  6;         /*!< OSD2 Line 2 Text 30                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT31:  6;         /*!< OSD2 Line 2 Text 31                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD2_LINE1_TEXT32:  6;         /*!< OSD2 Line 2 Text 32                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1280;                      /*!< OSD1_EN                                                               */
    
    struct {
      __IO uint32_t  OSD1_EN    :  1;               /*!< OSD1 Show Enable.                                                     */
      __IO uint32_t  OSD1_INDEX_UPD:  1;            /*!< 1: Update OSD1 Line Text index. 
                                                         This bit is set by FW when finish to write the Line text index
                                                         and clear by HW at video frame start                                  */
           uint32_t             :  1;
      __IO uint32_t  OSD1_SEL_RD:  1;               /*!< 1: Select to read OSD SRAM when OSD1_EN=0.                            */
      __IO uint32_t  OSD1_SIZE  :  2;               /*!< OSD1 font size. (0:8x16, 1:12x16, 2:16x16, 3:reserved)
                                                         Note: Support 32 OSD fonts for 16x16, 42 for 12x16, 64 for 8x16.      */
           uint32_t             :  2;
      __IO uint32_t  OSD10_PIX_GAIN:  3;            /*!< OSD1 Pixel Mapping Gain for column 0. (0: Gain=8, 1-7: Gain=1-7)      */
           uint32_t             :  1;
      __IO uint32_t  OSD11_PIX_GAIN:  3;            /*!< OSD1 Pixel Mapping Gain for column 1. (0: Gain=8, 1-7: Gain=1-7)      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1284;                      /*!< OSD10_COL_NUM                                                         */
    
    struct {
      __IO uint32_t  OSD10_COL_NUM:  6;             /*!< OSD1 Column Number for column 0.                                      */
           uint32_t             :  2;
      __IO uint32_t  OSD11_COL_NUM:  6;             /*!< OSD1 Column Number for column 1.                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1288;                      /*!< OSD10_ROW_STA                                                         */
    
    struct {
      __IO uint32_t  OSD10_ROW_STA: 10;             /*!< OSD1 Row Start Address for column 0. (unit: 2 lines)                  */
           uint32_t             :  6;
      __IO uint32_t  OSD10_COL_STA: 11;             /*!< OSD1 Column Start Address for column 0. (unit: 2 pixels)              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x128C;                      /*!< OSD11_ROW_STA                                                         */
    
    struct {
      __IO uint32_t  OSD11_ROW_STA: 10;             /*!< OSD1 Row Start Address for column 1.                                  */
           uint32_t             :  6;
      __IO uint32_t  OSD11_COL_STA: 11;             /*!< OSD1 Column Start Address for column 1.                               */
    };
  };
  __I  uint32_t  RESERVED326[4];
  
  union {
    __IO uint32_t  REG_0x12A0;                      /*!< OSD1_Y1                                                               */
    
    struct {
      __IO uint32_t  OSD1_Y1    :  8;               /*!< OSD1 Text Color-1 Y                                                   */
      __IO uint32_t  OSD1_CB1   :  8;               /*!< OSD1 Text Color-1 CB                                                  */
      __IO uint32_t  OSD1_CR1   :  8;               /*!< OSD1 Text Color-1 CR.                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12A4;                      /*!< OSD1_Y2                                                               */
    
    struct {
      __IO uint32_t  OSD1_Y2    :  8;               /*!< OSD1 Text Color-2 Y                                                   */
      __IO uint32_t  OSD1_CB2   :  8;               /*!< OSD1 Text Color-2 CB                                                  */
      __IO uint32_t  OSD1_CR2   :  8;               /*!< OSD1 Text Color-2 CR.                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12A8;                      /*!< OSD1_Y3                                                               */
    
    struct {
      __IO uint32_t  OSD1_Y3    :  8;               /*!< OSD1 Text Color-3 Y                                                   */
      __IO uint32_t  OSD1_CB3   :  8;               /*!< OSD1 Text Color-3 CB                                                  */
      __IO uint32_t  OSD1_CR3   :  8;               /*!< OSD1 Text Color-3 CR.                                                 */
    };
  };
  __I  uint32_t  RESERVED327;
  __O  uint16_t  OSD1_FONT_INIT_ADR;                /*!< Start address for read/write OSD1 SRAM when OSD1_EN=0. 
                                                         Note: If interrupt by CPU writing OSD-index, you must to write
                                                         this OSD-font address before writing OSD-font data.                   */
  __I  uint16_t  RESERVED328;
  __IO uint32_t  OSD1_FONT_DATA;                    /*!< SRAM read/write data Port for OSD1 SRAM. (544x32 bits) 
                                                         OSD font: 0-511. 
                                                         Row0 index buffer after sync: 512-519. 
                                                         Row1 index buffer after sync: 520-527. 
                                                         Row0 index buffer: 528-535. 
                                                         Row1 index buffer: 536-543.                                           */
  __I  uint32_t  RESERVED329[2];
  
  union {
    __IO uint32_t  REG_0x12C0;                      /*!< OSD1_LINE0_TEXT1                                                      */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT1:  6;          /*!< OSD1 Line 1 Text 1                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT2:  6;          /*!< OSD1 Line 1 Text 2                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT3:  6;          /*!< OSD1 Line 1 Text 3                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT4:  6;          /*!< OSD1 Line 1 Text 4                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12C4;                      /*!< OSD1_LINE0_TEXT5                                                      */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT5:  6;          /*!< OSD1 Line 1 Text 5                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT6:  6;          /*!< OSD1 Line 1 Text 6                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT7:  6;          /*!< OSD1 Line 1 Text 7                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT8:  6;          /*!< OSD1 Line 1 Text 8                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12C8;                      /*!< OSD1_LINE0_TEXT9                                                      */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT9:  6;          /*!< OSD1 Line 1 Text 9                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT10:  6;         /*!< OSD1 Line 1 Text 10                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT11:  6;         /*!< OSD1 Line 1 Text 11                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT12:  6;         /*!< OSD1 Line 1 Text 12                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12CC;                      /*!< OSD1_LINE0_TEXT13                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT13:  6;         /*!< OSD1 Line 1 Text 13                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT14:  6;         /*!< OSD1 Line 1 Text 14                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT15:  6;         /*!< OSD1 Line 1 Text 15                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT16:  6;         /*!< OSD1 Line 1 Text 16                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12D0;                      /*!< OSD1_LINE0_TEXT17                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT17:  6;         /*!< OSD1 Line 1 Text 17                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT18:  6;         /*!< OSD1 Line 1 Text 18                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT19:  6;         /*!< OSD1 Line 1 Text 19                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT20:  6;         /*!< OSD1 Line 1 Text 20                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12D4;                      /*!< OSD1_LINE0_TEXT21                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT21:  6;         /*!< OSD1 Line 1 Text 21                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT22:  6;         /*!< OSD1 Line 1 Text 22                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT23:  6;         /*!< OSD1 Line 1 Text 23                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT24:  6;         /*!< OSD1 Line 1 Text 24                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12D8;                      /*!< OSD1_LINE0_TEXT25                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT25:  6;         /*!< OSD1 Line 1 Text 25                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT26:  6;         /*!< OSD1 Line 1 Text 26                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT27:  6;         /*!< OSD1 Line 1 Text 27                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT28:  6;         /*!< OSD1 Line 1 Text 28                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12DC;                      /*!< OSD1_LINE0_TEXT29                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE0_TEXT29:  6;         /*!< OSD1 Line 1 Text 29                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT30:  6;         /*!< OSD1 Line 1 Text 30                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT31:  6;         /*!< OSD1 Line 1 Text 31                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE0_TEXT32:  6;         /*!< OSD1 Line 1 Text 32                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12E0;                      /*!< OSD1_LINE1_TEXT1                                                      */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT1:  6;          /*!< OSD1 Line 2 Text 1                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT2:  6;          /*!< OSD1 Line 2 Text 2                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT3:  6;          /*!< OSD1 Line 2 Text 3                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT4:  6;          /*!< OSD1 Line 2 Text 4                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12E4;                      /*!< OSD1_LINE1_TEXT5                                                      */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT5:  6;          /*!< OSD1 Line 2 Text 5                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT6:  6;          /*!< OSD1 Line 2 Text 6                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT7:  6;          /*!< OSD1 Line 2 Text 7                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT8:  6;          /*!< OSD1 Line 2 Text 8                                                    */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12E8;                      /*!< OSD1_LINE1_TEXT9                                                      */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT9:  6;          /*!< OSD1 Line 2 Text 9                                                    */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT10:  6;         /*!< OSD1 Line 2 Text 10                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT11:  6;         /*!< OSD1 Line 2 Text 11                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT12:  6;         /*!< OSD1 Line 2 Text 12                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12EC;                      /*!< OSD1_LINE1_TEXT13                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT13:  6;         /*!< OSD1 Line 2 Text 13                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT14:  6;         /*!< OSD1 Line 2 Text 14                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT15:  6;         /*!< OSD1 Line 2 Text 15                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT16:  6;         /*!< OSD1 Line 2 Text 16                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12F0;                      /*!< OSD1_LINE1_TEXT17                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT17:  6;         /*!< OSD1 Line 2 Text 17                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT18:  6;         /*!< OSD1 Line 2 Text 18                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT19:  6;         /*!< OSD1 Line 2 Text 19                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT20:  6;         /*!< OSD1 Line 2 Text 20                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12F4;                      /*!< OSD1_LINE1_TEXT21                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT21:  6;         /*!< OSD1 Line 2 Text 21                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT22:  6;         /*!< OSD1 Line 2 Text 22                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT23:  6;         /*!< OSD1 Line 2 Text 23                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT24:  6;         /*!< OSD1 Line 2 Text 24                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12F8;                      /*!< OSD1_LINE1_TEXT25                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT25:  6;         /*!< OSD1 Line 2 Text 25                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT26:  6;         /*!< OSD1 Line 2 Text 26                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT27:  6;         /*!< OSD1 Line 2 Text 27                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT28:  6;         /*!< OSD1 Line 2 Text 28                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x12FC;                      /*!< OSD1_LINE1_TEXT29                                                     */
    
    struct {
      __O  uint32_t  OSD1_LINE1_TEXT29:  6;         /*!< OSD1 Line 2 Text 29                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT30:  6;         /*!< OSD1 Line 2 Text 30                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT31:  6;         /*!< OSD1 Line 2 Text 31                                                   */
           uint32_t             :  2;
      __O  uint32_t  OSD1_LINE1_TEXT32:  6;         /*!< OSD1 Line 2 Text 32                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1300;                      /*!< CH0_FULL_FLAG                                                         */
    
    struct {
      __IO uint32_t  CH0_FULL_FLAG:  1;             /*!< 1: video pipe 1 buffer full, clear to 0 by writing 1 to this
                                                         bit                                                                   */
      __IO uint32_t  CH1_FULL_FLAG:  1;             /*!< 1: video pipe 2 buffer full, clear to 0 by writing 1 to this
                                                         bit                                                                   */
      __IO uint32_t  CH2_FULL_FLAG:  1;             /*!< 1: video pipe3 buffer full, clear to 0 by writing 1 to this
                                                         bit                                                                   */
      __IO uint32_t  CH3_FULL_FLAG:  1;             /*!< 1: 3DNR write buffer full, clear to 0 by writing 1 to this bit        */
      __IO uint32_t  CH4_EMPTY_FLAG:  1;            /*!< 1: 3DNR read buffer empty, clear to 0 by writing 1 to this bit        */
      __IO uint32_t  CH5_FULL_FLAG:  1;             /*!< 1: MD W0 write buffer full, clear to 0 by writing 1 to this
                                                         bit                                                                   */
      __IO uint32_t  CH6_EMPTY_FLAG:  1;            /*!< 1: MD W0 read buffer empty, clear to 0 by writing 1 to this
                                                         bit                                                                   */
      __IO uint32_t  CH7_FULL_FLAG:  1;             /*!< 1: MD W1 write buffer full, clear to 0 by writing 1 to this
                                                         bit                                                                   */
      __IO uint32_t  CH8_FULL_FLAG:  1;             /*!< 1: MD W2 write buffer full, clear to 0 by writing 1 to this
                                                         bit                                                                   */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1304;                      /*!< FF_FULL_0                                                             */
    
    struct {
      __I  uint32_t  FF_FULL_0  :  1;               /*!< Color tran 0 full (path1 fifo full)                                   */
      __I  uint32_t  FF_FULL_1  :  1;               /*!< Color tran 1 full (path2 fifo full)                                   */
      __I  uint32_t  FF_FULL_2  :  1;               /*!< Color tran 2 full (path3 fifo full)                                   */
    };
  };
  __I  uint32_t  Version;                           /*!< Year/Month/Day                                                        */
  __I  uint32_t  RESERVED330[61];
  
  union {
    __IO uint32_t  REG_0x1400;                      /*!< YUV_SCALE_EN                                                          */
    
    struct {
      __IO uint32_t  YUV_SCALE_EN:  1;              /*!< YUV scale enable 1: enable, 0: disable                                */
      __IO uint32_t  YUV_SCALE_NTSEL:  2;           /*!< DIS scaler dummy line output DSTB interval: 
                                                         0: 1T burst output, 1: 2T DSTB output 
                                                         2: 3T burst output, 3: 4T DSTB output                                 */
      __IO uint32_t  DIS_DUM_SEL:  2;               /*!< DIS Feature Extraction dummy line output DSTB interval: 
                                                         0: 1T burst output, 1: 2T DSTB output 
                                                         2: 3T burst output, 3: 4T DSTB output                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1404;                      /*!< YUV_RATIO_H                                                           */
    
    struct {
      __IO uint32_t  YUV_RATIO_H: 11;               /*!< Scaled image width has to be greater or equal to 320. 
                                                         Range:128/(128~2047)                                                  */
           uint32_t             :  5;
      __IO uint32_t  YUV_RATIO_V: 11;               /*!< Scaled image height has to be greater or equal to 240. 
                                                         Range:128/(128~2047)                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1408;                      /*!< DUMMY_BLANK                                                           */
    
    struct {
      __IO uint32_t  DUMMY_BLANK: 10;               /*!< Dummy line blank for DIS scaler. (unit: 1 ISP_CLK cycle)              */
           uint32_t             :  6;
      __IO uint32_t  DIS_DUM_BLK:  9;               /*!< Dummy line blank for DIS FE. (unit: 1 ISP_CLK cycle)                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x140C;                      /*!< DIS_EN                                                                */
    
    struct {
      __IO uint32_t  DIS_EN     :  1;               /*!< DIS enable 1: enable 0: disable                                       */
      __IO uint32_t  GRAY_LEVEL_DIFF:  5;           /*!< Fast threshold                                                        */
      __IO uint32_t  CONSECUTIVE_NUM:  4;           /*!< Consecutive bright/dark number                                        */
      __IO uint32_t  FE_NON_MAX_WIN_WIDTH:  5;      /*!< Maximum of the window size for horizontal domain                      */
      __IO uint32_t  BRIEF_NOISE_VAR:  4;           /*!< Brief threshold                                                       */
      __IO uint32_t  FE_BLK_WIDTH_BIT:  3;          /*!< Block window width = 2^FE_BLK_WIDTH_BIT, the range is limited
                                                         
                                                         to [4,5]                                                              */
      __IO uint32_t  FE_BLK_HEIGT_BIT:  3;          /*!< Block window height = 2^FE_BLK_HEIGHT_BIT, the range is limited
                                                         
                                                         To [4,5]                                                              */
      __IO uint32_t  FE_BLK_MAX_IN_IP_NUM:  3;      /*!< Capture the maximum number of feature points in each block window.    */
      __I  uint32_t  DIS_TRANS_READY:  1;           /*!< DIS transfer ready                                                    */
      __IO uint32_t  DIS_TRANS_READY_CLR:  1;       /*!< Write 1 to clear the DIS_TRANS_READY flag                             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1410;                      /*!< MATCH_MTCH_THRS                                                       */
    
    struct {
      __IO uint32_t  MATCH_MTCH_THRS:  7;           /*!< The similar degree of feature points between blocks. 
                                                         The range is limited to [20,127]                                      */
      __IO uint32_t  MATCH_NND  :  5;               /*!< The similar degree of feature points in the same block. 
                                                         The range is limited to [0,31]                                        */
      __IO uint32_t  MATCH_SEARCH_R_X:  6;          /*!< The maximum of search range in horizontal. 
                                                         The range is limited to [0,63]                                        */
      __IO uint32_t  MATCH_SEARCH_R_Y:  6;          /*!< The maximum of search range in vertical. 
                                                         The range is limited to [0,63]                                        */
      __IO uint32_t  ME_NUM_IN_BITS:  3;            /*!< The maximum motion estimation number = 2^ ME_NUM_IN_BITS. 
                                                         The range is limited to [3,6].                                        */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1414;                      /*!< ME_SUFF_MATCHED_NUM                                                   */
    
    struct {
      __IO uint32_t  ME_SUFF_MATCHED_NUM:  6;       /*!< The range is limited to [6,63]                                        */
      __IO uint32_t  MATCH_MAX_PICK_NUM:  7;        /*!< Capture the maximum number of match IPs between the frames.           */
      __IO uint32_t  ME_SMOOTH_LEVEL:  5;           /*!< Smooth level: 0: non compensation.                                    */
      __IO uint32_t  ME_LEARNING_RATE:  5;          /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1418;                      /*!< ME_CUM_MAX_TRANS_0                                                    */
    
    struct {
      __IO uint32_t  ME_CUM_MAX_TRANS_0_0: 16;      /*!< Maximum of transition for path 1                                      */
      __IO uint32_t  ME_CUM_MAX_TRANS_0_1: 16;      /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x141C;                      /*!< ME_CUM_MAX_TRANS_1                                                    */
    
    struct {
      __IO uint32_t  ME_CUM_MAX_TRANS_1_0: 16;      /*!< Maximum of transition for path 2                                      */
      __IO uint32_t  ME_CUM_MAX_TRANS_1_1: 16;      /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1420;                      /*!< ME_CUM_MAX_TRANS_2                                                    */
    
    struct {
      __IO uint32_t  ME_CUM_MAX_TRANS_2_0: 16;      /*!< Maximum of transition for path 3                                      */
      __IO uint32_t  ME_CUM_MAX_TRANS_2_1: 16;      /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED331;
  
  union {
    __IO uint32_t  REG_0x1428;                      /*!< ME_TRANS_MODEL_0                                                      */
    
    struct {
      __I  uint32_t  ME_TRANS_MODEL_0_0: 16;        /*!< (null)                                                                */
      __I  uint32_t  ME_TRANS_MODEL_0_1: 16;        /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x142C;                      /*!< ME_TRANS_MODEL_1                                                      */
    
    struct {
      __I  uint32_t  ME_TRANS_MODEL_1_0: 16;        /*!< (null)                                                                */
      __I  uint32_t  ME_TRANS_MODEL_1_1: 16;        /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1430;                      /*!< ME_TRANS_MODEL_2                                                      */
    
    struct {
      __I  uint32_t  ME_TRANS_MODEL_2_0: 16;        /*!< (null)                                                                */
      __I  uint32_t  ME_TRANS_MODEL_2_1: 16;        /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1434;                      /*!< YUV_SCALE_HSTART                                                      */
    
    struct {
      __IO uint32_t  YUV_SCALE_HSTART: 12;          /*!< Window out horizontal start point for DIS scaler (Unit:1pixel)        */
           uint32_t             :  4;
      __IO uint32_t  YUV_SCALE_VSTART: 12;          /*!< Window out vertical start point for DIS scaler (Unit:1pixel)          */
    };
  };
  __IO uint32_t  ME_TRANS_MODE0;                    /*!< ME_TRANS_MODE0                                                        */
  __IO uint32_t  ME_TRANS_MODE1;                    /*!< ME_TRANS_MODE1                                                        */
  __I  uint32_t  RESERVED332[48];
  
  union {
    __IO uint32_t  REG_0x1500;                      /*!< EN                                                                    */
    
    struct {
      __IO uint32_t  EN         :  1;               /*!< Motion Detection enable 
                                                         0: disable 
                                                         1: enable                                                             */
      __IO uint32_t  EN_2ND_RPT :  1;               /*!< Motion Detection 2nd report enable 
                                                         0: disable 
                                                         1: enable                                                             */
           uint32_t             :  6;
      __IO uint32_t  INPUT_IMG_TYPE:  2;            /*!< Input image source type 
                                                         0: RGB 
                                                         1: YUV422 
                                                         Others: Reserved                                                      */
    };
  };
  __IO uint8_t   UPDATE_ENABLE;                     /*!< UPDATE_ENABLE                                                         */
  __I  uint8_t   RESERVED333[3];
  
  union {
    __IO uint32_t  REG_0x1508;                      /*!< MU_EXPAND_ACTIVE                                                      */
    
    struct {
      __IO uint32_t  MU_EXPAND_ACTIVE:  1;          /*!< Mean value compensation active 
                                                         0: De-active 
                                                         1: Active                                                             */
      __IO uint32_t  SCENE_STATE:  2;               /*!< The current scene context.                                            */
           uint32_t             :  5;
      __IO uint32_t  ALPHA      :  8;               /*!< Adaptivea learning rate of the model. 
                                                         Value range is 0 to 255, map to real value 0 to 0. 99609375.          */
      __IO uint32_t  ALPHA_BASE :  8;               /*!< Fixed initial learning rate of the model 
                                                         Value range is 0 to 255, map to real value 0 to 0. 99609375.          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x150C;                      /*!< H_STEP                                                                */
    
    struct {
      __IO uint32_t  H_STEP     : 10;               /*!< Scaling step of horizontal.a 
                                                         Value range is 170 to 1023.                                           */
           uint32_t             :  6;
      __IO uint32_t  V_STEP     : 10;               /*!< Scaling step of vertical 
                                                         Value range is 170 to 1023.                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1510;                      /*!< MU_EXPAND_EN                                                          */
    
    struct {
      __IO uint32_t  MU_EXPAND_EN:  1;              /*!< Mean value compensation function 
                                                         0: Disable 
                                                         1: Enable                                                             */
           uint32_t             :  1;
      __IO uint32_t  COMPENSATE_C1_MU_EN:  1;       /*!< C1 component compensation 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  COMPENSATE_C2_MU_EN:  1;       /*!< C2 component compensation 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  COMPENSATE_C3_MU_EN:  1;       /*!< C3 component compensation 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  COMPENSATE_G_MU_EN:  1;        /*!< Gradient component compensation 
                                                         0: Disable 
                                                         1: Enable                                                             */
           uint32_t             :  2;
      __IO uint32_t  MD2_REPORT_REG_COMPENSATION_GAIN_1:  8;/*!< Compensation slope 1 
                                                         Value range is 0 to 255, map to real value 0 to 3.984375.             */
      __IO uint32_t  MD2_REPORT_REG_COMPENSATION_GAIN_2:  8;/*!< Compensation slope 2 
                                                         Value range is 0 to 255, map to real value 0 to 3.984375.             */
      __IO uint32_t  MD2_REPORT_REG_COMPENSATION_GAIN_3:  8;/*!< Compensation slope 3 
                                                         Value range is 0 to 255, map to real value 0 to 3.984375.             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1514;                      /*!< COMPENSATION_KNEE_VALUE_1                                             */
    
    struct {
      __IO uint32_t  COMPENSATION_KNEE_VALUE_1:  8; /*!< Boundary value of compensation slope 1 
                                                         Value range is 0 to 255.                                              */
      __IO uint32_t  COMPENSATION_KNEE_VALUE_2:  8; /*!< Boundary value of compensation slope 2 
                                                         Value range is 0 to 255.                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1518;                      /*!< C1_WEIGHT                                                             */
    
    struct {
      __IO uint32_t  C1_WEIGHT  :  4;               /*!< Weight for color component c1 in Bg model (Y or R) 
                                                         Value range is 0 to 15, map to real value 0 to 1.875.                 */
      __IO uint32_t  C2_WEIGHT  :  4;               /*!< Weight for color component c2 in Bg model (U or G) 
                                                         Value range is 0 to 15, map to real value 0 to 1.875.                 */
      __IO uint32_t  C3_WEIGHT  :  4;               /*!< Weight for color component c3 in Bg model (V or B) 
                                                         Value range is 0 to 15, map to real value 0 to 1.875.                 */
      __IO uint32_t  G_WEIGHT   :  4;               /*!< Weight for gradient component in Bg model 
                                                         Value range is 0 to 15, map to real value 0 to 1.875.                 */
      __IO uint32_t  MATCH_COEFFICIENT:  4;         /*!< Match coefficient for transferring an estimated camera standard
                                                         deviation to Th_value.                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x151C;                      /*!< INI_STD_C                                                             */
    
    struct {
      __IO uint32_t  INI_STD_C  :  8;               /*!< Initial color components standard deviation for a reassigning
                                                         distribution                                                          */
      __IO uint32_t  INI_STD_G  :  8;               /*!< Initial gradient components standard deviation for a reassigning
                                                         distribution                                                          */
    };
  };
  __IO uint8_t   FG_RELATIONAL_ALPHA_EN;            /*!< Fg relation for alpha adaptation 
                                                         0: Disable 
                                                         1: Enable                                                             */
  __I  uint8_t   RESERVED334[3];
  
  union {
    __IO uint32_t  REG_0x1524;                      /*!< CLIP_LEARN_EN                                                         */
    
    struct {
      __IO uint32_t  CLIP_LEARN_EN:  1;             /*!< Extra low learning rate mode 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  CLIP_LEARN_TH: 12;             /*!< If cnt of ith model bigger than ClipLearnTh, then update weight
                                                         of ith model.                                                         */
      __IO uint32_t  MIN_VAR    : 12;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1528;                      /*!< TH_VALUE                                                              */
    
    struct {
      __IO uint32_t  TH_VALUE   :  8;               /*!< Threshold value associated with dark current noise                    */
      __IO uint32_t  TH_VALUE_EXTRA1:  8;           /*!< Threshold value associated with dark current noise of 2nd report      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x152C;                      /*!< TH_VALUE_MAX_NOISE                                                    */
    
    struct {
      __IO uint32_t  TH_VALUE_MAX_NOISE:  8;        /*!< Maximum Th_value against luminance component                          */
      __IO uint32_t  NOISE_SLOPE:  8;               /*!< Noise slope of luminance component 
                                                         Value range is 0 to 255, map to real value 0 to 0. 99609375.          */
      __IO uint32_t  ROI_EN     :  1;               /*!< Main ROI for threshold adaptation 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  ROI_EXTRA1_EN:  1;             /*!< 2nd ROI for threshold adaptation 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  DETECTION_PREFERENCE:  8;      /*!< Preference on better precision or better recall                       */
      __IO uint32_t  PRIOR_PDF_TH_MODE:  2;         /*!< prior knowledge for threshold adaptation mode 
                                                         0: Disable 
                                                         1: Half current 
                                                         2: Half current + half previous 
                                                         3: All previous                                                       */
      __IO uint32_t  PRIOR_PDF_STEP:  4;            /*!< Prior knowledge step used for increasing decreasing the value
                                                         "Th_value"                                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1530;                      /*!< ROI_WEIGHT_ADDR                                                       */
    
    struct {
      __IO uint32_t  ROI_WEIGHT_ADDR: 10;           /*!< Address of ROI weight for main report 
                                                         1.Read/write address for once access 
                                                         2.Start address for auto address increase mode 
                                                                                                                               */
      __IO uint32_t  ROI_WEIGHT_ADDR_INCR:  1;      /*!< Auto address increase mode of ROI weight for main report 
                                                         0: disable 
                                                         1: enable                                                             */
      __IO uint32_t  ROI_WEIGHT_RW:  1;             /*!< Access mode of ROI weight for main report 
                                                         0: read 
                                                         1: write                                                              */
    };
  };
  __IO uint32_t  ROI_WEIGHT_VALUE;                  /*!< Data of ROI weight for main report                                    */
  
  union {
    __IO uint32_t  REG_0x1538;                      /*!< ROI_EXT1_WEIGHT_ ADDR                                                 */
    
    struct {
      __IO uint32_t  ROI_EXT1_WEIGHT_ADDR: 10;      /*!< Address of ROI weight for 2nd report 
                                                         1.Read/write address for once access 
                                                         2.Start address for auto address increase mode                        */
      __IO uint32_t  ROI_EXT1_WEIGHT_ADDR_INCR:  1; /*!< Auto address increase mode of ROI weight for 2nd report 
                                                         0: disable 
                                                         1: enable                                                             */
      __IO uint32_t  ROI_EXT1_WEIGHT_RW:  1;        /*!< Access mode of ROI weight for 2nd report 
                                                         0: read 
                                                         1: write                                                              */
    };
  };
  __IO uint32_t  ROI_EXT1_WEIGHT_VALUE;             /*!< Data of ROI weight for 2nd report                                     */
  
  union {
    __IO uint32_t  REG_0x1540;                      /*!< ROI_INDEX_ADDR                                                        */
    
    struct {
      __IO uint32_t  ROI_INDEX_ADDR: 10;            /*!< Address of ROI index for main report                                  */
      __IO uint32_t  ROI_INDEX_ADDR_INCR:  1;       /*!< Auto address increase mode of ROI index for main report 
                                                         0: disable 
                                                         1: enable                                                             */
      __IO uint32_t  ROI_INDEX_RW:  1;              /*!< Access mode of ROI index for main report
                                                         0: read 
                                                         1: write                                                              */
    };
  };
  __IO uint32_t  ROI_INDEX_VALUE;                   /*!< Data of ROI index for main report                                     */
  
  union {
    __IO uint32_t  REG_0x1548;                      /*!< ROI_EXT1_INDEX_ADDR                                                   */
    
    struct {
      __IO uint32_t  ROI_EXT1_INDEX_ADDR: 10;       /*!< Address of ROI index for 2nd report                                   */
      __IO uint32_t  ROI_EXT1_INDEX_ADDR_INCR:  1;  /*!< Auto address increase mode of ROI index for 2nd report 
                                                         0: disable 
                                                         1: enable                                                             */
      __IO uint32_t  ROI_EXT1_INDEX_RW:  1;         /*!< Access mode of ROI index for 2nd report 
                                                         0: read 
                                                         1: write                                                              */
    };
  };
  __IO uint32_t  ROI_EXT1_INDEX_VALUE;              /*!< Data of ROI index for 2nd report                                      */
  
  union {
    __IO uint32_t  REG_0x1550;                      /*!< ROI_FGMASK_ADDR                                                       */
    
    struct {
      __IO uint32_t  ROI_FGMASK_ADDR: 10;           /*!< Address of foreground mask for main report 
                                                         5.Read/write address for once access 
                                                         6.Start address for auto address increase mode                        */
      __IO uint32_t  ROI_FGMASK_ADDR_INCR:  1;      /*!< Auto address increase mode of foreground mask for main report
                                                         
                                                         0: disable 
                                                         1: enablea                                                            */
      __IO uint32_t  ROI_FGMASK_RW:  1;             /*!< Access mode of foreground mask for main report
                                                         0: read 
                                                         1: write                                                              */
    };
  };
  __IO uint32_t  ROI_FGMASK_VALUE;                  /*!< Data of foreground mask for main report                               */
  
  union {
    __IO uint32_t  REG_0x1558;                      /*!< ROI_EXT1_FGMASK_ADDR                                                  */
    
    struct {
      __IO uint32_t  ROI_EXT1_FGMASK_ADDR: 10;      /*!< Address of foreground mask for 2nd report 
                                                         7.Read/write address for once access 
                                                         8.Start address for auto address increase mode                        */
      __IO uint32_t  ROI_EXT1_FGMASK_ADDR_INCR:  1; /*!< Auto address increase mode of foreground mask for 2nd report
                                                         
                                                         0: disable 
                                                         1: enable                                                             */
      __IO uint32_t  ROI_EXT1_FGMASK_RW:  1;        /*!< Access mode of foreground mask for 2nd report 
                                                         0: read 
                                                         1: write                                                              */
    };
  };
  __IO uint32_t  ROI_EXT1_FGMASK_VALUE;             /*!< Data of foreground mask for 2nd report                                */
  
  union {
    __IO uint32_t  REG_0x1560;                      /*!< MULTI_MODAL_BG_ENABLE                                                 */
    
    struct {
      __IO uint32_t  MULTI_MODAL_BG_ENABLE:  1;     /*!< Decision Method 
                                                         0: Max modela 
                                                         1: Boundary model                                                     */
      __IO uint32_t  TH_PDF     :  8;               /*!< Threshold value for background decision                               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1564;                      /*!< MORPH_FILTER_CONFIG                                                   */
    
    struct {
      __IO uint32_t  MORPH_FILTER_CONFIG:  1;       /*!< Enable morphological post-processing for Fg/Bg bitmap 
                                                         0: Disable 
                                                         1: Enable                                                             */
      __IO uint32_t  MORPH_CONFIG:  3;              /*!< Config the combination of dilation and erosion in stage 1 and
                                                         stage 2                                                               */
      __IO uint32_t  TEMPORAL_FILTER_MODE:  2;      /*!< Temporal Filter mode 
                                                         0: No filter 
                                                         1: Low speed object pass filter 
                                                         2. Temporal dilation filter                                           */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1568;                      /*!< IRQ_OK                                                                */
    
    struct {
      __IO uint32_t  IRQ_OK     :  1;               /*!< Interrupt, motion detection processed one frame 
                                                         Write 1 to clear this interrupt status.                               */
      __IO uint32_t  IRQ_ERR_01 :  1;               /*!< Interrupt, motion detection error 01 
                                                         Write 1 to clear this interrupt status.                               */
    };
  };
  __I  uint32_t  RESERVED335;
  __I  uint32_t  HIST_TOTAL;                        /*!< Number of used distributions in current image                         */
  __I  uint32_t  HIST_00;                           /*!< Match condition distribution of current image (00 segment)            */
  __I  uint32_t  HIST_01;                           /*!< Match condition distribution of current image (01 segment)            */
  __I  uint32_t  HIST_02;                           /*!< Match condition distribution of current image (02 segment)            */
  __I  uint32_t  HIST_03;                           /*!< Match condition distribution of current image (03 segment)            */
  __I  uint32_t  HIST_04;                           /*!< Match condition distribution of current image (04 segment)            */
  __I  uint32_t  HIST_05;                           /*!< Match condition distribution of current image (05 segment)            */
  __I  uint32_t  HIST_06;                           /*!< Match condition distribution of current image (06 segment)            */
  
  union {
    __IO uint32_t  REG_0x1590;                      /*!< REG1_CNT_00                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_00: 16;               /*!< Foreground counter of index 00 for main report                        */
      __I  uint32_t  REG1_CNT_01: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1594;                      /*!< REG1_CNT_02                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_02: 16;               /*!< Foreground counter of index 02 for main report                        */
      __I  uint32_t  REG1_CNT_03: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1598;                      /*!< REG1_CNT_04                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_04: 16;               /*!< Foreground counter of index 04 for main report                        */
      __I  uint32_t  REG1_CNT_05: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x159C;                      /*!< REG1_CNT_06                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_06: 16;               /*!< Foreground counter of index 06 for main report                        */
      __I  uint32_t  REG1_CNT_07: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15A0;                      /*!< REG1_CNT_08                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_08: 16;               /*!< Foreground counter of index 08 for main report                        */
      __I  uint32_t  REG1_CNT_09: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15A4;                      /*!< REG1_CNT_10                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_10: 16;               /*!< Foreground counter of index 10 for main report                        */
      __I  uint32_t  REG1_CNT_11: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15A8;                      /*!< REG1_CNT_12                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_12: 16;               /*!< Foreground counter of index 12 for main report                        */
      __I  uint32_t  REG1_CNT_13: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15AC;                      /*!< REG1_CNT_14                                                           */
    
    struct {
      __I  uint32_t  REG1_CNT_14: 16;               /*!< Foreground counter of index 14 for main report                        */
      __I  uint32_t  REG1_CNT_15: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15B0;                      /*!< REG2_CNT_00                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_00: 16;               /*!< Foreground counter of index 00 for 2nd report                         */
      __I  uint32_t  REG2_CNT_01: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15B4;                      /*!< REG2_CNT_02                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_02: 16;               /*!< Foreground counter of index 02 for 2nd report                         */
      __I  uint32_t  REG2_CNT_03: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15B8;                      /*!< REG2_CNT_04                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_04: 16;               /*!< Foreground counter of index 04 for 2nd report                         */
      __I  uint32_t  REG2_CNT_05: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15BC;                      /*!< REG2_CNT_06                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_06: 16;               /*!< Foreground counter of index 06 for 2nd report                         */
      __I  uint32_t  REG2_CNT_07: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15C0;                      /*!< REG2_CNT_08                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_08: 16;               /*!< Foreground counter of index 08 for 2nd report                         */
      __I  uint32_t  REG2_CNT_09: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15C4;                      /*!< REG2_CNT_10                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_10: 16;               /*!< Foreground counter of index 10 for 2nd report                         */
      __I  uint32_t  REG2_CNT_11: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15C8;                      /*!< REG2_CNT_12                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_12: 16;               /*!< Foreground counter of index 12 for 2nd report                         */
      __I  uint32_t  REG2_CNT_13: 16;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x15CC;                      /*!< REG2_CNT_14                                                           */
    
    struct {
      __I  uint32_t  REG2_CNT_14: 16;               /*!< Foreground counter of index 14 for 2nd report                         */
      __I  uint32_t  REG2_CNT_15: 16;               /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED336[12];
  
  union {
    __IO uint32_t  REG_0x1600;                      /*!< DRC_GAMMA_EN                                                          */
    
    struct {
      __IO uint32_t  DRC_GAMMA_EN:  1;              /*!< (null)                                                                */
           uint32_t             :  3;
      __IO uint32_t  PRE_DRC_GAMMA_SEL:  3;         /*!< DRC BAYER Gamma Group Selection: 
                                                         0: GAMMA0 ~ GAMMA3 
                                                         1: GAMMA4 ~ GAMMA7 
                                                         2: GAMMA8 ~ GAMMA11 
                                                         3: GAMMA12 ~ GAMMA15 
                                                         4: GAMMA16 ~ GAMMA19 
                                                         5: GAMMA20 ~ GAMMA23 
                                                         6: GAMMA24 ~ GAMMA27 
                                                         7: GAMMA28 ~ GAMMA29                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1604;                      /*!< BAYER_GAMMA0                                                          */
    
    struct {
      __IO uint32_t  BAYER_GAMMA0: 10;              /*!< Default: 
                                                         0~23 Gamma table: 
                                                         (0,16,32,64),(96,128,192,256),(320,384,448,512), 
                                                         (576,640,704,736),(768,800,832,864),(896,928,960,1023) 
                                                         0~29 Gamma table: 
                                                         (0,8,16,24),(32,40,48,56),(64,96,128,192), 
                                                         (256,320,384,448),(512,576,640,704),(736,768,800,832), 
                                                         (864,896,928,960),(992,1023,x,x)                                      */
           uint32_t             :  6;
      __IO uint32_t  BAYER_GAMMA1: 10;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1608;                      /*!< BAYER_GAMMA2                                                          */
    
    struct {
      __IO uint32_t  BAYER_GAMMA2: 10;              /*!< Default: 
                                                         0~23 Gamma table: 
                                                         (0,16,32,64),(96,128,192,256),(320,384,448,512), 
                                                         (576,640,704,736),(768,800,832,864),(896,928,960,1023) 
                                                         0~29 Gamma table: 
                                                         (0,8,16,24),(32,40,48,56),(64,96,128,192), 
                                                         (256,320,384,448),(512,576,640,704),(736,768,800,832), 
                                                         (864,896,928,960),(992,1023,x,x)                                      */
           uint32_t             :  6;
      __IO uint32_t  BAYER_GAMMA3: 10;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x160C;                      /*!< POST_DRC_GAMMA_SEL                                                    */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  POST_DRC_GAMMA_SEL:  3;        /*!< DRC BAYER INV Gamma Group Selection: 
                                                         0: GAMMA0 ~ GAMMA3 
                                                         1: GAMMA4 ~ GAMMA7 
                                                         2: GAMMA8 ~ GAMMA11 
                                                         3: GAMMA12 ~ GAMMA15 
                                                         4: GAMMA16 ~ GAMMA19 
                                                         5: GAMMA20 ~ GAMMA23 
                                                         6: GAMMA24 ~ GAMMA27 
                                                         7: GAMMA28 ~ GAMMA29                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1610;                      /*!< BAYER_INV_GAMMA0                                                      */
    
    struct {
      __IO uint32_t  BAYER_INV_GAMMA0: 10;          /*!< Default: 
                                                         0~23 Gamma table: 
                                                         (0,16,32,64),(96,128,192,256),(320,384,448,512), 
                                                         (576,640,704,736),(768,800,832,864),(896,928,960,1023) 
                                                         0~29 Gamma table: 
                                                         (0,8,16,24),(32,40,48,56),(64,96,128,192), 
                                                         (256,320,384,448),(512,576,640,704),(736,768,800,832), 
                                                         (864,896,928,960),(992,1023,x,x)                                      */
           uint32_t             :  6;
      __IO uint32_t  BAYER_INV_GAMMA1: 10;          /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1614;                      /*!< BAYER_INV_GAMMA2                                                      */
    
    struct {
      __IO uint32_t  BAYER_INV_GAMMA2: 10;          /*!< Default: 
                                                         0~23 Gamma table: 
                                                         (0,16,32,64),(96,128,192,256),(320,384,448,512), 
                                                         (576,640,704,736),(768,800,832,864),(896,928,960,1023) 
                                                         0~29 Gamma table: 
                                                         (0,8,16,24),(32,40,48,56),(64,96,128,192), 
                                                         (256,320,384,448),(512,576,640,704),(736,768,800,832), 
                                                         (864,896,928,960),(992,1023,x,x)                                      */
           uint32_t             :  6;
      __IO uint32_t  BAYER_INV_GAMMA3: 10;          /*!< (null)                                                                */
    };
  };
  __I  uint32_t  RESERVED337[11];
  
  union {
    __IO uint32_t  REG_0x1644;                      /*!< LSC_SCALE_FACTOR_B                                                    */
    
    struct {
      __IO uint32_t  LSC_SCALE_FACTOR_B: 11;        /*!< (null)                                                                */
           uint32_t             :  5;
      __IO uint32_t  LSC_SCALE_FACTOR_GB: 11;       /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1648;                      /*!< LSC_SCALE_FACTOR_GR                                                   */
    
    struct {
      __IO uint32_t  LSC_SCALE_FACTOR_GR: 11;       /*!< (null)                                                                */
           uint32_t             :  5;
      __IO uint32_t  LSC_SCALE_FACTOR_R: 11;        /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x164C;                      /*!< CIR_SHIFT0                                                            */
    
    struct {
      __IO uint32_t  CIR_SHIFT0 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT1 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT2 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT3 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT4 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT5 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT6 :  4;               /*!< (null)                                                                */
      __IO uint32_t  CIR_SHIFT7 :  4;               /*!< (null)                                                                */
    };
  };
  __IO uint8_t   CIR_FIELD_BIT;                     /*!< CIR_FIELD_BIT                                                         */
} SEN_Type;


/* ================================================================================ */
/* ================                      MIPI                      ================ */
/* ================================================================================ */


/**
  * @brief MIPI (MIPI)
  */

typedef struct {                                    /*!< MIPI Structure                                                        */
  
  union {
    __IO uint32_t  REG_0x1800;                      /*!< MIPI_EN                                                               */
    
    struct {
      __IO uint32_t  MIPI_EN    :  1;               /*!< 1:Enable MIPI receiver image capture.                                 */
      __IO uint32_t  MIPI_PD    :  1;               /*!< 1:Power down MIPI analog phy.                                         */
      __IO uint32_t  DLAN_NUM   :  2;               /*!< 0: Support to one data lane 
                                                         1: Support to two data lanes 
                                                         3:2: Reserved                                                         */
      __IO uint32_t  MIPI_TEST_MODE:  5;            /*!< MIPI test mode                                                        */
      __IO uint32_t  MIPI_TEST_EN:  1;              /*!< MIPI test enable                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1804;                      /*!< SOT_HS_ERR                                                            */
    
    struct {
      __IO uint32_t  SOT_HS_ERR :  1;               /*!< 1:Sync sequence is corrupted. 
                                                         (any one bit is not matched) 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  SOT_SYNC_HS_ERR:  1;           /*!< 1:Sync sequence is corrupted. 
                                                         (any proper synchronization can not be expected) 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  CTRL_ERR   :  1;               /*!< 1:Control error
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  ESC_ERR    :  1;               /*!< 1:Escape entry error 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  ECC_1BIT_ERR:  1;              /*!< 1:ECC check is only 1-bit error.(can be corrected) 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  ECC_MBIT_ERR:  1;              /*!< 1:ECC check over 1-bit error.(can not be corrected) 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  CRC_ERR    :  1;               /*!< 1:CRC check error 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  MIPI_ID_ERR:  1;               /*!< 1:Data ID is un-known. 
                                                         Set 1 to clear this bit to 0                                          */
      __I  uint32_t  MIPI_ENTRY0_RDY:  1;           /*!< 1:MIPI escape entry command is ready. 
                                                         (MIPI_ENTRY0_CMD can be read)                                         */
      __I  uint32_t  MIPI_ENTRY1_RDY:  1;           /*!< 1:MIPI escape entry command is ready. 
                                                         (MIPI_ENTRY1_CMD can be read)                                         */
           uint32_t             :  6;
      __I  uint32_t  DLAN0_ULPM :  1;               /*!< 1:Data Lane 0 enter ultra low power mode                              */
      __I  uint32_t  DLAN1_ULPM :  1;               /*!< 1 : Data Lane 1 enter ultra low power mode                            */
           uint32_t             :  2;
      __I  uint32_t  CKLAN_ULPM :  1;               /*!< 1:Clock Lane enter ultra low power mode.                              */
           uint32_t             :  3;
      __I  uint32_t  MIPI_CH_NUM:  2;               /*!< Indicate the Virtual channel number.                                  */
      __I  uint32_t  MIPI_IMG_FMT:  6;              /*!< MIPI data format. 
                                                         6'h00:Frame Start. 
                                                         6'h01:Frame End.
                                                         6'h02:Line Start.
                                                         6'h03:Line End.
                                                         6'h10:Null.
                                                         6'h11:Blanking Data.
                                                         6'h12:Embeded 8-bit non Image data.
                                                         6'h18:YUV 420 8-bit.(N/A)
                                                         6'h19:YUV 420 10-bit.(N/A)
                                                         6'h1a:Legacy YUV 420 8-bit.(N/A)
                                                         6'h1c:YUV 420 8-bit(Chroma Shifted Pixel Sampling)(N/A)
                                                         6'h1d:YUV420 10-bit(Chroma Shifted Pixel Sampling)(N/A)
                                                         6'h1e:YUV 422 8-bit.(N/A)
                                                         6'h1f: YUV 422 10-bit.(N/A)
                                                         6'h20:RGB444.(N/A)
                                                         6'h21:RGB555.(N/A)
                                                         6'h22:RGB565.(N/A)
                                                         6'h23:RGB666.(N/A)
                                                         6'h24:RGB888.(N/A)
                                                         6'h28                                                                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1808;                      /*!< HSYNC_MODE                                                            */
    
    struct {
      __IO uint32_t  HSYNC_MODE :  1;               /*!< 0:HSYNC depends on packet data type. 
                                                         1:HSYNC depends on line start and line end.                           */
      __IO uint32_t  BLANKING_MODE:  1;             /*!< 0:Ignore blanking data packet. 
                                                         1:Using the blanking packet for dummy lines                           */
      __I  uint32_t  MIPI_FF_ERR:  1;               /*!< 1:MIPI FIFO overrun.                                                  */
      __I  uint32_t  FRAME_SYNC_ERR:  1;            /*!< 1:Frame start is followed by a second frame start. (No frame
                                                         end)                                                                  */
      __I  uint32_t  LINE_SYNC_ERR:  1;             /*!< 1:Line start is followed by a second line start.(No line end)No
                                                         line start, but get a line end.                                       */
      __I  uint32_t  MIPI_DF0_ERR:  1;              /*!< 1:MIPI Delay FIFO 0 overfull                                          */
      __I  uint32_t  MIPI_DF1_ERR:  1;              /*!< 1:MIPI Delay FIFO 1 overfull                                          */
           uint32_t             :  2;
      __IO uint32_t  CLK_SEL0   :  1;               /*!< Delay cell selection for data lane delay                              */
      __IO uint32_t  CLK_SEL1   :  1;               /*!< Delay cell selection for data lane delay                              */
      __IO uint32_t  CLK_SEL2   :  1;               /*!< Delay cell selection for data lane delay                              */
      __IO uint32_t  CLK_SEL3   :  1;               /*!< Delay cell selection for data lane delay                              */
      __IO uint32_t  CLK_SEL4   :  1;               /*!< Delay cell selection for data lane delay                              */
      __IO uint32_t  TERM_EN    :  1;               /*!< 1: Force the clock lane and 2 data lanes termination to be enable.    */
      __IO uint32_t  DLAN_PDA_AUTO:  1;             /*!< 1:Data lane power down is depend on packet flow 
                                                         0:Always power on                                                     */
           uint32_t             :  8;
      __IO uint32_t  LINE_END_FLAG:  1;             /*!< 1:Line end 
                                                         Set 1 to clear this bit to 0                                          */
      __IO uint32_t  LINE_END_FLAG_EN:  1;          /*!< 1:Line end flag enable. 0:Line end flag disable.                      */
      __IO uint32_t  STATE_ERR_FLAG_EN:  1;         /*!< 1: State error flag enable. 0: State error flag disable.              */
      __IO uint32_t  MIPI_ENTRY_RDY_EN:  1;         /*!< 1: MIPI entry ready enable. 0: MIPI entry ready disable.              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x180C;                      /*!< DATA_LANE0_SEL0                                                       */
    
    struct {
      __IO uint32_t  DATA_LANE0_SEL0:  1;           /*!< Delay cell selection for data lane0 delay                             */
      __IO uint32_t  DATA_LANE0_SEL1:  1;           /*!< (null)                                                                */
      __IO uint32_t  DATA_LANE0_SEL2:  1;           /*!< (null)                                                                */
      __IO uint32_t  DATA_LANE0_SEL3:  1;           /*!< (null)                                                                */
      __IO uint32_t  DATA_LANE0_SEL4:  1;           /*!< (null)                                                                */
           uint32_t             :  3;
      __IO uint32_t  DATA_LANE1_SEL0:  1;           /*!< Delay cell selection for data lane1 delay                             */
      __IO uint32_t  DATA_LANE1_SEL1:  1;           /*!< (null)                                                                */
      __IO uint32_t  DATA_LANE1_SEL2:  1;           /*!< (null)                                                                */
      __IO uint32_t  DATA_LANE1_SEL3:  1;           /*!< (null)                                                                */
      __IO uint32_t  DATA_LANE1_SEL4:  1;           /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1810;                      /*!< STOP_STATE                                                            */
    
    struct {
      __I  uint32_t  STOP_STATE :  1;               /*!< 1: Clock lane enters stop state                                       */
      __I  uint32_t  STOP_STATE0:  1;               /*!< 1: Data lane 0 enters stop state                                      */
      __I  uint32_t  STOP_STATE1:  1;               /*!< 1: Data lane 1 enters stop state                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1814;                      /*!< MIPI_ENTRY0_CMD                                                       */
    
    struct {
      __I  uint32_t  MIPI_ENTRY0_CMD:  8;           /*!< MIPI data lane 0 enter escape entry mode command.                     */
      __I  uint32_t  MIPI_ENTRY1_CMD:  8;           /*!< MIPI data lane 1 enter escape entry mode command.                     */
      __O  uint32_t  CLR_MIPI_FF_ERR:  1;           /*!< Set 1 to clear MIPI_FIFO_ERR to 0                                     */
      __O  uint32_t  CLR_FRAME_SYNC_ERR:  1;        /*!< Set 1 to clear FRAME_SYNC_ERR to 0                                    */
      __O  uint32_t  CLR_LINE_SYNC_ERR:  1;         /*!< Set 1 to clear LINE_SYNC_ERR to 0                                     */
      __O  uint32_t  CLR_MIPI_DF0_ERR:  1;          /*!< Set 1 to clear MIPI_DF0_ERR to 0                                      */
      __O  uint32_t  CLR_MIPI_DF1_ERR:  1;          /*!< Set 1 to clear MIPI_DF1_ERR to 0                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x1818;                      /*!< AUTO_FW_DET_TRI                                                       */
    
    struct {
      __O  uint32_t  AUTO_FW_DET_TRI:  1;           /*!< Automatic/FW detection trigger signal.                                */
      __IO uint32_t  TRI_MODE   :  1;               /*!< Trigger mode. 1: Automatic trigger, 0: FW trigger.                    */
      __IO uint32_t  PACKET_CNT_SIZE:  5;           /*!< The number of packet count for FW/Auto detection. 
                                                         The packet count size is at least one packet.                         */
      __IO uint32_t  PHA_DET_EN :  1;               /*!< Phase detection enable 
                                                         1: Enable phase detection. 
                                                         0: Disable Phase detection.                                           */
      __I  uint32_t  PHASE_DET_RDY:  1;             /*!< 1: Phase detection ready. Set 1 to clear this bit to 0 
                                                         When phase detection ready = 1, the PHASE_DET_REPORT can be
                                                         read.                                                                 */
      __IO uint32_t  HS_TEST    :  1;               /*!< High speed test mode. 1: enable 0: disable.                           */
      __IO uint32_t  PHASE_FAIL_CONDITION:  2;      /*!< Phase fail condition. 
                                                         00: DPHY up or down is considered for phase fail. 
                                                         01: DPHY down is considered only for phase fail. 
                                                         Others: DPHY up is considered only for phase fail.                    */
      __IO uint32_t  SHRINK_1BYTE_DATA_SIZE:  1;    /*!< (null)                                                                */
      __O  uint32_t  CLR_PHASE_DET_RDY:  1;         /*!< Set 1 to clear PHASE_DET_RDY to 0                                     */
           uint32_t             :  2;
      __IO uint32_t  MANUAL_RX0_DET_EN:  1;         /*!< Manually set phase detection enable by FW for data lane0. 
                                                         Used in high speed test mode only.                                    */
      __IO uint32_t  MANUAL_RX0_CLR_RPT:  1;        /*!< Manually clear phase detection report by FW for data lane0.
                                                         
                                                         Used in high speed test mode only.                                    */
      __IO uint32_t  MANUAL_RX1_DET_EN:  1;         /*!< Manually set phase detection enable by FW for data lane1. 
                                                         Used in high speed test mode only.                                    */
      __IO uint32_t  MANUAL_RX1_CLR_RPT:  1;        /*!< Manually clear phase detection report by FW for data lane1.
                                                         
                                                         Used in high speed test mode only.                                    */
           uint32_t             :  4;
      __I  uint32_t  DPHY0_PHASE_UP:  1;            /*!< Data phase is faster based on clock domain for data lane0             */
      __I  uint32_t  DPHY0_PHASE_DN:  1;            /*!< Data phase is slower based on clock domain for data lane0             */
      __I  uint32_t  DPHY1_PHASE_UP:  1;            /*!< Data phase is faster based on clock domain for data lane1             */
      __I  uint32_t  DPHY1_PHASE_DN:  1;            /*!< Data phase is slower based on clock domain for data lane1             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x181C;                      /*!< DATA_CHANNEL0_SEL                                                     */
    
    struct {
      __IO uint32_t  DATA_CHANNEL0_SEL:  2;         /*!< Data lane channel 0 selection.                                        */
      __IO uint32_t  DATA_CHANNEL1_SEL:  2;         /*!< Data lane channel 1 selection.                                        */
      __IO uint32_t  DATA_CHANNEL2_SEL:  2;         /*!< Data lane channel 2 selection.                                        */
      __IO uint32_t  DATA_CHANNEL3_SEL:  2;         /*!< Data lane channel 2 selection.                                        */
           uint32_t             :  1;
      __IO uint32_t  DPN0_SEL   :  1;               /*!< DP0 and DN0 sequence. 1: DN0 first. 0: DP0 first.                     */
      __IO uint32_t  DPN1_SEL   :  1;               /*!< DP1 and DN1 sequence. 1: DN1 first. 0: DP1 first.                     */
      __IO uint32_t  DPN2_SEL   :  1;               /*!< DP2 and DN2 sequence. 1: DN2 first. 0: DP2 first.                     */
      __IO uint32_t  DPN3_SEL   :  1;               /*!< DP3 and DN3 sequence. 1: DN3 first. 0: DP3 first.                     */
      __IO uint32_t  MIPI_NO_PDDDEL:  1;            /*!< (null)                                                                */
      __IO uint32_t  MIPI_NO_PDDDEL_LP:  1;         /*!< (null)                                                                */
           uint32_t             :  1;
      __IO uint32_t  DLAN_PDD_LSCALE_SEL0:  6;      /*!< Data lane0 digital power down large-scale timing selection 
                                                         0:1T after termination enable 
                                                         1:2T after termination enable                                         */
           uint32_t             :  2;
      __IO uint32_t  DLANE_PDD_SSCALE_SEL0:  4;     /*!< Data lane0 digital power down small-scale timing selection.
                                                         
                                                         Each scale is represented as a period of mipi sensor clock.           */
      __IO uint32_t  CPN0_SEL   :  1;               /*!< CP0 and CN0 sequence. 1: CN first. 0: CP first.                       */
      __IO uint32_t  CPN1_SEL   :  1;               /*!< CP1 and CN1 sequence. 1: CN first. 0: CP first.                       */
      __IO uint32_t  CPN2_SEL   :  1;               /*!< CP2 and CN2 sequence. 1: CN first. 0: CP first.                       */
      __IO uint32_t  CPN3_SEL   :  1;               /*!< CP3 and CN3 sequence. 1: CN first. 0: CP first.                       */
    };
  };
  __I  uint32_t  PHASE_DET_REPORT0;                 /*!< Phase detection report for data lane0. 
                                                         Bit = 1 means that the data phase is faster/slower based on
                                                         the clock domain.                                                     */
  __I  uint32_t  PHASE_DET_REPORT1;                 /*!< Phase detection report for data lane1. 
                                                         Bit = 1 means that the data phase is faster/slower based on
                                                         the clock domain.                                                     */
  __I  uint32_t  RESERVED[2];
  
  union {
    __IO uint32_t  REG_0x1830;                      /*!< LANE0_CLK_SEL                                                         */
    
    struct {
      __IO uint32_t  LANE0_CLK_SEL:  1;             /*!< MIPI CLK source from channel 0 or 1.                                  */
      __IO uint32_t  LANE1_CLK_SEL:  1;             /*!< MIPI CLK source from channel 0 or 1.                                  */
      __IO uint32_t  LANE2_CLK_SEL:  1;             /*!< MIPI CLK source from channel 2 or 3.                                  */
      __IO uint32_t  LANE3_CLK_SEL:  1;             /*!< MIPI CLK source from channel 2 or 3.                                  */
      __IO uint32_t  EP_SD0     :  2;               /*!< Error report window option.                                           */
      __IO uint32_t  EP_SD1     :  2;               /*!< DP1 and DN1 sequence. 1: DN1 first. 0: DP1 first.                     */
      __IO uint32_t  EP_SD2     :  2;               /*!< DP2 and DN2 sequence. 1: DN2 first. 0: DP2 first.                     */
      __IO uint32_t  EP_SD3     :  2;               /*!< DP3 and DN3 sequence. 1: DN3 first. 0: DP3 first.                     */
      __IO uint32_t  PD_NO_VDD3318:  1;             /*!< ullPullPull -Low Control, only used on sensor power cut off
                                                         in MIPI PHY1/2.                                                       */
           uint32_t             :  3;
      __IO uint32_t  PRALL_PD   : 16;               /*!< Parallel interface input pull-low control.                            */
    };
  };
} MIPI_Type;


/* ================================================================================ */
/* ================                       LCD                      ================ */
/* ================================================================================ */


/**
  * @brief LCD / TV / OSD (LCD)
  */

typedef struct {                                    /*!< LCD Structure                                                         */
  
  union {
    __IO uint32_t  REG_0x9800_0000;                 /*!< 0x9800_0000                                                           */
    
    struct {
      __IO uint32_t  LCD_MODE   :  4;               /*!< Graphic LCD mode selection                                            */
           uint32_t             :  1;
      __IO uint32_t  TV_LCD_EN  :  1;               /*!< Enable TV/LCD timing controller.                                      */
      __IO uint32_t  OSD_EN     :  1;               /*!< Enable OSD.                                                           */
      __IO uint32_t  IMG0_EN    :  1;               /*!< 1: Enable image channel 0.
                                                          0: Disable.                                                          */
      __IO uint32_t  IMG1_EN    :  1;               /*!< 1: Enable image channel 1.
                                                          0: Disable.                                                          */
      __IO uint32_t  IMG2_EN    :  1;               /*!< 1: Enable image channel 2.
                                                          0: Disable.                                                          */
      __IO uint32_t  IMG3_EN    :  1;               /*!< 1: Enable image channel 3.
                                                          0: Disable.                                                          */
           uint32_t             : 10;
      __IO uint32_t  TEAR_IN_EN :  1;               /*!< 1:Enable tear effect input.
                                                         This bit is effective at LCD_MODE 3,4,5,6,9,11,14.
                                                         LCD_IO[27] will function as the tear effect input                     */
      __IO uint32_t  TEAR_INT_RIS:  1;              /*!< 1: Issue an interrupt at the rising edge of tear effect input.        */
      __I  uint32_t  LCD_OK     :  1;               /*!< LCD_OK is valid when using CPU interface mode.
                                                          In these mode,
                                                          LCD_OK=0 when TV_CD_EN=0;
                                                          LCD_OK=1 when TV_LCD_EN=1
                                                          and a frame of display data was written.                             */
      __I  uint32_t  LCD_LOW_BW :  1;               /*!< 1: LCD bandwidth is low.                                              */
      __I  uint32_t  LCD_HMI_ERR_FLAG:  1;          /*!< 1: LCD AMBA interface error.                                          */
      __IO uint32_t  LCD_INT_EN :  1;               /*!< LCD interrupt is level trigger
                                                          and triggered at the end of each frame.                              */
      __I  uint32_t  LCD_INT_FLAG:  1;              /*!< LCD interrupt flag.                                                   */
      __IO uint32_t  LCD_REG_RW :  1;               /*!< Select read / write mode for CPU 8/16-bit interface.                  */
      __O  uint32_t  CLR_LCD_LOW_BW:  1;            /*!< Write 1 to clear LCD_LOW_BW                                           */
      __O  uint32_t  CLR_LCD_HMI_ERR:  1;           /*!< Write 1 to clear LCD_HMI_ERR_FLAG                                     */
      __O  uint32_t  CLR_LCD_INT:  1;               /*!< Write 1 to clear LCD_INT_FLAG                                         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0004;                 /*!< 0x9800_0004                                                           */
    
    struct {
      __IO uint32_t  TEST_TV    :  1;               /*!< 1: Test mode for IC simulation.                                       */
      __IO uint32_t  TV_MODE    :  2;               /*!< 0: NTSC mode
                                                          1: NTSC 4.43 mode
                                                          2: PAL mode
                                                          3: PAL-M mode                                                        */
      __IO uint32_t  TV_PROG    :  1;               /*!< TV select progressive                                                 */
      __IO uint32_t  TV_SINC_EN :  1;               /*!< TV sinc filter enable                                                 */
      __IO uint32_t  TV_PATTERN :  3;               /*!< TV pattern output                                                     */
      __IO uint32_t  TV_MONO_Display:  1;           /*!< TV mono display mode                                                  */
      __IO uint32_t  TV_MONO_Burst:  1;             /*!< TV mono burst mode                                                    */
      __IO uint32_t  TV_INV     :  1;               /*!< Inverse TV output                                                     */
           uint32_t             :  5;
      __IO uint32_t  TV_W_CLIP  :  6;               /*!< White clip for Y+SETUP+VSYNC.
                                                          Clip level = (8 x TV_W_CLIP + 512) / 1024                            */
           uint32_t             :  2;
      __IO uint32_t  TV_BURST   :  7;               /*!< TV U/V burst level (2 level at 10 bits D/A)                           */
      __IO uint32_t  SEL_TV     :  1;               /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0008;                 /*!< 0x9800_0008                                                           */
    
    struct {
      __IO uint32_t  TV_SETUP   :  7;               /*!< TV setup level.
                                                          (4 level at 10 bits D/A)                                             */
           uint32_t             :  1;
      __IO uint32_t  TV_BLANK   :  7;               /*!< TV blank level.
                                                          (4 level at 10 bits D/A)                                             */
           uint32_t             :  1;
      __IO uint32_t  TV_Y_GAIN  :  7;               /*!< TV Y GAIN.
                                                          (GAIN=(64+TV_Y_GAIN)/128)                                            */
           uint32_t             :  1;
      __IO uint32_t  TV_UV_GAIN :  7;               /*!< TV UV GAIN.
                                                          (GAIN=1+TV_UV_GAIN/128)                                              */
    };
  };
  
  union {
    __IO uint16_t  REG_0x9800_000C;                 /*!< 0x9800_000C                                                           */
    
    struct {
      __IO uint16_t  TV_FLT_EN  :  1;               /*!< TV UV filter enable.                                                  */
      __IO uint16_t  TV_FLT_GAIN:  2;               /*!< Filter GAIN for UV filter.
                                                          (Divide Y_EDGE by 2^TV_FLT_GAIN)                                     */
      __IO uint16_t  TV_FLT_EDGE:  3;               /*!< Filter EDGE for UV filter.
                                                          (Substract 4 x TV_FLT_EDGE from Y_EDGE)                              */
      __IO uint16_t  TV_LPF_EN  :  1;               /*!< Enable TV UV LPF filter.                                              */
      __IO uint16_t  TV_COMP_MODE:  1;              /*!< (null)                                                                */
      __IO uint16_t  VDO_DAC_EN :  1;               /*!< Video DAC enable                                                      */
      __IO uint16_t  VDO_DAC_TP :  5;               /*!< VDAC test-mode input setting pin.                                     */
    };
  };
  __I  uint16_t  RESERVED;
  __IO uint16_t  LCD_CMD;                           /*!< 0x9800_0010
                                                          Write: Trigger to issue read/write command with RS=0
                                                          through 8080-series 8/16-bit interface.
                                                          If LCD_REG_RW=0, then
                                                          DB[7:0]=LCD_CMD[7:0]. (8080-series 8-bit)
                                                          DB[15:0]=LCD_CMD[15:0]. (8080-series 16-bit)
                                                          Read: Return the read data from 8080-series 8/16-bit interface.
                                                          Note: Reading/Writing data from/to LCD controller is only allowed
                                                         when TV_LCD_EN=0.                                                     */
  __I  uint16_t  RESERVED1;
  __IO uint16_t  LCD_DATA;                          /*!< 0x9800_000C
                                                          Write: Trigger to issue read/write command with RS=1
                                                          through8080-series 8/16-bit interface.
                                                          If LCD_REG_RW=0, then
                                                          DB[7:0]=LCD_DATA[7:0]. (8080-series 8-bit)
                                                          DB[15:0]=LCD_DATA[15:0]. (8080-series 16-bit)
                                                          Read: Return the read data from 8080-series 8/16-bit interface.
                                                          Note: Reading/Writing data from/to LCD controller is only allowed
                                                         when TV_LCD_EN=0.                                                     */
  __I  uint16_t  RESERVED2;
  
  union {
    __IO uint32_t  LCD_GPIO_O;                      /*!< 0x9800_0018
                                                          LCD I/O output when GPIO mode                                        */
    
    struct {
      __IO uint32_t  LCD_GPIO_O0:  1;               /*!< LCD IO 0 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O1:  1;               /*!< LCD IO 1 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O2:  1;               /*!< LCD IO 2 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O3:  1;               /*!< LCD IO 3 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O4:  1;               /*!< LCD IO 4 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O5:  1;               /*!< LCD IO 5 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O6:  1;               /*!< LCD IO 6 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O7:  1;               /*!< LCD IO 7 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O8:  1;               /*!< LCD IO 8 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O9:  1;               /*!< LCD IO 9 output when GPIO mode                                        */
      __IO uint32_t  LCD_GPIO_O10:  1;              /*!< LCD IO 10 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O11:  1;              /*!< LCD IO 11 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O12:  1;              /*!< LCD IO 12 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O13:  1;              /*!< LCD IO 13 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O14:  1;              /*!< LCD IO 14 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O15:  1;              /*!< LCD IO 15 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O16:  1;              /*!< LCD IO 16 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O17:  1;              /*!< LCD IO 17 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O18:  1;              /*!< LCD IO 18 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O19:  1;              /*!< LCD IO 19 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O20:  1;              /*!< LCD IO 20 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O21:  1;              /*!< LCD IO 21 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O22:  1;              /*!< LCD IO 22 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O23:  1;              /*!< LCD IO 23 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O24:  1;              /*!< LCD IO 24 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O25:  1;              /*!< LCD IO 25 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O26:  1;              /*!< LCD IO 26 output when GPIO mode                                       */
      __IO uint32_t  LCD_GPIO_O27:  1;              /*!< LCD IO 27 output when GPIO mode                                       */
    };
  };
  
  union {
    __IO uint32_t  LCD_GPIO_OE;                     /*!< 0x9800_001C
                                                          LCD I/O output enable when GPIO mode.
                                                          1: Enable
                                                          0: Disable                                                           */
    
    struct {
      __IO uint32_t  LCD_GPIO_OE0:  1;              /*!< LCD IO 0 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE1:  1;              /*!< LCD IO 1 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE2:  1;              /*!< LCD IO 2 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE3:  1;              /*!< LCD IO 3 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE4:  1;              /*!< LCD IO 4 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE5:  1;              /*!< LCD IO 5 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE6:  1;              /*!< LCD IO 6 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE7:  1;              /*!< LCD IO 7 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE8:  1;              /*!< LCD IO 8 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE9:  1;              /*!< LCD IO 9 output enable when GPIO mode.                                */
      __IO uint32_t  LCD_GPIO_OE10:  1;             /*!< LCD IO 10 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE11:  1;             /*!< LCD IO 11 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE12:  1;             /*!< LCD IO 12 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE13:  1;             /*!< LCD IO 13 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE14:  1;             /*!< LCD IO 14 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE15:  1;             /*!< LCD IO 15 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE16:  1;             /*!< LCD IO 16 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE17:  1;             /*!< LCD IO 17 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE18:  1;             /*!< LCD IO 18 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE19:  1;             /*!< LCD IO 19 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE20:  1;             /*!< LCD IO 20 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE21:  1;             /*!< LCD IO 21 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE22:  1;             /*!< LCD IO 22 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE23:  1;             /*!< LCD IO 23 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE24:  1;             /*!< LCD IO 24 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE25:  1;             /*!< LCD IO 25 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE26:  1;             /*!< LCD IO 26 output enable when GPIO mode.                               */
      __IO uint32_t  LCD_GPIO_OE27:  1;             /*!< LCD IO 27 output enable when GPIO mode.                               */
    };
  };
  
  union {
    __I  uint32_t  LCD_GPIO_I;                      /*!< REG_0x9800_0020
                                                         LCD IO 0 input when GPIO mode.                                        */
    
    struct {
      __I  uint32_t  LCD_GPIO_I0:  1;               /*!< LCD IO 0 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I1:  1;               /*!< LCD IO 1 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I2:  1;               /*!< LCD IO 2 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I3:  1;               /*!< LCD IO 3 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I4:  1;               /*!< LCD IO 4 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I5:  1;               /*!< LCD IO 5 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I6:  1;               /*!< LCD IO 6 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I7:  1;               /*!< LCD IO 7 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I8:  1;               /*!< LCD IO 8 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I9:  1;               /*!< LCD IO 9 input when GPIO mode.                                        */
      __I  uint32_t  LCD_GPIO_I10:  1;              /*!< LCD IO 10 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I11:  1;              /*!< LCD IO 11 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I12:  1;              /*!< LCD IO 12 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I13:  1;              /*!< LCD IO 13 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I14:  1;              /*!< LCD IO 14 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I15:  1;              /*!< LCD IO 15 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I16:  1;              /*!< LCD IO 16 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I17:  1;              /*!< LCD IO 17 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I18:  1;              /*!< LCD IO 18 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I19:  1;              /*!< LCD IO 19 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I20:  1;              /*!< LCD IO 20 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I21:  1;              /*!< LCD IO 21 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I22:  1;              /*!< LCD IO 22 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I23:  1;              /*!< LCD IO 23 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I24:  1;              /*!< LCD IO 24 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I25:  1;              /*!< LCD IO 25 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I26:  1;              /*!< LCD IO 26 input when GPIO mode.                                       */
      __I  uint32_t  LCD_GPIO_I27:  1;              /*!< LCD IO 27 input when GPIO mode.                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0024;                 /*!< 0x9800_0024                                                           */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  DISP0_STR_A: 30;               /*!< Start address of channel 0 input image. (Unit: 4 Bytes)               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0028;                 /*!< 0x9800_0028                                                           */
    
    struct {
      __IO uint32_t  DISP0_HI_START:  8;            /*!< Start address of channel n input image. (Unit: 4 pixels)              */
      __IO uint32_t  DISP0_VI_START: 10;            /*!< Vertical start line for original input image. (Unit: 1 line)          */
      __IO uint32_t  DISP0_HI_SIZE: 10;             /*!< Horizontal start pixel for original input image. (Unit: 4 pixels)     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_002C;                 /*!< 0x9800_002C                                                           */
    
    struct {
      __IO uint32_t  DISP0_H_SIZE: 10;              /*!< Horizontal pixel size for original input image. (Unit: 4 pixels)      */
           uint32_t             :  6;
      __IO uint32_t  DISP0_V_SIZE: 12;              /*!< Horizontal pixel size for captured image. (Unit: 1 line)              */
    };
  };
  __I  uint32_t  RESERVED3;
  
  union {
    __IO uint32_t  REG_0x9800_0034;                 /*!< 0x9800_0034                                                           */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  DISP1_STR_A: 30;               /*!< Start address of channel 1 input image. (Unit: 4 Bytes)               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0038;                 /*!< 0x9800_0038                                                           */
    
    struct {
      __IO uint32_t  DISP1_HI_START:  8;            /*!< Start address of channel n input image. (Unit: 4 pixels)              */
      __IO uint32_t  DISP1_VI_START: 10;            /*!< Vertical start line for original input image. (Unit: 1 line)          */
      __IO uint32_t  DISP1_HI_SIZE: 10;             /*!< Horizontal start pixel for original input image. (Unit: 4 pixels)     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_003C;                 /*!< 0x9800_003C                                                           */
    
    struct {
      __IO uint32_t  DISP1_H_SIZE: 10;              /*!< Horizontal pixel size for original input image. (Unit: 4 pixels)      */
           uint32_t             :  6;
      __IO uint32_t  DISP1_V_SIZE: 12;              /*!< Horizontal pixel size for captured image. (Unit: 1 line)              */
    };
  };
  __I  uint32_t  RESERVED4;
  
  union {
    __IO uint32_t  REG_0x9800_0044;                 /*!< 0x9800_0044                                                           */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  DISP2_STR_A: 30;               /*!< Start address of channel 2 input image. (Unit: 4 Bytes)               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0048;                 /*!< 0x9800_0048                                                           */
    
    struct {
      __IO uint32_t  DISP2_HI_START:  8;            /*!< Start address of channel n input image. (Unit: 4 pixels)              */
      __IO uint32_t  DISP2_VI_START: 10;            /*!< Vertical start line for original input image. (Unit: 1 line)          */
      __IO uint32_t  DISP2_HI_SIZE: 10;             /*!< Horizontal start pixel for original input image. (Unit: 4 pixels)     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_004C;                 /*!< 0x9800_004C                                                           */
    
    struct {
      __IO uint32_t  DISP2_H_SIZE: 10;              /*!< Horizontal pixel size for original input image. (Unit: 4 pixels)      */
           uint32_t             :  6;
      __IO uint32_t  DISP2_V_SIZE: 12;              /*!< Horizontal pixel size for captured image. (Unit: 1 line)              */
    };
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  REG_0x9800_0054;                 /*!< 0x9800_0054                                                           */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  DISP3_STR_A: 30;               /*!< Start address of channel 3 input image. (Unit: 4 Bytes)               */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0058;                 /*!< 0x9800_0058                                                           */
    
    struct {
      __IO uint32_t  DISP3_HI_START:  8;            /*!< Start address of channel n input image. (Unit: 4 pixels)              */
      __IO uint32_t  DISP3_VI_START: 10;            /*!< Vertical start line for original input image. (Unit: 1 line)          */
      __IO uint32_t  DISP3_HI_SIZE: 10;             /*!< Horizontal start pixel for original input image. (Unit: 4 pixels)     */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_005C;                 /*!< 0x9800_005C                                                           */
    
    struct {
      __IO uint32_t  DISP3_H_SIZE: 10;              /*!< Horizontal pixel size for original input image. (Unit: 4 pixels)      */
           uint32_t             :  6;
      __IO uint32_t  DISP3_V_SIZE: 12;              /*!< Horizontal pixel size for captured image. (Unit: 1 line)              */
    };
  };
  __I  uint32_t  RESERVED6;
  
  union {
    __IO uint32_t  REG_0x9800_0064;                 /*!< 0x9800_0064                                                           */
    
    struct {
      __IO uint32_t  LCD_FS0_EN :  1;               /*!< Settings of fine-scaler0 will be applied to channel 0 and 2.          */
      __IO uint32_t  LCD_FS0_HDUP_EN:  1;           /*!< 1: Duplicate each pixel at the last stage of fine-scaler.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
      __IO uint32_t  LCD_FS0_VDUP_EN:  1;           /*!< 1: Duplicate each line at the last stage of fine-scaler.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
      __IO uint32_t  LCD_FS0_FIR_EN:  1;            /*!< Horizontal LPF is enabled
                                                          if LCD_FSx_FIR_EN = 1
                                                          and(LCD_FSx_EN = 0 or LCD_FSx_HRATIO >= 128) Vertical LPF is
                                                         enabled if LCD_FSx_FIR_EN = 1
                                                          and (LCD_FSx_EN= 0 or LCD_FSx_VRATIO >= 128)
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
      __IO uint32_t  LCD_FS0_FIELD_MODE:  1;        /*!< 0:FIR and fine-scaling calculations are based on the whole frame.
                                                         1:FIR and fine-scaling calculations are based on fields.
                                                         It's useful for TV and BT modes which require FIR and scaler
                                                         to run faster by reducing a little bit of video qualities.            */
           uint32_t             :  9;
      __IO uint32_t  LCD_FS0_FIR0:  9;              /*!< Signed LPF coefficient for the current pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                         256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS0_FIR1:  9;              /*!< Signed LPF coefficient for 1st pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0068;                 /*!< 0x9800_0068                                                           */
    
    struct {
      __IO uint32_t  LCD_FS0_FIR2:  9;              /*!< Signed LPF coefficient for 2nd pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS0_FIR3:  9;              /*!< Signed LPF coefficient for 3rd pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS0_FIR4:  9;              /*!< Signed LPF coefficient for 4th pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_006C;                 /*!< 0x9800_006C                                                           */
    
    struct {
      __IO uint32_t  LCD_FS0_HRATIO: 10;            /*!< Horizontal scaling factor.
                                                          Effective ratio = 128 / LCD_FS0_HRATIO
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS0_VRATIO: 10;            /*!< Vertical scaling factor. Effective ratio = 128 / LCD_FS0_VRATIO
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0070;                 /*!< 0x9800_0070                                                           */
    
    struct {
      __IO uint32_t  LCD_FS0_HO_START: 12;          /*!< Horizontal start pixel of cropped output image.
                                                          (Unit: 1 pixel)Bit 0 always is 0 regardless of write data.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
           uint32_t             :  4;
      __IO uint32_t  LCD_FS0_VO_START: 12;          /*!< Vertical start line of cropping output image.
                                                          (Unit: 1 line)Settings of fine-scaler0 will be applied to channel
                                                         0 and 2.                                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0074;                 /*!< 0x9800_0074                                                           */
    
    struct {
      __IO uint32_t  LCD_FS0_HO_SIZE: 12;           /*!< Horizontal size of cropped output image.
                                                          (Unit: 1 pixel)Bit 0 always is 0 regardless of write data.
                                                          When horizontal LPF is enabled and horizontal duplication is
                                                         disabled,
                                                          max. value is 1368.
                                                          Otherwise,
                                                          max value is 2736.
                                                          If duplication is enabled,
                                                          the max value can be doubled.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
           uint32_t             :  4;
      __IO uint32_t  LCD_FS0_VO_SIZE: 12;           /*!< Vertical size of cropping output image.
                                                          (Unit: 1 line) Bit 0 always is 0 regardless of write data.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0078;                 /*!< 0x9800_0078                                                           */
    
    struct {
      __IO uint32_t  LCD_FS1_EN :  1;               /*!< Settings of fine-scaler0 will be applied to channel 0 and 2.          */
      __IO uint32_t  LCD_FS1_HDUP_EN:  1;           /*!< 1: Duplicate each pixel at the last stage of fine-scaler.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
      __IO uint32_t  LCD_FS1_VDUP_EN:  1;           /*!< 1: Duplicate each line at the last stage of fine-scaler.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
      __IO uint32_t  LCD_FS1_FIR_EN:  1;            /*!< Horizontal LPF is enabled
                                                          if LCD_FSx_FIR_EN = 1
                                                          and(LCD_FSx_EN = 0 or LCD_FSx_HRATIO >= 128) Vertical LPF is
                                                         enabled if LCD_FSx_FIR_EN = 1
                                                          and (LCD_FSx_EN= 0 or LCD_FSx_VRATIO >= 128)
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
      __IO uint32_t  LCD_FS1_FIELD_MODE:  1;        /*!< 0:FIR and fine-scaling calculations are based on the whole frame.
                                                         1:FIR and fine-scaling calculations are based on fields.
                                                         It's useful for TV and BT modes which require FIR and scaler
                                                         to run faster by reducing a little bit of video qualities.            */
           uint32_t             :  9;
      __IO uint32_t  LCD_FS1_FIR0:  9;              /*!< Signed LPF coefficient for the current pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                         256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS1_FIR1:  9;              /*!< Signed LPF coefficient for 1st pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_007C;                 /*!< 0x9800_007C                                                           */
    
    struct {
      __IO uint32_t  LCD_FS1_FIR2:  9;              /*!< Signed LPF coefficient for 2nd pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS1_FIR3:  9;              /*!< Signed LPF coefficient for 3rd pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS1_FIR4:  9;              /*!< Signed LPF coefficient for 4th pixel to the left, right, up,
                                                         and bottom pixel,
                                                          -256 ~ 255. FIR0 + 2*(FIR1 + FIR2 + FIR3 + FIR3) should be
                                                          256.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2          */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0080;                 /*!< 0x9800_0080                                                           */
    
    struct {
      __IO uint32_t  LCD_FS1_HRATIO: 10;            /*!< Horizontal scaling factor.
                                                          Effective ratio = 128 / LCD_FS0_HRATIO
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
      __IO uint32_t  LCD_FS1_VRATIO: 10;            /*!< Vertical scaling factor. Effective ratio = 128 / LCD_FS0_VRATIO
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0084;                 /*!< 0x9800_0084                                                           */
    
    struct {
      __IO uint32_t  LCD_FS1_HO_START: 12;          /*!< Horizontal start pixel of cropped output image.
                                                          (Unit: 1 pixel)Bit 0 always is 0 regardless of write data.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
           uint32_t             :  4;
      __IO uint32_t  LCD_FS1_VO_START: 12;          /*!< Vertical start line of cropping output image.
                                                          (Unit: 1 line)Settings of fine-scaler0 will be applied to channel
                                                         0 and 2.                                                              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0088;                 /*!< 0x9800_0088                                                           */
    
    struct {
      __IO uint32_t  LCD_FS1_HO_SIZE: 12;           /*!< Horizontal size of cropped output image.
                                                          (Unit: 1 pixel)Bit 0 always is 0 regardless of write data.
                                                          When horizontal LPF is enabled and horizontal duplication is
                                                         disabled,
                                                          max. value is 1368.
                                                          Otherwise,
                                                          max value is 2736.
                                                          If duplication is enabled,
                                                          the max value can be doubled.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
           uint32_t             :  4;
      __IO uint32_t  LCD_FS1_VO_SIZE: 12;           /*!< Vertical size of cropping output image.
                                                          (Unit: 1 line) Bit 0 always is 0 regardless of write data.
                                                          Settings of fine-scaler0 will be applied to channel 0 and 2.         */
    };
  };
  __I  uint32_t  RESERVED7[38];
  
  union {
    __IO uint32_t  REG_0x9800_0124;                 /*!< 0x9800_0124                                                           */
    
    struct {
      __IO uint32_t  LCD_HO_SIZE: 12;               /*!< Horizontal active pixel size for LCD output.
                                                          (Unit: 1 pixel)Usually, this is the resolution of panel.             */
           uint32_t             :  4;
      __IO uint32_t  LCD_VO_SIZE: 12;               /*!< Vertical active pixel size for LCD output.
                                                          (Unit: 1 line) Usually, this is the resolution of panel.             */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0128;                 /*!< 0x9800_0128                                                           */
    
    struct {
      __IO uint32_t  LCD_HT_START: 10;              /*!< Horizontal start number for Graphic LCD.
                                                          It is used to adjust the number of dummy pixels before horizontal
                                                         active region
                                                          (Unit: 1 pixel)In TV mode, non-zero LCD_HT_START shifts the
                                                          display horizontally.                                                */
           uint32_t             :  6;
      __IO uint32_t  LCD_VT_START:  8;              /*!< Vertical start number for Graphic LCD.
                                                          It is used to adjust the number of dummy lines before vertical
                                                         active region
                                                          (Unit: 1 line) In TV mode, non-zero LCD_VT_START shifts the
                                                          display vertically.                                                  */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_012C;                 /*!< 0x9800_012C                                                           */
    
    struct {
      __IO uint32_t  LCD_HT_DM_SIZE: 10;            /*!< It is used to adjust the number of dummy pixels
                                                          after horizontal activeregion.
                                                          Horizontal dummy pixel size for LCD output. (Unit: 1 pixel)          */
           uint32_t             :  6;
      __IO uint32_t  LCD_VT_DM_SIZE: 10;            /*!< It is used to adjust the number of dummy lines
                                                          after vertical active region.
                                                          Vertical dummy line size for LCD output. (Unit: 1 line)              */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0130;                 /*!< 0x9800_0130                                                           */
    
    struct {
      __IO uint32_t  LCD_PCK_SPEED:  8;             /*!< Pixel clock speed for LCD timing generator.
                                                          0 and 1 are invalid.
                                                          ASIC: FPCK = 400 MHz / LCD_PCK_SPEED
                                                          FPGA: FPCK = 100 MHz / LCD_PCK_SPEED                                 */
      __IO uint32_t  LCD_EVEN_RGB:  2;              /*!< RGB output sequence for even line of LCD output.
                                                          Note:
                                                          LCD_RGB_REVERSE=0 -> 00:RGB, 01:GBR, 1x:BRG
                                                          LCD_RGB_REVERSE=1 -> 00:BGR, 01:RBG, 1x:GRB                          */
      __IO uint32_t  LCD_ODD_RGB:  2;               /*!< RGB output sequence for odd line of LCD output.
                                                          Note:
                                                          LCD_RGB_REVERSE=0 -> 00:RGB, 01:GBR, 1x:BRG LCD_RGB_REVERSE=1
                                                         -> 00:BGR, 01:RBG, 1x:GRB                                             */
      __IO uint32_t  LCD_RGB_REVERSE:  1;           /*!< Reverse RGB output sequence.                                          */
      __IO uint32_t  LCD_HSYNC_HIGH:  1;            /*!< 1: HSYNC is high active for LCD output.                               */
      __IO uint32_t  LCD_VSYNC_HIGH:  1;            /*!< 1: VSYNC is high active for LCD output                                */
      __IO uint32_t  LCD_DE_HIGH:  1;               /*!< 1: DE is high active for LCD output.
                                                          This bit is referenced only when LCD_MODE=8.                         */
      __IO uint32_t  LCD_PCK_RIS:  1;               /*!< 1: LCD data is latch at rising edge of pixel clock for LCD output.    */
      __IO uint32_t  SEL_UV     :  1;               /*!< Valid in sensor interface,
                                                          BT656 and BT601 mode.
                                                                                                                               */
      __IO uint32_t  LCD_Y_GAMMA_EN:  1;            /*!< 1: Enable gamma.                                                      */
      __IO uint32_t  LCD_UV_GAIN_EN:  1;            /*!< 1: Enable UV gain.                                                    */
      __IO uint32_t  DITHER_EN  :  1;               /*!< 1: Enable dithering function                                          */
      __IO uint32_t  DITHER_MODE:  1;               /*!< (null)                                                                */
      __IO uint32_t  DITHER_RAND_EN:  1;            /*!< 1: Random enable                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0134;                 /*!< 0x9800_0134                                                           */
    
    struct {
      __IO uint32_t  LCD_HS_WIDTH:  8;              /*!< LCD HSYNC pulse width.
                                                          (Unit: 1 pixel period)                                               */
      __IO uint32_t  LCD_VS_WIDTH:  4;              /*!< LCD VSYNC pulse width.
                                                          (Unit: 1 line period)                                                */
           uint32_t             :  4;
      __IO uint32_t  LCD_WL_WIDTH:  4;              /*!< Low pulse width for CSTN LCD write.
                                                          (Unit: 1 pixel clock)                                                */
      __IO uint32_t  LCD_WH_WIDTH:  4;              /*!< High pulse width for CSTN LCD write.
                                                          (Unit: 1 pixel clock)                                                */
      __IO uint32_t  LCD_RL_WIDTH:  4;              /*!< Low pulse width for CSTN LCD read.
                                                          (Unit: 1 pixel clock)                                                */
      __IO uint32_t  LCD_RH_WIDTH:  4;              /*!< High pulse width for CSTN LCD read.
                                                          (Unit: 1 pixel clock)                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0138;                 /*!< 0x9800_0138                                                           */
    
    struct {
      __IO uint32_t  LCD_Y_GAMMA0:  8;              /*!< Y0 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA1:  8;              /*!< Y1 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA2:  8;              /*!< Y2 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA3:  8;              /*!< Y3 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_013C;                 /*!< 0x9800_013C                                                           */
    
    struct {
      __IO uint32_t  LCD_Y_GAMMA4:  8;              /*!< Y4 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA5:  8;              /*!< Y5 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA6:  8;              /*!< Y6 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA7:  8;              /*!< Y7 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0140;                 /*!< 0x9800_0140                                                           */
    
    struct {
      __IO uint32_t  LCD_Y_GAMMA8:  8;              /*!< Y8 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA9:  8;              /*!< Y9 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA10:  8;             /*!< Y10 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA11:  8;             /*!< Y11 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0144;                 /*!< 0x9800_0144                                                           */
    
    struct {
      __IO uint32_t  LCD_Y_GAMMA12:  8;             /*!< Y12 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA13:  8;             /*!< Y13 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA14:  8;             /*!< Y14 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint32_t  LCD_Y_GAMMA15:  8;             /*!< Y15 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
    };
  };
  
  union {
    __IO uint16_t  REG_0x9800_0148;                 /*!< 0x9800_0148                                                           */
    
    struct {
      __IO uint16_t  LCD_Y_GAMMA16:  8;             /*!< Y16 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
      __IO uint16_t  LCD_Y_GAMMA17:  8;             /*!< Y17 for LCD Y gamma.
                                                          (Unit: 1 level at 8 bits image)                                      */
    };
  };
  __I  uint16_t  RESERVED8;
  
  union {
    __IO uint32_t  REG_0x9800_014C;                 /*!< 0x9800_014C
                                                          Ui = Cb - 128
                                                          Vi = Cr - 128
                                                          Uo = Lim{(Ui * GAIN0 + Vi * GAIN1)>>6, -128, 127}
                                                          Vo = Lim{(Ui * GAIN2 + Vi * GAIN3)>>6, -128, 127}                    */
    
    struct {
      __IO uint32_t  LCD_UV_GAIN0:  8;              /*!< (null)                                                                */
      __IO uint32_t  LCD_UV_GAIN1:  8;              /*!< (null)                                                                */
      __IO uint32_t  LCD_UV_GAIN2:  8;              /*!< (null)                                                                */
      __IO uint32_t  LCD_UV_GAIN3:  8;              /*!< (null)                                                                */
    };
  };
  
  union {
    __IO uint8_t   REG_0x9800_0150;                 /*!< 0x9800_0150                                                           */
    
    struct {
      __IO uint8_t   LCD_OSD_WT :  3;               /*!< OSD weighting. (Range: 0-7)
                                                          Note: LCD/TV output = (OSD_WT x OSD + (8 - OSD_WT) x IMG) /
                                                         8.                                                                    */
      __IO uint8_t   LCD_OSD_H_SIZE:  2;            /*!< OSD horizontal pixel size                                             */
      __IO uint8_t   LCD_OSD_V_SIZE:  2;            /*!< OSD vertical pixel size.                                              */
    };
  };
  __I  uint8_t   RESERVED9[3];
  __IO uint16_t  OSD_LINE_SIZE;                     /*!< 0x9800_0154
                                                          OSD_LINE_SIZE = (LCD_HO_SIZE / (OSD_H_SIZE + 1) + 3) >> 2
                                                          Unit: 4 bytes                                                        */
  __I  uint16_t  RESERVED10[3];
  __O  uint8_t   LCD_PALETTE_RD_TRG;                /*!< 0x9800_015C
                                                          0: Read the palette data.
                                                          1: Write data into the palette.
                                                          Note:
                                                          To write data into palette:
                                                          1. Let TV_LCD_EN = 0
                                                          2. Set PALETTE_A
                                                          3. Write PALETTE_D[15:0]
                                                          (PALETTE_A increased by 1 automatically if AUTO_INC_PALETTE_A=1.)
                                                          To read the palette:
                                                          1. Let TV_LCD_EN = 0
                                                          2. Set PALETTE_A
                                                          3. PALETTE_RD_TRG
                                                          (PALETTE_A increased by 1 automatically if AUTO_INC_PALETTE_A=1.)
                                                          4. Read PALETTE_D[15:0]                                              */
  __I  uint8_t   RESERVED11[3];
  
  union {
    __IO uint32_t  REG_0x9800_0160;                 /*!< 0x9800_0160                                                           */
    
    struct {
      __IO uint32_t  LCD_PALETTE_A:  8;             /*!< OSD palette address.                                                  */
           uint32_t             : 23;
      __IO uint32_t  LCD_AUTO_INC_PALETTE_A:  1;    /*!< 1: Increase PALETTE_A automatically.                                  */
    };
  };
  __IO uint16_t  LCD_PALETTE_D;                     /*!< 0x9800_0164
                                                                                                                               */
  __I  uint16_t  RESERVED12;
  
  union {
    __IO uint8_t   REG_0x9800_0168;                 /*!< 0x9800_0168                                                           */
    
    struct {
      __IO uint8_t   BT_MODE    :  2;               /*!< 0: BT601 11-pin
                                                         1: BT601 19-pin
                                                         2: BT656 9-pin
                                                         3: Reserved. Don't use it.
                                                         Note:
                                                         In BT656/601 mode,
                                                         it's necessary to set 2254h~225Fh.
                                                         Those settings are frame-based
                                                         and the line is numbered from the first line of field1
                                                         which is 0 to the last line of field1
                                                         and then from the first line of field2 to the last line of field2
                                                         which is LCD_VT_SIZE-1.
                                                         The number of lines per frame is determined by LCD_VT_SIZE.
                                                         LCD_HT_START is counted from the end of HSYNC.
                                                         For BT656 and BT601 11-pin:
                                                         HSYNC duration = LCD_HS_WIDT                                          */
      __IO uint8_t   BT_PROG    :  1;               /*!< 0: Interlaced BT
                                                         1: Progressive BT                                                     */
    };
  };
  __I  uint8_t   RESERVED13[3];
  __IO uint16_t  BT_VS1_ST;                         /*!< 0x9800_016C
                                                          Field1 VSYNC start. Reference value:
                                                          NTSC: 0, PAL: 0
                                                          Unit: line                                                           */
  __I  uint16_t  RESERVED14;
  __IO uint16_t  BT_VS1_END;                        /*!< 0x9800_0170
                                                          Field1 VSYNC end.
                                                          Reference value:
                                                          NTSC: 19, PAL: 24
                                                          Unit: line                                                           */
  __I  uint16_t  RESERVED15;
  __IO uint16_t  BT_VS2_ST;                         /*!< 0x9800_0174
                                                          Field2 VSYNC start.
                                                          Reference value:
                                                          NTSC: 263, PAL: 312
                                                          Unit: line                                                           */
  __I  uint16_t  RESERVED16;
  __IO uint16_t  BT_VS2_END;                        /*!< 0x9800_0178
                                                          Field1 VSYNC end.
                                                          Reference value:
                                                          NTSC: 282, PAL: 337
                                                          Unit: line                                                           */
  __I  uint16_t  RESERVED17;
  __IO uint16_t  BT_FLD1;                           /*!< 0x9800_017C
                                                          The line at which field1 identification changes.
                                                          Reference value:
                                                          NTSC: 3, PAL: 2
                                                          Unit: line                                                           */
  __I  uint16_t  RESERVED18;
  __IO uint16_t  BT_FLD2;                           /*!< 0x9800_0180
                                                          The line at which field2 identification changes.
                                                          Reference value:
                                                          NTSC: 265, PAL: 314
                                                          Unit: line                                                           */
  __I  uint16_t  RESERVED19;
  
  union {
    __IO uint32_t  REG_0x9800_0184;                 /*!< 0x9800_0184                                                           */
    
    struct {
      __IO uint32_t  WND0_X_START: 12;              /*!< X start position of window n, includsive.
                                                          (Unit: 1 pixel)                                                      */
           uint32_t             :  4;
      __IO uint32_t  WND0_Y_START: 12;              /*!< Y start position of window n, includsive.
                                                         (Unit: 1 pixel)                                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0188;                 /*!< 0x9800_0188                                                           */
    
    struct {
      __IO uint32_t  WND1_X_START: 12;              /*!< X start position of window n, includsive.
                                                          (Unit: 1 pixel)                                                      */
           uint32_t             :  4;
      __IO uint32_t  WND1_Y_START: 12;              /*!< Y start position of window n, includsive.
                                                         (Unit: 1 pixel)                                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_018C;                 /*!< 0x9800_018C                                                           */
    
    struct {
      __IO uint32_t  WND2_X_START: 12;              /*!< X start position of window n, includsive.
                                                          (Unit: 1 pixel)                                                      */
           uint32_t             :  4;
      __IO uint32_t  WND2_Y_START: 12;              /*!< Y start position of window n, includsive.
                                                         (Unit: 1 pixel)                                                       */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_0190;                 /*!< 0x9800_0190                                                           */
    
    struct {
      __IO uint32_t  WND3_X_START: 12;              /*!< X start position of window n, includsive.
                                                         (Unit: 1 pixel)                                                       */
           uint32_t             :  4;
      __IO uint32_t  WND3_Y_START: 12;              /*!< Y start position of window n, includsive.
                                                         (Unit: 1 pixel)                                                       */
    };
  };
  __I  uint32_t  RESERVED20[12];
  
  union {
    __IO uint32_t  REG_0x9800_01C4;                 /*!< 0x9800_01C4                                                           */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  OSD_STR_A  : 30;               /*!< Start address of OSD data.
                                                          (Unit: 4 Bytes)                                                      */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_01C8;                 /*!< 0x9800_01C8                                                           */
    
    struct {
      __IO uint32_t  OSD_X_START: 12;               /*!< X start position of OSD,
                                                          includsive. (Unit: 1 pixel)                                          */
           uint32_t             :  4;
      __IO uint32_t  OSD_X_END  : 12;               /*!< X end position of OSD,
                                                          exclusive. (Unix: 1 line)                                            */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_01CC;                 /*!< 0x9800_01CC                                                           */
    
    struct {
      __IO uint32_t  OSD_Y_START: 12;               /*!< Y start position of OSD, includsive. (Unit: 1 pixel)
                                                         Note: In the interlaced mode, OSD_Y_START must be even.               */
           uint32_t             :  4;
      __IO uint32_t  OSD_Y_END  : 12;               /*!< Y end position of OSD,exclusive. (Unix: 1 line)
                                                         Note: In the interlaced mode, OSD_Y_END must be even.                 */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_01D0;                 /*!< 0x9800_01D0                                                           */
    
    struct {
      __IO uint32_t  TEST_Y     :  8;               /*!< TV test image Y input                                                 */
      __IO uint32_t  TEST_CB    :  8;               /*!< TV test image Cb input                                                */
      __IO uint32_t  TEST_CR    :  8;               /*!< TV test image Cr input                                                */
    };
  };
  
  union {
    __IO uint32_t  REG_0x9800_01D4;                 /*!< 0x9800_01D4                                                           */
    
    struct {
      __IO uint32_t  DEFAULT_BG_Y:  8;              /*!< Default background color if no pixel output                           */
      __IO uint32_t  DEFAULT_BG_CB:  8;             /*!< Default background color if no pixel output                           */
      __IO uint32_t  DEFAULT_BG_CR:  8;             /*!< Default background color if no pixel output                           */
    };
  };
  
  union {
    __IO uint8_t   REG_0x9800_01D8;                 /*!< 0x9800_01D8                                                           */
    
    struct {
      __IO uint8_t   LCD_JPEG_DEC_EN:  1;           /*!< 1: Enable JPEG decoder                                                */
      __IO uint8_t   LCD_JPEG_CH:  2;               /*!< Select a channel to use the JPEG decoder                              */
      __IO uint8_t   LCD_JPEG_DEC_INT_MASK:  2;     /*!< Bit0: JPEG decode OK interrupt mask.
                                                          Bit1: JPEG decode error interrupt mask                               */
    };
  };
  __I  uint8_t   RESERVED21[3];
  
  union {
    __IO uint8_t   REG_0x9800_01DC;                 /*!< 0x9800_01DC                                                           */
    
    struct {
      __O  uint8_t   CLR_LCD_JPEG_DEC_OK_FLAG:  1;  /*!< 1: Clear JPEG_DEC_OK_FLAG                                             */
      __O  uint8_t   CLR_LCD_JPEG_DEC_ERR_FLAG:  1; /*!< 1: Clear JPEG_DEC_ERR_FLAG                                            */
      __I  uint8_t   LCD_JPEG_DEC_OK_FLAG:  1;      /*!< JPEG decoding completed                                               */
      __I  uint8_t   LCD_JPEG_DEC_ERR_FLAG:  1;     /*!< JPEG decoding error occurred.                                         */
    };
  };
  __I  uint8_t   RESERVED22[3];
  
  union {
    __IO uint32_t  REG_0x9800_01E0;                 /*!< 0x9800_01E0                                                           */
    
    struct {
      __IO uint32_t  LCD_QTAB_RAM_EN:  1;           /*!< Enable CPU to read/write Q-table RAM.                                 */
           uint32_t             :  7;
      __IO uint32_t  LCD_QTAB_RAM_A:  7;            /*!< Q-table read/write address.
                                                          Actions of reading/writing Q-table increase QTAB_ADDR by 1
                                                         automatically.                                                        */
           uint32_t             : 16;
      __IO uint32_t  LCD_AUTO_INC_QTAB_RAM_A:  1;   /*!< 1: Increase QTAB_RAM_A automatically                                  */
    };
  };
  __O  uint8_t   LCD_QTAB_RD_TRG;                   /*!< 0x9800_01E4
                                                          1: Trigger to read Q-table                                           */
  __I  uint8_t   RESERVED23[3];
  __IO uint8_t   LCD_QTAB_DAT;                      /*!< 0x9800_01E8
                                                          Data port of Q-table.
                                                          * To read Q-table:
                                                          Let QTAB_RAM_EN = 1
                                                          Set QTAB_ADDR (optional)
                                                          Let QTAB_RD_TRG = 1
                                                          Read QTAB_DAT (QTAB_RAM_A + 1 automatically)
                                                          * To write Q-table:
                                                          Let QTAB_RAM_EN = 1
                                                          Set QTAB_ADDR (optional)
                                                          Write QTAB_DAT (QTAB_RAM_A + 1 automatically)                        */
  __I  uint8_t   RESERVED24[19];
  __I  uint32_t  LCD_VER;                           /*!< 0x9800_01FC
                                                          LCD version                                                          */
} LCD_Type;


/* ================================================================================ */
/* ================                       DDR                      ================ */
/* ================================================================================ */


/**
  * @brief DDR Controller (DDR)
  */

typedef struct {                                    /*!< DDR Structure                                                         */
  
  union {
    __IO uint32_t  DENALI_CTL_00;                   /*!< 0x9900_0000                                                           */
    
    struct {
      __IO uint32_t  START      :  1;               /*!< Initiate command processing in the
                                                         controller. Set to 1 to initiate                                      */
           uint32_t             :  7;
      __IO uint32_t  DRAM_CLASS :  4;               /*!< Defines the mode of operation of
                                                         the controller
                                                         'b0100 = DDR2 (supports burst length of 4)
                                                         All other settings reserved                                           */
           uint32_t             :  4;
      __I  uint32_t  VERSION    : 16;               /*!< Holds the controller version
                                                         number. READ-ONLY                                                     */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_01;                   /*!< 0x9900_0004                                                           */
    
    struct {
      __I  uint32_t  MAX_ROW_REG:  4;               /*!< Holds the maximum width of
                                                         memory address bus. READ-ONLY                                         */
           uint32_t             :  4;
      __I  uint32_t  MAX_COL_REG:  4;               /*!< Holds the maximum width of
                                                         column address in DRAMs. READONLY                                     */
           uint32_t             :  4;
      __I  uint32_t  MAX_CS_REG :  1;               /*!< Holds the maximum number of chip
                                                         selects available. READ-ONLY                                          */
           uint32_t             :  7;
      __I  uint32_t  READ_DATA_FIFO_DEPTH:  8;      /*!< Reports the depth of the controller core read data queue.
                                                         Reports the depth of the Controller core read data queue.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified in the cadence_mc_denali_user_defin
                                                         e.h fileon the first controller clock edge after reset.
                                                         READONLY                                                              */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_02;                   /*!< 0x9900_0008                                                           */
    
    struct {
      __I  uint32_t  READ_DATA_FIFO_PTR_WIDTH:  8;  /*!< Reports the width of the controller core read data queue pointer.
                                                         Reports the width of the Controller core read data queue pointer.
                                                         This parameter is readonly.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                         on the first controller clock edge after reset.READ-ONLY              */
      __I  uint32_t  WRITE_DATA_FIFO_DEPTH:  8;     /*!< Reports the depth of the controller core write data latency
                                                         queue.
                                                         Reports the depth of the Controller core write data latency
                                                          queue.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                         on the first controller clock edge after reset.READ-ONLY              */
      __I  uint32_t  WRITE_DATA_FIFO_PTR_WIDTH:  8; /*!< Reports the width of the controller core write data latency
                                                         queue pointer.
                                                         Reports the width of the Controller core write data latency
                                                          queue pointer.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                         on the first controller clock edge after reset. READ-ONLY             */
      __I  uint32_t  ASYNC_CDC_STAGES:  8;          /*!< Reports the number of synchronizer delays specified for the
                                                         asynchronous boundary crossings.
                                                         Holds the number of serial flip-flop stagesused for the synchronizers
                                                          in the Controller core.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                         on the first controller clock edge after reset READ-ONLY              */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_03;                   /*!< 0x9900_000C                                                           */
    
    struct {
      __I  uint32_t  AXI0_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 0 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 0 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI0_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 0 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 0 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI0_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 0 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 0 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI0_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 0 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 0 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_04;                   /*!< 0x9900_0010                                                           */
    
    struct {
      __I  uint32_t  AXI1_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 1 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 1 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI1_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 1 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 1 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI1_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 1 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 1 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI1_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 1 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 1 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_05;                   /*!< 0x9900_0014                                                           */
    
    struct {
      __I  uint32_t  AXI2_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 2 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 2 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI2_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 2 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 2 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI2_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 2 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 2 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI2_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 2 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 2 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_06;                   /*!< 0x9900_0018                                                           */
    
    struct {
      __I  uint32_t  AXI3_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 3 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 3 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI3_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 3 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 3 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI3_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 3 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 3 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI3_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 3 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 3 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_07;                   /*!< 0x9900_001C                                                           */
    
    struct {
      __I  uint32_t  AXI4_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 4 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 4 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI4_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 4 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 4 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI4_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 4 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 4 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI4_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 4 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 4 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_mc                                                      */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_08;                   /*!< 0x9900_0020                                                           */
    
    struct {
      __I  uint32_t  AXI4_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 4 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 4 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
      __I  uint32_t  AXI5_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 5 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 5 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI5_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 5 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 5 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI5_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 5 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 5 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_09;                   /*!< 0x9900_0024                                                           */
    
    struct {
      __I  uint32_t  AXI5_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 5 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 5 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_mc                                                      */
      __I  uint32_t  AXI5_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 5 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 5 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
      __I  uint32_t  AXI6_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 6 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 6 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI6_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 6 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 6 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_10;                   /*!< 0x9900_0028                                                           */
    
    struct {
      __I  uint32_t  AXI6_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 6 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 6 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI6_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 6 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 6 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_mc                                                      */
      __I  uint32_t  AXI6_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 6 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 6 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
      __I  uint32_t  AXI7_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 7 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 7 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_11;                   /*!< 0x9900_002C                                                           */
    
    struct {
      __I  uint32_t  AXI7_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 7 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 7 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI7_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 7 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 7 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI7_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 7 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 7 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_mc                                                      */
      __I  uint32_t  AXI7_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 7 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 7 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_12;                   /*!< 0x9900_0030                                                           */
    
    struct {
      __I  uint32_t  AXI8_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 8 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 8 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI8_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 8 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 8 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI8_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 8 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 8 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
      __I  uint32_t  AXI8_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 8 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 8 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_mc                                                      */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_13;                   /*!< 0x9900_0034                                                           */
    
    struct {
      __I  uint32_t  AXI8_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 8 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 8 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
      __I  uint32_t  AXI9_CMDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 9 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 9 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h file
                                                                                                                               */
      __I  uint32_t  AXI9_RDFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 9 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 9 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h                                */
      __I  uint32_t  AXI9_WRFIFO_LOG2_DEPTH:  8;    /*!< Reports the depth of the AXI port 9 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 9 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_14;                   /*!< 0x9900_0038                                                           */
    
    struct {
      __I  uint32_t  AXI9_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 9 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 9 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_mc                                                      */
      __I  uint32_t  AXI9_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 9 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 9 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thecad                                                             */
      __I  uint32_t  AXI10_CMDFIFO_LOG2_DEPTH:  8;  /*!< Reports the depth of the AXI port 10 Command FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 10 command FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.Note:
                                                          This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.h fil                            */
      __I  uint32_t  AXI10_RDFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 10 Read Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 10 read data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_define.                                 */
    };
  };
  
  union {
    __I  uint32_t  DENALI_CTL_15;                   /*!< 0x9900_003C                                                           */
    
    struct {
      __I  uint32_t  AXI10_WRFIFO_LOG2_DEPTH:  8;   /*!< Reports the depth of the AXI port 10 Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 10 write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in the cadence_mc_denali_user_defin                                   */
      __I  uint32_t  AXI10_TRANS_WRFIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 10 Transition Write Data FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 10 transition write data FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters arerepresented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the value specified
                                                         in thecadence_                                                        */
      __I  uint32_t  AXI10_WRCMD_PROC_FIFO_LOG2_DEPTH:  8;/*!< Reports the depth of the AXI port 10 Write Command Processing
                                                         FIFO.
                                                         Value is the log2 value of the depth.
                                                         Holds the depth of the AXI port 10 writecommand processing FIFO.
                                                         The value returned is the log2 of the depth.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the value specified
                                                         in thec                                                               */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_16;                   /*!< 0x9900_0040                                                           */
    
    struct {
      __IO uint32_t  TINIT      : 24;               /*!< DRAM TINIT value in cycles
                                                         Defines the DRAM initialization delay, in memory clocks.
                                                         This refers to the time required for memory clocks to be started
                                                         andstabilized before clock enable becomes active.
                                                         The user may set this value to CK stabilization time of 10 ns
                                                         or 5 memory clocks before CKE active.
                                                         The memory specification value to be used is dependent on the
                                                          memory system:
                                                         * For DDR2 memories: 400 ns + tRP +tMRD + the max of (X,Y) +
                                                          tOIT,
                                                         where X is 200 cycles of CK and Y is ((2*tMRD) + tRP + (2*tRFC))
                                                         Not                                                                   */
      __IO uint32_t  INITAREF   :  4;               /*!< Number of auto-refresh commands
                                                         to execute during DRAM
                                                         initialization.                                                       */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_17;                   /*!< 0x9900_0044                                                           */
    
    struct {
      __IO uint32_t  TCPD       : 16;               /*!< DRAM TCPD value in cycles
                                                         Defines the clock enable to pre-charge delay
                                                         during initialization for the DRAM memories,
                                                         in memory clocks. This value can be found
                                                         by reviewing the initialization requirements in
                                                         the memory specification.
                                                         Note: Since the counter is initially loaded
                                                         with the value "tcpd-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counter to its maximum value. Therefore,
                                                         the user should set this parameter to 'b1
                                                         as a minimum.                                                         */
      __IO uint32_t  TDLL       : 16;               /*!< DRAM TDLL value in cycles                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_18;                   /*!< 0x9900_0048                                                           */
    
    struct {
      __IO uint32_t  NO_CMD_INIT:  1;               /*!< Disable DRAM commands until the
                                                         TDLL parameter has expired during
                                                         initialization. Set to 1 to disable                                   */
           uint32_t             :  7;
      __IO uint32_t  CASLAT_LIN :  4;               /*!< Sets latency from read command
                                                         send to data receive from/to
                                                         controller. Bit (0) is half-cycle
                                                         increment and the upper bits define
                                                         memory CAS latency for the
                                                         controller.
                                                         Sets the CAS latency linear value.
                                                         Note: The memory CAS latency is
                                                         programmed via the memory mode
                                                         registers. This parameter is used by the
                                                         Cadence Design IP DDR Controller and
                                                         should be programmed to match the
                                                         memory CAS latency.
                                                         Not all linear values will be supported for the
                                                         memories being used. Refer to the
                                                         specification for the memories                                        */
           uint32_t             :  4;
      __IO uint32_t  WRLAT      :  4;               /*!< DRAM WRLAT value in cycles
                                                         Defines the write latency from when the
                                                         write command is issued to the time the
                                                         write data is presented to the DRAM
                                                         memories, in memory clocks                                            */
           uint32_t             :  4;
      __IO uint32_t  ADDITIVE_LAT:  3;              /*!< DRAM additive latency value incycles.
                                                         Defines the number of DRAM clock cycles foradditive latency.
                                                         * For DDR1 memories: This parameter has no meaning for this
                                                         memory type.
                                                         * For DDR2 memories: Additive latency is defined in EMR1 [A5:A3]
                                                          as a fixed value.
                                                         Therefore, this parameter should beprogrammed
                                                         with the same value as bits [5:3] of the mr1_data_0 parameter         */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_19;                   /*!< 0x9900_004C                                                           */
    
    struct {
      __IO uint32_t  TBST_INT_INTERVAL:  3;         /*!< DRAM burst interrupt interval value in cycles                         */
           uint32_t             :  5;
      __IO uint32_t  TCCD       :  5;               /*!< DRAM CAS-to-CAS value in cycles
                                                         Defines the minimum delay between CAS commands, in memory clocks.
                                                         This value is loaded into a counter
                                                         when a memory burst is issued
                                                         and a new command may be issued
                                                         when the counter reaches 0.
                                                         The memory specification value to be used is dependent on the
                                                         memory system:
                                                         * For DDR2 memories: tCCD
                                                         Note: Since the counter is initially loadedwith the value "tccd-1",
                                                         if this parameter is cleared to 'b0,
                                                         the counter will underflow on load.
                                                         This will result in setting thecounter to i                           */
           uint32_t             :  3;
      __IO uint32_t  TRRD       :  8;               /*!< DRAM TRRD value in cycles
                                                         Defines the DRAM activate to activate delayto different bank
                                                         groups, in memory clocks.
                                                         The memory specification value to be used is dependent on the
                                                          memory system:
                                                         * For DDR2 memories: tRRD
                                                         Note: Since the counter is initially loadedwith the value "trrd-1",
                                                         if this parameter is cleared to 'b0,
                                                         the counter will underflow on load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set this parameter to 'b1 as a minimum     */
      __IO uint32_t  TRC        :  8;               /*!< DRAM TRC value in cycles
                                                         Defines the period between active
                                                         commands (DRAM tRC term) for the same
                                                         bank, in memory clocks.
                                                         Note: Since the counter is initially loaded
                                                         with the value "trc-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counter to its maximum value. Therefore,
                                                         the user should set this parameter to 'b1
                                                         as a minimum                                                          */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_20;                   /*!< 0x9900_0050                                                           */
    
    struct {
      __IO uint32_t  TRAS_MIN   :  8;               /*!< DRAM TRAS_MIN value in cycles
                                                         Note: Defines the DRAM minimum row
                                                         activate time (DRAM tRAS term), in
                                                         memory clocks.Since the counter is initially
                                                         loaded with the value "tras_min-1", if this
                                                         parameter is cleared to 'b0, the counter will
                                                         underflow on load. This will result in setting
                                                         the counter to its maximum value. In
                                                         general, it is suggested that this parameter
                                                         be programmed to a value of at least 0x3                              */
      __IO uint32_t  TWTR       :  4;               /*!< Sets the number of memory clocks neededto switch from a write
                                                         to a read operation.
                                                         The memory specification value to be used is dependent on the
                                                          memory system:
                                                         * For DDR2 memories: tWTR
                                                         Note: Since the counter is initially loadedwith the value "twtr-1",
                                                         if this parameter is cleared to 'b0,
                                                         the counter will underflow on load.
                                                         This will result in setting the counter to its maximum value.
                                                         Therefore, the user should set this parameter to 'b1 as a minimum     */
           uint32_t             :  4;
      __IO uint32_t  TRP        :  5;               /*!< DRAM TRP value in cycles
                                                         Defines the pre-charge / pre-activate
                                                         command time (DRAM tRP term), in
                                                         memory clocks. If the memory specification
                                                         defines both a single-bank and an all-banks
                                                         pre-charge value, this parameter should be
                                                         programmed to the single-bank value and
                                                         the trp_ab parameter should be
                                                         programmed to the all-banks value.
                                                         Note: Since the counter is initially loaded
                                                         with the value "trp-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counte                                                                */
           uint32_t             :  3;
      __IO uint32_t  TFAW       :  6;               /*!< DRAM TFAW value in cycles
                                                         Defines the DRAM tFAW term, in memory clocks.
                                                         Note: Since the counter is initially loaded
                                                         with the value "tfaw-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counter to its maximum value. Therefore,
                                                         the user should set this parameter to 'b1
                                                         as a minimum.                                                         */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_21;                   /*!< 0x9900_0054                                                           */
    
    struct {
      __IO uint32_t  TRTP       :  3;               /*!< DRAM TRTP value in cycles
                                                         Defines the read to precharge command delay.
                                                         The memory specification value to be used is dependent on the
                                                         memory system:
                                                         * For DDR2 memories: tRTP;
                                                         Minimumvalue supported is 3,
                                                         even if tRTP is lower,
                                                         the user should program this parameter to 0x3 for this memory
                                                          system                                                               */
           uint32_t             :  5;
      __IO uint32_t  TMRD       :  5;               /*!< DRAM TMRD value in cycles
                                                         Defines the minimum number of memory clocks required between
                                                         two memory mode register write commands.
                                                         This is the time required to complete the write operation to
                                                          the mode register.
                                                         There are two parameters that control the timing
                                                         after a mode register write: tmod and tmrd.
                                                         This parameter (tmrd) is typically the shorter of the two timing
                                                          delays.
                                                         TheController will wait this delay
                                                         after a mode register command before sending the next mode register
                                                          command.
                                                         The Controller does not n                                             */
           uint32_t             :  3;
      __IO uint32_t  TMOD       :  8;               /*!< Number of cycles after MRScommand and before any other command
                                                         Defines the number of memory clocks of delay
                                                         after a memory mode register write to any non-mode register
                                                         write command.
                                                         There are two parameters that control the timing after a mode
                                                          register write: tmod and tmrd.
                                                         This parameter (tmod) is typically the longer timing delay
                                                         (defined bythe memory specification)
                                                         and controls the spacing of a mode register command to any other
                                                          memory command.
                                                         The Controller willwait this delay
                                                         after a mode register c                                               */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_22;                   /*!< 0x9900_0058                                                           */
    
    struct {
      __IO uint32_t  TRAS_MAX   : 16;               /*!< DRAM TRAS_MAX value in cycles
                                                         Defines the DRAM maximum row active time
                                                         (DRAM tRAS term), in memory clocks.The
                                                         user should set this value to the timing
                                                         parameter in the memory specification. In
                                                         practical use, the Cadence Design IP DDR
                                                         Controller will use the value in this
                                                         parameter with adjustments made for write
                                                         recovery time, memory burst length and any
                                                         internal delays if required.
                                                         Note: Since the counter is initially loaded
                                                         with the value "tras_max-1", if this
                                                         parameter is cleared to 'b0, the counter wil                          */
      __IO uint32_t  TCKE       :  3;               /*!< Minimum CKE pulse width
                                                         Defines the minimum CKE pulse width
                                                         (DRAM tCKE term), in memory clocks.
                                                         Note: Since the counter is initially loaded
                                                         with the value "tcke-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counter to its maximum value. Therefore,
                                                         the user should set this parameter to 'b1
                                                         as a minimum.                                                         */
           uint32_t             :  5;
      __IO uint32_t  TCKESR     :  5;               /*!< Minimum CKE low pulse width during a self-refresh
                                                         Defines the minimum number of cycles
                                                         that CKE must be held low during self-refresh (DRAM tCKESR term),
                                                         in memory clocks.
                                                         The memory specification value to be used is dependent on the
                                                          memory system:
                                                         * For DDR2 memories: tCKE
                                                         Note: Since the counter is initially loaded with the value "tckesr-1",
                                                         if this parameter is cleared to 'b0,
                                                         the counter will underflow on load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set t                                      */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_23;                   /*!< 0x9900_005C                                                           */
    
    struct {
      __IO uint32_t  WRITEINTERP:  1;               /*!< Allow controller to interrupt a write burst to the DRAMs with
                                                         a read command. Set to 1 to allow interruption                        */
           uint32_t             :  7;
      __IO uint32_t  TRCD       :  8;               /*!< DRAM TRCD value in cycles
                                                         Defines the DRAM RAS to CAS delay
                                                         (DRAM tRCD term), in memory clocks.
                                                         Note: Since the counter is initially loaded
                                                         with the value "trcd-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counter to its maximum value. Therefore,
                                                         the user should set this parameter to 'b1
                                                         as a minimum.                                                         */
      __IO uint32_t  TWR        :  6;               /*!< DRAM TWR value in cycles
                                                         Defines the write recovery time (DRAM tWR time), in memory clocks.
                                                         Note: Since the counter is initially loaded
                                                         with the value "twr-1", if this parameter is
                                                         cleared to 'b0, the counter will underflow
                                                         on load. This will result in setting the
                                                         counter to its maximum value. Therefore,
                                                         the user should set this parameter to 'b1 as a minimum                */
           uint32_t             :  2;
      __IO uint32_t  AP         :  1;               /*!< Enable auto pre-charge mode ofcontroller. Set to 1 to enable
                                                         Enables auto pre-charge mode for DRAM memories.
                                                         Note: This parameter may not be modified
                                                         after the start parameter has been asserted.
                                                         Note: When using auto-precharge percommand
                                                         (the axiY_ARAPCMD/axiY_AWAPCMD/ahbY_HAPCMD signals), this parameter
                                                         must be cleared to 'b0.                                               */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_24;                   /*!< 0x9900_0060                                                           */
    
    struct {
      __IO uint32_t  CONCURRENTAP:  1;              /*!< Allow controller to issue commandsto other banks
                                                         while a bank is in auto pre-charge. Set to 1 to enable
                                                         Enables concurrent auto pre-charge.
                                                         Some DRAM memories do not allow one bank tobe auto pre-charged
                                                         while another bank is reading or writing.
                                                         The JEDEC standard allows concurrent auto pre-charge.
                                                         The user should set this parameter if the DRAM memory supports
                                                         this feature.
                                                         Note: This parameter can only be set
                                                         if thememory supports concurrent AP for all transactions.
                                                         Some memories only support concurrent AP                              */
           uint32_t             :  7;
      __IO uint32_t  TRAS_LOCKOUT:  1;              /*!< Allow the controller to execute auto pre-charge commands before
                                                         the TRAS_MIN parameter expires.
                                                         Set to 1 to enable
                                                         Defines the tRAS lockout setting for the DRAM memory, in memory
                                                          clocks.
                                                         tRAS lockout allows the controller to execute auto pre-charge
                                                          commands
                                                         before the tras_min_0 parameter has expired.
                                                         Note: This parameter may only be applicable to DDR1 memory systems
                                                          (dram_class = 'b0000).
                                                         Please refer to thememory specification.                              */
           uint32_t             :  7;
      __IO uint32_t  TDAL       :  6;               /*!< DRAM TDAL value in cycles
                                                         Defines the auto pre-charge write recovery (DRAM tDAL term)
                                                          when auto pre-charge isenabled (the ap parameter is set to
                                                         'b1), in memory clocks.
                                                         This is defined internally as tRP (pre-charge time) + auto pre-charge
                                                          write recovery time.
                                                         Not all memories use this parameter.
                                                         If tDALis defined in the memory specification,
                                                         then program this parameter to the specified value.
                                                         If the memory does not specify a tDAL,
                                                         then program this parameter to tWR + tRP.
                                                         DO NOT program this parameter wit                                     */
           uint32_t             :  2;
      __IO uint32_t  BSTLEN     :  3;               /*!< Encoded burst length sent to DRAMs during initialization.
                                                         Set to 1 for BL2, set to 2 for BL4, or set to 3 for BL8.
                                                         Defines the memory burst length encoding that will be programmed
                                                         into the DRAM memories at initialization.
                                                         The mode isprogrammed in the dram_class parameter
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the default value on the first controller
                                                          clock edge after reset                                               */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_25;                   /*!< 0x9900_0064                                                           */
    
    struct {
      __IO uint32_t  TRP_AB     :  5;               /*!< DRAM TRP all bank value incycles
                                                         Defines the DRAM row precharge time for allbanks, in memory
                                                         clocks.
                                                         If the memory specification defines both a single-bank and an
                                                          all-banks pre-charge value,
                                                         this parameter should be programmed to the allbanksvalue
                                                         and the trp parameter should beprogrammed to the single-bank
                                                          value.
                                                         If the memory specification does NOT specify anall-banks pre-charge
                                                          value,
                                                         both parametersshould be programmed to the same value.
                                                         The memory specification value to be used is dependent on the
                                                          mem                                                                  */
           uint32_t             :  3;
      __IO uint32_t  REG_DIMM_ENABLE:  1;           /*!< Enable registered DIMM operation of the controller.
                                                         Set to 1 to enable                                                    */
           uint32_t             :  7;
      __O  uint32_t  AREFRESH   :  1;               /*!< Initiate auto-refresh at boundary specified by theAUTO_REFRESH_MODE
                                                         parameter.
                                                         Set to 1 to trigger.
                                                         Initiates an automatic refresh to the DRAMmemories.
                                                         If there are any open banks when this parameter is set,
                                                         the Cadence Design IP DDR Controller will automatically close
                                                          these banks
                                                         before issuing the auto-refreshcommand.
                                                         This parameter is write-only and will always read back as 0x0.        */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_26;                   /*!< 0x9900_0068                                                           */
    
    struct {
      __IO uint32_t  TREF_ENABLE:  1;               /*!< Issue auto-refresh commands tothe DRAMs at the interval defined
                                                         in the TREF parameter.
                                                         Set to 1 toenable
                                                         Enables refresh commands.
                                                         If command refresh mode is configured,
                                                         then refresh commands will be automatically issued based on
                                                          the tref parameter value
                                                          and any refresh commands sent through the command interface
                                                          or the register interface.
                                                         Refreshes will still occur even
                                                         if the DRAM memories have been placed in power-downstate.
                                                         Note: Even with this parameter cleared to 'b0, some refresh
                                                          commands may still                                                   */
           uint32_t             :  7;
      __IO uint32_t  TRFC       : 10;               /*!< DRAM TRFC value in cycles
                                                         Defines the DRAM tRFC time, the refreshcommand time, in memory
                                                         clocks.
                                                         Note: Since the counter is initially loadedwith the value "trfc-1",
                                                         if this parameter is cleared to 'b0, the counter will underflowon
                                                          load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set this parameter to 'b1 as a minimum     */
    };
  };
  __IO uint16_t  TREF;                              /*!< 0x9900_006C
                                                         DRAM TREF value in cycles
                                                         Defines the time between refresh commands (DRAM tREFI term),
                                                         in memory clocks.
                                                         This parameter sets the averageinterval between refreshes.
                                                         Note: Since the counter is initially loaded with the value "tref-1",
                                                         if this parameter is cleared to 'b0, the counter will underflowon
                                                          load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set this parameter to 'b1 as a minimum     */
  __I  uint16_t  RESERVED;
  
  union {
    __IO uint32_t  DENALI_CTL_28;                   /*!< 0x9900_0070                                                           */
    
    struct {
      __IO uint32_t  TPDEX      : 16;               /*!< DRAM TPDEX value in cycles
                                                         Defines the DRAM power-down exit command period, in memory clocks.
                                                         The memory specification value to be used is dependent on the
                                                         memory system:
                                                         * For DDR2 memories: tXP
                                                         Note: Since the counter is initially loadedwith the value "tpdex-1",
                                                         if this parameter is cleared to 'b0, the counter will underflowon
                                                          load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set this parameter to 'b1 as a minimum     */
      __IO uint32_t  TXARD      : 16;               /*!< DRAM TXARD value in cycles
                                                         Defines the fast exit DRAM active powerdownexit to read command
                                                         time, in memory clocks                                                */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_29;                   /*!< 0x9900_0074                                                           */
    
    struct {
      __IO uint32_t  TXARDS     : 16;               /*!< DRAM TXARDS value in cycles
                                                         Defines the slow exit DRAM active powerdownexit to read command
                                                         time, in memory clocks                                                */
      __IO uint32_t  TXSR       : 16;               /*!< DRAM TXSR value in cycles
                                                         Defines the DRAM time from a self-refresh exit to an active
                                                         command that requires the memory DLL to be locked, in memory
                                                          clocks.
                                                         The meaning of this parameter depends on the memory system being
                                                          used:
                                                         * For DDR2 memories: tXSRD - tRCD
                                                         Note: Since the counter is initially loadedwith the value "txsr-1",
                                                         if this parameter is cleared to 'b0, the counter will underflowon
                                                          load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set this parameter to '                    */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_30;                   /*!< 0x9900_0078                                                           */
    
    struct {
      __IO uint32_t  TXSNR      : 16;               /*!< DRAM TXSNR value in cycles
                                                         Defines the DRAM time from a self-refresh exit to a command
                                                         that does not require the memory DLL to be locked, in memory
                                                          clocks.
                                                         The memory specification value to be used is dependent on the
                                                          memory system:
                                                         * For DDR2 memories: tXSNR
                                                         Note: Since the counter is initially loadedwith the value "txsnr-1",
                                                         if this parameter is cleared to 'b0, the counter will underflowon
                                                          load.
                                                         This will result in setting thecounter to its maximum value.
                                                         Therefore, the user should set this parameter to                      */
      __IO uint32_t  PWRUP_SREFRESH_EXIT:  1;       /*!< Allow powerup via self-refreshinstead of full memory initialization.
                                                         Set to 1 to enable
                                                         Allows the controller to exit low power by executing a self-refresh
                                                         exit instead of thefull memory initialization.
                                                         This parameter provides a means to skip full initializationwhen
                                                          the DRAM memories are in a known self-refresh state                  */
           uint32_t             :  7;
      __IO uint32_t  SREFRESH_EXIT_NO_REFRESH:  1;  /*!< Disables the automatic refreshrequest associated with self-refresh
                                                         exit.
                                                         Set to 1 to disable
                                                         When a self-refresh exit command isexecuted, an automatic refresh
                                                          is requested.
                                                         By setting this bit, the automatic refresh request is inhibited       */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_31;                   /*!< 0x9900_007C                                                           */
    
    struct {
      __IO uint32_t  ENABLE_QUICK_SREFRESH:  1;     /*!< Allow user to interrupt memoryinitialization to enter self-refresh
                                                         mode.
                                                         Set to 1 to allow interruption
                                                         When this bit is set to 'b1, the memory initialization sequence
                                                          may be interrupted and the memory may enter self-refresh mode.
                                                         This is used to place the memories into self-refresh mode when
                                                          a power loss is detected during the initialization process.
                                                         Setting this parameter does not initiate a self-refresh entry
                                                          during initialization.
                                                         However, if a self-refresh entry is requested during initialization,
                                                         it                                                                    */
           uint32_t             :  7;
      __IO uint32_t  CKE_DELAY  :  3;               /*!< Additional cycles to delay CKE forstatus reporting
                                                         Sets the number of additional controller clocks of delay between
                                                         changes 
                                                         of state in the dfi_cke and the cke_status Controller output
                                                          signals.
                                                         The default value of 0x0 will result in a 2 controller clock
                                                          delay fromdfi_cke to cke_status state changes.
                                                         Note: This parameter can be programmed to reflect the actual
                                                          timing
                                                          of the CKE pin assertion at the ASIC boundary for systems that
                                                          choose to utilize the cke_status signal                              */
           uint32_t             :  5;
      __IO uint32_t  LOWPOWER_REFRESH_ENABLE:  1;   /*!< Enable refreshes while in low power mode. Bit (0) controls cs0,
                                                         bit (1) controls cs1, etc.
                                                         Set each bit to 1 to disable
                                                         Sets whether refreshes will occur while thecontroller is in
                                                          one of the power-down modes.
                                                         Note that refreshes will not occur while inany of the self-refresh
                                                          modes.
                                                         Note: This parameter is active low                                    */
           uint32_t             :  7;
      __IO uint32_t  CKSRE      :  4;               /*!< Clock hold delay on self-refresh entry
                                                         Sets the number of controller clocks to hold the controller
                                                         clock stable after entering selfrefreshmode.
                                                         The Controller clock will run for a minimum of cksre clocks
                                                          after CKE falls                                                      */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_32;                   /*!< 0x9900_0080                                                           */
    
    struct {
      __IO uint32_t  CKSRX      :  4;               /*!< Clock stable delay on self-refreshexit
                                                         Sets the number of controller clocks to hold the controller
                                                         clock stable before exiting selfrefreshmode.
                                                         The Controller clock will run for a minimum of cksrx clocks
                                                          before CKE rises                                                     */
           uint32_t             :  4;
      __O  uint32_t  LP_CMD     :  8;               /*!< Low power software commandrequest interface.
                                                         Bit (0) controls exit,
                                                         bit (1) controls entry,
                                                         bits (4:2) define the low power state,
                                                         bit (5)controls memory clock gating,
                                                         bit(6) controls controller clock gating,
                                                         and bit (7) controls lock. WRITEONLY
                                                         Defines the low power command requestedthrough the software
                                                         programmable interface.
                                                         When this command is completed,
                                                         the low power command complete interrupt (bit 4) in the int_status
                                                          parameter
                                                         will be set to 'b1. Re-programming attempts to thisparameter
                                                          until the i                                                          */
      __I  uint32_t  LP_STATE   :  6;               /*!< Low power state status parameter.
                                                         Bits (4:0) indicate the current lowpower state and
                                                         bit (5) set indicates that status bits are valid. READONLY
                                                         Holds the state of the DRAM memories.
                                                         This value is also reflected in the output signal lp_ext_state.
                                                         This parameter is read-only.
                                                         * Bit [5] = Valid.
                                                         This bit will be cleared to 'b0when a command is accepted on
                                                         the software programmable or external pininterfaces,
                                                         and remain at 'b0 until thecommand has completed.
                                                         -- 'b0 = Invalid, low power state currently in transi                 */
           uint32_t             :  2;
      __I  uint32_t  LP_ARB_STATE:  4;              /*!< Reports on the state of the arbiter.
                                                         Bits (2:0) indicate which interfacehas control of the low power
                                                         control module and
                                                         bit (3) indicates if the software programmable interface has
                                                          an active lock on the arbiter.
                                                         For bits (2:0), value of 0 indicates module is idle,
                                                         value of 1 indicates software programmable interface isin control,
                                                         value of 2 indicates external pin interface is in control,
                                                         value of 3 indicates automatic interface is in control,
                                                         value of 4 indicates dynamic power control per chip select inter      */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_33;                   /*!< 0x9900_0084                                                           */
    
    struct {
      __IO uint32_t  LP_AUTO_ENTRY_EN:  3;          /*!< Enable auto entry into each of thelow power states when the
                                                         associated idle timer expires.
                                                         Bit(0) controls power-down,
                                                         bit (1)controls self-refresh, and
                                                         bit (2)controls self-refresh with memory and controller clock
                                                          gating.
                                                         Seteach bit to 1 to enable
                                                         Enables automatic entry into each of the low power states when
                                                          the associated idle timer expires.
                                                         For power-down or self-refresh modes,
                                                         thememory clock will also be gated when the timer expires
                                                         if the associated bit in the lp_auto_mem_gate_en parameter is
                                                          set t                                                                */
           uint32_t             :  5;
      __IO uint32_t  LP_AUTO_EXIT_EN:  3;           /*!< Enable auto exit from each of the low power states when a read
                                                         or write command enters thecommand queue.
                                                         Bit (0) controls power-down,
                                                         bit (1) controls selfrefresh, and
                                                         bit (2) controls selfrefresh with memory and controllerclock
                                                         gating.
                                                         Set each bit to 1 to enable
                                                         Enables automatic exit from each of the lowpower states when
                                                          a read
                                                         or write command enters the command queue in the Controllercore.
                                                         If the memory clock was gated,
                                                         it willbe gated on again with the exit.
                                                         Note: Automatic exit will occur regardless                            */
           uint32_t             :  5;
      __IO uint32_t  LP_AUTO_MEM_GATE_EN:  2;       /*!< Enable memory clock gating when entering a low power state via
                                                         theauto low power counters.
                                                         Bit (0)controls power-down, and
                                                         bit (1)controls self-refresh.
                                                         Set each bit to1 to enable
                                                         Enables memory clock gating when entering each of the low power
                                                          modes automatically.
                                                         A low power mode is only entered automatically
                                                         if the associated bit in the lp_auto_entry_en parameter is also
                                                          set to 'b1 when the idle timer expires.
                                                         Note: This parameter does not apply to the "Self-Refresh with
                                                          Memory and ControllerClock Gating                                    */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_34;                   /*!< 0x9900_0088                                                           */
    
    struct {
      __IO uint32_t  LP_AUTO_PD_IDLE: 12;           /*!< Defines the idle time until the controller will place memory
                                                         in active power-down
                                                         Defines the power-down mode auto entry controller clocks.
                                                         This parameter relates to all of the following states:
                                                         * "Active Power-Down"
                                                         * "Active Power-Down with Memory Clock Gating"
                                                         * "Pre-Charge Power-Down"
                                                         * "Pre-Charge Power-Down with Memory Clock Gating"
                                                         The Controller will issue a power-down entry.
                                                         The DRAMs will enter one of the four power-down states depending
                                                          on the state
                                                         of the rows and the setting
                                                          of the lp_auto_me                                                    */
           uint32_t             :  4;
      __IO uint32_t  LP_AUTO_SR_IDLE:  8;           /*!< Number of long count sequencesuntil the controller will placememory
                                                         in self-refresh
                                                         "Self-Refresh" or "Self-Refresh with MemoryClock Gating" auto
                                                          entry periodic cycles.
                                                         This parameter defines the number of long count sequences
                                                         that can elapse before the controller will automatically issue
                                                          an entryinto the "Self-Refresh"
                                                         or "Self-Refresh with Memory Clock Gating" low power state.
                                                         When the controller is idle,
                                                         if the associated bit (bit 1) in the lp_auto_entry_en parameteris
                                                          set to 'b1
                                                         and this parameter is p                                               */
      __IO uint32_t  LP_AUTO_SR_MC_GATE_IDLE:  8;   /*!< Number of long count sequencesuntil the controller will placememory
                                                         in self-refresh with controller and memory clock gating
                                                         "Self-Refresh with Memory and Controller Clock Gating" auto
                                                         entry periodic cycles.
                                                         This parameter defines the number of long count sequences
                                                         that can elapse before the controller will automatically issue
                                                          an entryinto
                                                         the "Self-Refresh with Memory and Controller Clock Gating" low
                                                          power state.
                                                         When the controller is idle,
                                                         if the associated bit (bit 2) in the lp_auto_entry_en parameteris     */
    };
  };
  __I  uint32_t  RESERVED1;
  __IO uint32_t  WRITE_MODEREG;                     /*!< Write memory mode register data to the DRAMs.
                                                         Bits (7:0) define the memory mode register number if bit (23)
                                                         is set,
                                                         bits (15:8) define the chip select if bit (24) is clear,
                                                         bits (23:16) define which memory mode register/s to write,
                                                         bit (24) defines whether all chip selects will be written, and
                                                         bit (25) triggers the write
                                                         Issues memory mode register write(s) to thespecified mode register(s)
                                                          and memories.
                                                         When the write has been completed,
                                                         themode register write complete interrupt
                                                         (bit 8)will be set to 'b1 i                                           */
  
  union {
    __IO uint32_t  DENALI_CTL_37;                   /*!< 0x9900_0094                                                           */
    
    struct {
      __I  uint32_t  MRW_STATUS :  8;               /*!< Write memory mode registerstatus.
                                                         Bit (0) set indicates aWRITE_MODEREG parameterprogramming error.
                                                         READ-ONLY
                                                         Reports the status of the write memory mode register request
                                                         issued through theassertion of write_modereg.
                                                         This parameter is read-only and is valid
                                                         when the mode register write complete interrupt (bit 8) is set
                                                          to 'b1 in the int_status parameter.
                                                         * Bits [7:3] = Reserved
                                                         * Bit [2] = Reserved
                                                         * Bit [1] = Reserved
                                                         * Bit [0] = write_modereg programming error.
                                                         This bit will be set if no mode register wri                          */
      __IO uint32_t  MR0_DATA_0 : 14;               /*!< Data to program into memory mode register 0 for chip select
                                                         0
                                                         Holds the memory mode register 0 data written during memory
                                                          initialization
                                                         or whenthe write_modereg parameter bit [25] isasserted with
                                                          bit [17] set to 'b1.
                                                         Consult thememory specification for the fields of thismode register.
                                                         The meaning of this parameter depends on the memory system being
                                                          used:
                                                         * For DDR2 memories: (MR) The A3 bit should be cleared to 'b0
                                                          to disable interleaving.
                                                         In addition, the DLL Reset bit (A8) will be ignored in favor
                                                          of an                                                                */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_38;                   /*!< 0x9900_0098                                                           */
    
    struct {
      __IO uint32_t  MR1_DATA_0 : 15;               /*!< Data to program into memory mode register 1 for chip select
                                                         0
                                                         Holds the memory mode register 1 data written during memory
                                                          initialization
                                                         or whenthe write_modereg parameter bit [25] isasserted with
                                                          bit [17] set to 'b1.
                                                         Consult thememory specification for the fields of thismode register.
                                                         The meaning of this parameter depends on the memory system being
                                                          used:
                                                         * For DDR2 memories: Extended memory mode register 1 (EMR1)
                                                         Bits [5:3] should be programmed with the same value as the additive_lat
                                                          parameter.
                                                         Bits[4:3]                                                             */
           uint32_t             :  1;
      __IO uint32_t  MR2_DATA_0 : 15;               /*!< Data to program into memory mode register 2 for chip select
                                                         0.
                                                         Holds the memory mode register 2 data
                                                         written during memory initialization
                                                         or when the write_modereg parameter bit [25] isasserted with
                                                          bit [17] set to 'b1.
                                                         Consult thememory specification for the fields of thismode register.
                                                         The meaning of this parameter depends on the memory system being
                                                          used:
                                                         * For DDR2 memories: Extended memory mode register 2 (EMR2)           */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_39;                   /*!< 0x9900_009C                                                           */
    
    struct {
      __IO uint32_t  MRSINGLE_DATA_0: 15;           /*!< Data to program into memory mode register single write to chip
                                                         select 0
                                                         Holds the data to be programmed into a single memory mode register.
                                                         This parameter is used when the write_modereg parameter bit
                                                          [25] is asserted with bit [23] is set to 'b1.
                                                         The write_modereg parameter will specify which mode register
                                                         and which chip selects (one or all) are to be programmed.
                                                         The user is expected to define mode register write data accurately.
                                                         If the mode register number specified in write_modereg bits
                                                          [7:0] is not a val                                                   */
           uint32_t             :  1;
      __IO uint32_t  MR3_DATA_0 : 15;               /*!< Data to program into memory mode register 3 for chip select
                                                         0
                                                         Holds the data to be programmed into a single memory mode register.
                                                         This parameter is used when the write_modereg parameter bit
                                                          [25] is asserted with bit [23] is set to 'b1.
                                                         The write_modereg parameter will specify which mode register
                                                          and which chipselects (one or all) are to be programmed.
                                                         The user is expected to define mode register write data accurately.
                                                         If the mode register number specified in write_modereg bits
                                                          [7:0] is not a valid setting                                         */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_40;                   /*!< 0x9900_00A0                                                           */
    
    struct {
      __O  uint32_t  BIST_GO    :  1;               /*!< Initiate a BIST operation.
                                                         Set to 1 totrigger.
                                                         WRITE-ONLY
                                                         Initiates a BIST address or data check operation,
                                                         depending on whether the bist_addr_check or bist_data_check
                                                         parameter is set to 'b1.
                                                         This parameter is write-only and will always read back as 0x0.
                                                         Note: All programmable registers must be static for a minimum
                                                         of 10 controller clocksprior to writing 'b1 to the bist_goparameter.
                                                         Note: Manually clearing this parameter to 'b0 will clear the
                                                          bist_result parameter!
                                                         However, since this parameter MUST be cl                              */
           uint32_t             :  7;
      __I  uint32_t  BIST_RESULT:  2;               /*!< BIST operation status (pass/fail).
                                                         Bit (0) indicates data check statusand
                                                         bit (1) indicates address checkstatus. Value of 1 is a passingresult.
                                                         READ-ONLY
                                                         Holds the result of the BIST operation.
                                                         Themeaning of the bist_result parameter isdependent on the status
                                                         of the bist_addr_check and bist_data_check parameters.
                                                         This parameter value is only valid if the BIST complete interrupt
                                                         (bit 5) in the int_status parameter is set to 'b1.
                                                         Thebist_result parameter is cleared to 'b00 when the bist_go
                                                          parameter is clear                                                   */
           uint32_t             :  6;
      __IO uint32_t  ADDR_SPACE :  5;               /*!< Sets the number of address bits tocheck during BIST operation.
                                                         Used in BIST address or data checking to define the address
                                                         space in bytes from 0 to 2addr_space that the BIST logic will
                                                          check.
                                                         As an example,
                                                         if addr_space was programmed to 0x1c,
                                                         then the BIST logic would check 228bytes = 256 MBytes                 */
           uint32_t             :  3;
      __IO uint32_t  BIST_DATA_CHECK:  1;           /*!< Enable data checking with BISToperation. Set to 1 to enable
                                                         Enables the data check portion of the BIST algorithm.
                                                         When the BIST operation is initiated by setting the bist_go
                                                         parameter to 'b1,
                                                         the data lines will be tested.
                                                         This parameter will NOT be automatically cleared after the data
                                                          check is completed.
                                                         The user must clear this parameter to 'b0 after theoperation
                                                          or the Controller will not be able toprocess other commands          */
    };
  };
  __IO uint8_t   BIST_ADDR_CHECK;                   /*!< 0x9900_00A4
                                                         Enable address checking with BIST operation.
                                                         Set to 1 to enable
                                                         Enables the address check portion of the BIST algorithm.
                                                         When the BIST operation is initiated by setting the bist_go
                                                         parameter to 'b1,
                                                         the address lines will be tested.
                                                         This parameter will NOT be automatically cleared after the address
                                                          check is completed.
                                                         Theuser must clear this parameter to 'b0 afterthe operation
                                                         or the Controller will not be able to process other commands
                                                         'b0 = No action
                                                         'b1 = Enables address checking on the next                            */
  __I  uint8_t   RESERVED2[3];
  __IO uint32_t  BIST_START_ADDRESS;                /*!< 0x9900_00A8
                                                         Start BIST checking at thisaddress.
                                                         Used in BIST address or data checking to define the starting
                                                         address for BIST checking in bytes                                    */
  __IO uint32_t  BIST_DATA_MASK;                    /*!< 0x9900_00AC
                                                         Mask applied to data for BIST errorchecking.
                                                         Bit (0) controls memorydata path bit (0),
                                                         bit (1) controls memory data path bit (1), etc.
                                                         Seteach bit to 1 to mask
                                                         Sets the data mask that will be applied to the BIST error logic
                                                         for BIST data checking.
                                                         Bit[0] controls bit [0] of the memory data path,
                                                         Bit [1] controls bit [1] of the memory datapath, etc.
                                                         For each memory data path bit:
                                                         * 'b0 = Do not mask error checking on this bit.
                                                         * 'b1 = Mask error checking on this bit                               */
  __IO uint8_t   BIST_TEST_MODE;                    /*!< 0x9900_00B0
                                                         Sets the BIST test mode.
                                                         Value of 0 specifies standard BIST operation,
                                                         value of 1 specifies a reduced BISToperation,
                                                         value of 2 specifies a self-refresh retention test,
                                                         value of 3 specifies an idle retention test, and
                                                         value of 4 specifies memoryinitalization function                     */
  __I  uint8_t   RESERVED3[3];
  __IO uint32_t  BIST_DATA_PATTERN0;                /*!< 0x9900_00B4
                                                         Data pattern to be used
                                                         when the BIST_TEST_MODE parameter is programmed to 1, 2, 3,
                                                         or 4.                                                                 */
  __IO uint32_t  BIST_DATA_PATTERN1;                /*!< 0x9900_00B8
                                                         Data pattern to be used
                                                         when the BIST_TEST_MODE parameter is programmed to 1, 2, 3,
                                                         or 4.                                                                 */
  
  union {
    __IO uint32_t  DENALI_CTL_47;                   /*!< 0x9900_00BC                                                           */
    
    struct {
      __O  uint32_t  BIST_RET_STATE_EXIT:  1;       /*!< Exit self-refresh or idle retention state,
                                                         used when the BIST_TEST_MODE parameter is programmed to 2 or
                                                         3. Set to 1 totrigger.
                                                         WRITE-ONLY                                                            */
           uint32_t             :  7;
      __I  uint32_t  BIST_RET_STATE:  1;            /*!< Indicates if BIST is in a retention wait state,
                                                         used when the BIST_TEST_MODE parameter is programmed to 2 or
                                                         3. Value of 1 indicates BIST is waiting.
                                                         READONLY                                                              */
           uint32_t             :  7;
      __IO uint32_t  BIST_ERR_STOP: 12;             /*!< Defines the maximum number of
                                                         error occurrences allowed prior to quitting
                                                         when the BIST_TEST_MODE parameter is programmed to 1, 2 or 3.
                                                         A value of 0 will allow the test to run to completion                 */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_48;                   /*!< 0x9900_00C0                                                           */
    
    struct {
      __I  uint32_t  BIST_ERR_COUNT: 12;            /*!< Indicates the number of BIST errors found
                                                         when the BIST_TEST_MODE parameter is programmed to 1, 2 or 3.
                                                         READONLY                                                              */
           uint32_t             :  4;
      __IO uint32_t  LONG_COUNT_MASK:  5;           /*!< Reduces the length of the longcounter from 1024 cycles.
                                                         The only supported values are
                                                         0x00 (1024 cycles),
                                                         0x10 (512 clocks),
                                                         0x18 (256 clocks),
                                                         0x1C (128 clocks),
                                                         0x1E (64 clocks) and
                                                         0x1F (32 clocks)                                                      */
           uint32_t             :  3;
      __IO uint32_t  BANK_DIFF  :  2;               /*!< Encoded number of banks on theDRAM(s)
                                                         Defines the difference between the maximum number of banks bits
                                                         configured (3)
                                                         and the actual number of banks being used                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_49;                   /*!< 0x9900_00C4                                                           */
    
    struct {
      __IO uint32_t  ROW_DIFF   :  3;               /*!< Difference between number of address pins available and numberbeing
                                                         used
                                                         Defines the difference between the maximum number of address
                                                          pins configured (14)
                                                         and the actual number of pins being used.
                                                         The user address is automatically shifted
                                                         so that the user address space is mapped contiguously into the
                                                          memory map based on the value of this parameter                      */
           uint32_t             :  5;
      __IO uint32_t  COL_DIFF   :  4;               /*!< Difference between number of column pins available and number
                                                         being used.
                                                         Shows the difference between the maximum column width available
                                                          (11)
                                                         and the actual number of column pins being used.
                                                         The user address is automatically shifted
                                                         so that theuser address space is mapped contiguously into the
                                                          memory map based on the value ofthis parameter                       */
           uint32_t             :  4;
      __IO uint32_t  BANK_START_BIT:  5;            /*!< Defines the LSbit of the bank address within the page of
                                                         the user address when the BANK_ADDR_INTLV_EN parameter is set         */
           uint32_t             :  3;
      __IO uint32_t  BANK_ADDR_INTLV_EN:  1;        /*!< Enables the capability to interleave the bank address
                                                         within the row address bits.
                                                         Set to 1 to enable                                                    */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_50;                   /*!< 0x9900_00C8                                                           */
    
    struct {
      __IO uint32_t  APREBIT    :  4;               /*!< Location of the auto pre-charge bit in the DRAM address
                                                         Defines the location of the auto pre-chargebit in the DRAM address
                                                         in decimal encoding.
                                                         Note: This parameter will be cleared to 0x0 on reset,
                                                         but will change to the default value on the first controller
                                                          clock edge after reset                                               */
           uint32_t             :  4;
      __IO uint32_t  AGE_COUNT  :  8;               /*!< Initial value of master aging-ratecounter for command aging
                                                         Holds the initial value of the master agingratecounter.
                                                         When using the placement logic to fill the command queue,
                                                         thecommand aging counters will be decremented one each time
                                                         the masteraging-rate counter counts down age_count cycles.
                                                         This parameter is only applicable when priority is enabled as
                                                          a placement factor (the priority_en parameter is set to 'b1)         */
      __IO uint32_t  COMMAND_AGE_COUNT:  8;         /*!< Initial value of individual command aging counters for command
                                                         aging
                                                         Holds the initial value of the command aging counters associated
                                                          with each command in the command queue.
                                                         When using the placement logic to fill the command queue,
                                                         the command aging counters decrement one each time the master
                                                          aging-rate counter counts down the number
                                                         of cycles in the age_count parameter.
                                                         This parameter is only applicable when priority is enabled as
                                                          a placement factor (the priority_en parameter is set to 'b1)         */
      __IO uint32_t  ADDR_CMP_EN:  1;               /*!< Enable address collision detectionas a rule for command queueplacement.
                                                         Set to 1 to enable
                                                         Enables address collision/data coherency detection as a condition
                                                         when using the placement logic to fill the command queue              */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_51;                   /*!< 0x9900_00CC                                                           */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  BANK_SPLIT_EN:  1;             /*!< Enable bank splitting as a rule for command queue placement.
                                                         Set to 1 to enable
                                                         Enables bank splitting as a condition
                                                         when using the placement logic to fill the command queue              */
           uint32_t             :  7;
      __IO uint32_t  PLACEMENT_EN:  1;              /*!< Enable placement logic forcommand queue.
                                                         Set to 1 to enable
                                                         Enables using the placement logic to fill the command queue           */
           uint32_t             :  7;
      __IO uint32_t  PRIORITY_EN:  1;               /*!< Enable priority as a rule for command queue placement.
                                                         Set to 1 to enable
                                                         Enables priority as a condition when using the placement logic
                                                         to fill the command queue                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_52;                   /*!< 0x9900_00D0                                                           */
    
    struct {
      __IO uint32_t  RW_SAME_EN :  1;               /*!< Enable read/write grouping as a rule for command queueplacement.
                                                         Set to 1 to enable
                                                         Enables read/write grouping as a condition
                                                         when using the placement logic to fill the command queue              */
           uint32_t             :  7;
      __IO uint32_t  RW_SAME_PAGE_EN:  1;           /*!< Enables read/write grouping as a condition
                                                         when using the placement logic to fill the command queue
                                                         Enables page grouping within a read/write group
                                                         as a condition when using the placement logic to fill the command
                                                         queue                                                                 */
           uint32_t             :  7;
      __IO uint32_t  DISABLE_RW_GROUP_W_BNK_CONFLICT:  2;/*!< Disables placement to read/write group when grouping creates
                                                         abank collision.
                                                         Bit (0) controls placement next to bank conflict command and
                                                         bit (1) controls placement 2 away from bankconflict command.
                                                         Set each bit to 1 to disable
                                                         Enables read/write grouping as a condition
                                                         when using the placement logic to fill the command queue.
                                                         For more information onthis feature,
                                                         refer to Section 7.1.5,
                                                          "Read/Write Grouping"
                                                         in the "Core Command Queue with Placement Logic" Chapter.
                                                         * Bit [1] = Prohibits placement into a                                */
           uint32_t             :  6;
      __IO uint32_t  NUM_Q_ENTRIES_ACT_DISABLE:  3; /*!< Number of queue entries in which ACT requests will be disabled.
                                                         Setting to X will disable ACT requests
                                                         from the X entries lowest in the command queue
                                                         Specifies the number of entries of the command queue in which
                                                         ACT requests are not allowed.
                                                         For this 8-deep command queue, the entries are numbered 0-7,
                                                         where entry 0 is the command next to execute                          */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_53;                   /*!< 0x9900_00D4                                                           */
    
    struct {
      __IO uint32_t  SWAP_EN    :  1;               /*!< Enable command swapping logic in execution unit.
                                                         Set to 1 to enable
                                                         Enables swapping of the active command for a new higher-priority
                                                         command
                                                         when using the placement logic                                        */
           uint32_t             :  7;
      __IO uint32_t  DISABLE_RD_INTERLEAVE:  1;     /*!< Disable read data interleaving forcommands from the same port,
                                                         regardless of the requestor ID.
                                                         Disables read data interleaving forcommands from the same port,
                                                         regardless of the requestor ID.
                                                         Read data may still be returned out of order regardless of the
                                                         value of this parameter                                               */
           uint32_t             :  7;
      __IO uint32_t  INHIBIT_DRAM_CMD:  1;          /*!< Inhibit read/write command trafficand associated bank commands.
                                                         Set to 1 to inhibit.
                                                         Inhibits certain types of commands frombeing executed from the
                                                         command queue.
                                                         Once the command queue has beeninhibited,
                                                         the DRAM command inhibited interrupt (bit 9) will be set to
                                                          'b1 in the int_status parameter.
                                                         Even when this parameter is programmed to a non-zero value,
                                                         commands may still be accepted into the controller
                                                         and theController core command queue,
                                                         but they will not be executed                                         */
           uint32_t             :  7;
      __IO uint32_t  REDUC      :  1;               /*!< Enable the half datapath feature of the controller.
                                                         Set to 1 to enable
                                                         Allows the same controller to be used with memories with a smaller
                                                         datapath.
                                                         When enabled, certain bits of the DFI data bus are unused since
                                                          the memory data bus is halfthe width
                                                         of the initial configured size
                                                         Note: The entire user datapath is used regardless of this setting.
                                                         Note: This parameter should not be changed after the start parameter
                                                          has been set to 'b1                                                  */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_54;                   /*!< 0x9900_00D8                                                           */
    
    struct {
      __IO uint32_t  Q_FULLNESS :  3;               /*!< Quantity that determines command queue full
                                                         Defines quantity of data that will be considered full for the
                                                         command queue.
                                                         When this value is reached,
                                                         theq_almost_full signal will be driven to the userinterface.          */
           uint32_t             :  5;
      __IO uint32_t  IN_ORDER_ACCEPT:  1;           /*!< Forces the controller to accept commands in the order
                                                         in which they are placed in the command queue
                                                         Forces the command queue selection logic to execute commands
                                                         in the order
                                                         in which they are placed in the command queue without re-ordering
                                                          at execution time
                                                         Forces the command queue selection logic to execute commands
                                                          in the order
                                                         in which they are placed in the command queue without re-ordering
                                                          at execution time                                                    */
           uint32_t             :  7;
      __I  uint32_t  CONTROLLER_BUSY:  1;           /*!< Indicator that the controller is processing a command.
                                                         Evaluates all ports for outstandingtransactions.
                                                         Value of 1 indicates controller busy.
                                                         Indicates that the controller is actively processing a command
                                                         from any port.
                                                         This information is also passed to the ASICthrough the controller_busy
                                                          signal.
                                                         READ-ONLY                                                             */
           uint32_t             :  7;
      __O  uint32_t  CTRLUPD_REQ:  1;               /*!< Assert the DFI controller-initiated update request signal dfi_ctrlupd_req.
                                                         Set to 1 to trigger.
                                                         Triggers a controller-initiated update request on the DFI interface
                                                         (dfi_ctrlupd_req).
                                                         This parameter is write-only and will always read back as 0x0.
                                                         Note: For proper operation, the user must issue at least one
                                                          read
                                                         or write command to memory after reset prior to setting this
                                                          parameter.Note: This parameter may only be set to 'b1when the
                                                          memory controller clock is notgated
                                                         WRITE-ONLY                                                            */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_55;                   /*!< 0x9900_00DC                                                           */
    
    struct {
      __IO uint32_t  CTRLUPD_REQ_PER_AREF_EN:  1;   /*!< Enable an automatic controllerinitiated update (dfi_ctrlupd_req)
                                                         after every refresh.
                                                         Set to 1 toenable
                                                         Enables an automatic controller-initiated update (asserts the
                                                          dfi_ctrlupd_req signal) after every refresh                          */
           uint32_t             :  7;
      __I  uint32_t  INT_STATUS : 13;               /*!< Status of interrupt features in the controller. READ-ONLY             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_56;                   /*!< 0x9900_00E0                                                           */
    
    struct {
      __O  uint32_t  INT_ACK    : 12;               /*!< Clear mask of the INT_STATUS parameter. WRITE-ONLY                    */
           uint32_t             :  4;
      __IO uint32_t  INT_MASK   : 13;               /*!< Mask for controller_int signals from the INT_STATUS parameter
                                                         Active-high mask bits that control the value of the controller_int
                                                         signal on the ASIC interface.
                                                         Unless the user has suppressed interrupt reporting (by setting
                                                          the mostsignificant bit of this parameter to 'b1),
                                                         all lower bits of the int_mask parameter will be inverted and
                                                          logically
                                                         AND'ed with thecorresponding bits of the int_status parameter
                                                         and the result is reported on the controller_int signal.
                                                         * Bit [12] = Masks all interrupt reporting.
                                                         --                                                                    */
    };
  };
  __I  uint32_t  OUT_OF_RANGE_ADDR;                 /*!< 0x9900_00E4
                                                         Address of command that caused an out-of-range interrupt.
                                                         Holds the address of the command
                                                         that caused either of the out-of-range interrupts (bits 0 or
                                                         1)
                                                         in the int_status parameter to be set to 'b1.
                                                         READONLY                                                              */
  
  union {
    __I  uint32_t  DENALI_CTL_58;                   /*!< 0x9900_00E8                                                           */
    
    struct {
      __I  uint32_t  OUT_OF_RANGE_LENGTH:  7;       /*!< Length of command that caused an out-of-range interrupt.
                                                         Holds the length of the command that caused either of the out-of-range
                                                         interrupts (bits 0 or 1)
                                                         in the int_status parameter to be set to 'b1
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __I  uint32_t  OUT_OF_RANGE_TYPE:  7;         /*!< Type of command that caused anout-of-range interrupt.
                                                         Holds the type of command that caused either of the out-of-range
                                                         interrupts (bits 0 or 1)
                                                         in the int_status parameter to be set to 'b1.
                                                         Note: For this configuration,
                                                         bit [1] will always be set to 'b1
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __I  uint32_t  OUT_OF_RANGE_SOURCE_ID: 12;    /*!< Source ID of command that caused an out-of-range interrupt.
                                                         Holds the source ID of the command thatcaused either of the
                                                         out-of-range interrupts (bits 0 or 1)
                                                         in the int_status parameter to be set to 'b1.
                                                         For AXI ports, the source ID is comprised of the Port ID (upper
                                                          bit/s)
                                                         and the Requestor ID,
                                                         where the Requestor ID is the axiY_AWID for write commands
                                                         or the axiY_ARID for read commands
                                                         READONLY                                                              */
    };
  };
  __I  uint32_t  BIST_EXP_DATA0;                    /*!< 0x9900_00EC
                                                         Expected data on BIST error.
                                                         Holds the expected read data for a BISTdata check failure
                                                         READ-ONLY                                                             */
  __I  uint32_t  BIST_EXP_DATA1;                    /*!< 0x9900_00F0
                                                         Holds the expected read data for a BISTdata check failure
                                                         READ-ONLY                                                             */
  __I  uint32_t  BIST_FAIL_DATA0;                   /*!< 0x9900_00F4
                                                         Actual data on BIST error.
                                                         Holds the actual failing data for a BIST data check failure
                                                         READONLY                                                              */
  __I  uint32_t  BIST_FAIL_DATA1;                   /*!< 0x9900_00F8
                                                         Actual data on BIST error.
                                                         Holds the actual failing data for a BIST data check failure
                                                         READONLY                                                              */
  __I  uint32_t  BIST_FAIL_ADDR;                    /*!< 0x9900_00FC
                                                         Address of BIST error.
                                                         Holds the actual failing address for a BISTdata check failure
                                                         READONLY                                                              */
  __I  uint32_t  PORT_CMD_ERROR_ADDR;               /*!< 0x9900_0100
                                                         Address of command that caused the PORT command error.
                                                         Holds the address of the command that caused a port command
                                                         error condition
                                                         READONLY                                                              */
  
  union {
    __IO uint32_t  DENALI_CTL_65;                   /*!< 0x9900_0104                                                           */
    
    struct {
      __I  uint32_t  PORT_CMD_ERROR_ID: 12;         /*!< Source ID of command that caused the PORT command error.
                                                         Holds the source ID of the command thatcaused a port command
                                                         error condition.
                                                         For AXI ports, the source ID is comprised of the Port ID (upper
                                                          bit/s)
                                                         and the Requestor ID,
                                                         where the Requestor ID is the axiY_AWID for write commands
                                                         or the axiY_ARID for read commands.
                                                         READONLY                                                              */
           uint32_t             :  4;
      __I  uint32_t  PORT_CMD_ERROR_TYPE:  2;       /*!< Type of error and access type thatcaused the PORT command error.
                                                         Holds the type of error and the access typethat caused the port
                                                         command error condition.
                                                         If multiple bits are set to 'b1,
                                                         then multiple errors were found
                                                         READ-ONLY                                                             */
           uint32_t             :  6;
      __IO uint32_t  TODTL_2CMD :  8;               /*!< Defines the DRAM delay from anODT de-assertion to the next nonwrite,
                                                         non-read command.
                                                         Defines the DRAM timing between an ODT to the next command,
                                                          in memory clocks.
                                                         * For DDR2 memories: Program to thetAOFD value from the memoryspecificatio
                                                         n                                                                     */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_66;                   /*!< 0x9900_0108                                                           */
    
    struct {
      __IO uint32_t  TODTH_WR   :  4;               /*!< Defines the DRAM minimum ODT high time after an ODT assertion
                                                         for a write command.
                                                         Defines the DRAM timing for the minimumODT high time
                                                         after an ODT assertion for write data.
                                                         When this parameter is programmed to a value larger than the
                                                          number of cycles required for a burst,
                                                         thecommand-to-command delays must be adjusted to delay commands
                                                          as needed.
                                                         * For DDR2 memories: The recommended programming is to program
                                                          this parameter
                                                         * (BST_CYCLES/2) + 1 for the preamble)                                */
           uint32_t             :  4;
      __IO uint32_t  ODT_EN     :  1;               /*!< Enable support of DRAM ODT.
                                                         When enabled, controller will assert
                                                         and de-assert ODT output to DRAM as needed
                                                         Enables the use of the DRAM ODT pin
                                                                                                                               */
           uint32_t             :  7;
      __IO uint32_t  WR_TO_ODTH :  5;               /*!< Defines the delay from a write
                                                         command to ODT assertion                                              */
           uint32_t             :  3;
      __IO uint32_t  R2R_SAMECS_DLY:  5;            /*!< Additional delay to insert betweentwo reads to the same chip
                                                         select.
                                                         Any value including 0x0 supported
                                                         Defines the number of additional controllerclocks of delay to
                                                          insert
                                                         between two read commands to the same chip select.
                                                         This parameter may be programmed to any value including 0x0           */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_67;                   /*!< 0x9900_010C                                                           */
    
    struct {
      __IO uint32_t  R2W_SAMECS_DLY:  5;            /*!< Additional delay to insert betweenreads
                                                         and writes to the same chipselect.
                                                         Program to a non-zero value
                                                         Defines the number of additional controllerclocks
                                                         of delay to insert from a read command to a write command to
                                                         the same chip select.
                                                         This parameter should be programmed to a non-zero value.
                                                         Note: This parameter will be cleared to 0x0on reset,
                                                         but will change to the default value on the first controller
                                                          clock edge after reset                                               */
           uint32_t             :  3;
      __IO uint32_t  W2R_SAMECS_DLY:  5;            /*!< Additional delay to insert betweenwrites
                                                         and reads to the same chip select
                                                         Defines the number of additional controllerclocks
                                                         of delay to insert from a writecommand to a read command to
                                                         the same chip select                                                  */
           uint32_t             :  3;
      __IO uint32_t  W2W_SAMECS_DLY:  5;            /*!< Additional delay to insert betweentwo writes to the same chip
                                                         select.
                                                         Any value including 0x0 supported
                                                         Defines the number of additional controllerclocks
                                                         of delay to insert between two write commands to the same chip
                                                          select.
                                                         This parameter may be programmed to any value including 0x0           */
           uint32_t             :  3;
      __IO uint32_t  OCD_ADJUST_PDN_CS_0:  5;       /*!< OCD pull-down adjust setting for DRAMs for chip select 0
                                                         This parameter is reserved for future use
                                                         and should be cleared to 0x0                                          */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_68;                   /*!< 0x9900_0110                                                           */
    
    struct {
      __IO uint32_t  OCD_ADJUST_PUP_CS_0:  5;       /*!< OCD pull-up adjust setting forDRAMs for chip select 0
                                                         This parameter is reserved for future use
                                                         and should be cleared to 0x0                                          */
           uint32_t             :  3;
      __IO uint32_t  AHB4_WRLEN :  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         4.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc                         */
           uint32_t             :  4;
      __IO uint32_t  AHB4_RDLEN :  4;               /*!< Number of beats minus one for an INCR read command on AHB port4.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB5_WRLEN :  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         5.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc                         */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_69;                   /*!< 0x9900_0114                                                           */
    
    struct {
      __IO uint32_t  AHB5_RDLEN :  4;               /*!< Number of beats minus one for an INCR read command on AHB port
                                                         5.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc                         */
           uint32_t             :  4;
      __IO uint32_t  AHB6_WRLEN :  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         6.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc                         */
           uint32_t             :  4;
      __IO uint32_t  AHB6_RDLEN :  4;               /*!< Number of beats minus one for an INCR read command on AHB port6.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB7_WRLEN :  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         7.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc                         */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_70;                   /*!< 0x9900_0118                                                           */
    
    struct {
      __IO uint32_t  AHB7_RDLEN :  4;               /*!< Number of beats minus one for an INCR read command on AHB port7.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB8_WRLEN :  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         8.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB8_RDLEN :  4;               /*!< Number of beats minus one for an INCR read command on AHB port8.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB9_WRLEN :  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         9.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_71;                   /*!< 0x9900_011C                                                           */
    
    struct {
      __IO uint32_t  AHB9_RDLEN :  4;               /*!< Number of beats minus one for an INCR read command on AHB port9.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB10_WRLEN:  4;               /*!< Number of beats minus one for an INCR write command on AHB port
                                                         10.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AHB10_RDLEN:  4;               /*!< Number of beats minus one for an INCR read command on AHB port10.
                                                         Set to 0 for 1 beat, set to 1 for 2beats, etc.                        */
           uint32_t             :  4;
      __IO uint32_t  AXI0_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 0.
                                                         0 is the highest priority                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_72;                   /*!< 0x9900_0120                                                           */
    
    struct {
      __IO uint32_t  AXI0_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 0.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI0_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 0 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,
                                                         or set to 3 for synchronous                                           */
           uint32_t             :  6;
      __IO uint32_t  AXI1_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 1.
                                                         0 is the highest priority.                                            */
           uint32_t             :  6;
      __IO uint32_t  AXI1_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 1.
                                                         0 is the highest priority                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_73;                   /*!< 0x9900_0124                                                           */
    
    struct {
      __IO uint32_t  AXI1_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 1 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,
                                                         or set to 3 for synchronous                                           */
           uint32_t             :  6;
      __IO uint32_t  AXI2_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 2. 0 is the highest priority   */
           uint32_t             :  6;
      __IO uint32_t  AXI2_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 2. 0 is the highest
                                                         priority.                                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI2_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 2 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous                                              */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_74;                   /*!< 0x9900_0128                                                           */
    
    struct {
      __IO uint32_t  AXI3_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 3. 0 is the highest priority   */
           uint32_t             :  6;
      __IO uint32_t  AXI3_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 3. 0 is the highest
                                                         priority                                                              */
           uint32_t             :  6;
      __IO uint32_t  AXI3_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 3 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous                                              */
           uint32_t             :  6;
      __IO uint32_t  AXI4_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 4.
                                                         0 is the highest priority.                                            */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_75;                   /*!< 0x9900_012C                                                           */
    
    struct {
      __IO uint32_t  AXI4_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 4.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI4_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 4 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous.                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI5_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 5. 0 is the highest priority   */
           uint32_t             :  6;
      __IO uint32_t  AXI5_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 5.
                                                         0 is the highest priority                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_76;                   /*!< 0x9900_0130                                                           */
    
    struct {
      __IO uint32_t  AXI5_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 5 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous                                              */
           uint32_t             :  6;
      __IO uint32_t  AXI6_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 6.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI6_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 6.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI6_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 6 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous                                              */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_77;                   /*!< 0x9900_0134                                                           */
    
    struct {
      __IO uint32_t  AXI7_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 7.
                                                         0 is the highest priority.                                            */
           uint32_t             :  6;
      __IO uint32_t  AXI7_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 7.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI7_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 7 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync, or
                                                         set to 3 for synchronous                                              */
           uint32_t             :  6;
      __IO uint32_t  AXI8_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 8.
                                                         0 is the highest priority                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_78;                   /*!< 0x9900_0138                                                           */
    
    struct {
      __IO uint32_t  AXI8_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 8.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI8_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 8 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous.                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI9_R_PRIORITY:  2;           /*!< Priority of read commands fromAXI port 9.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI9_W_PRIORITY:  2;           /*!< Priority of write commands from AXI port 9.
                                                         0 is the highest priority                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_79;                   /*!< 0x9900_013C                                                           */
    
    struct {
      __IO uint32_t  AXI9_FIFO_TYPE_REG:  2;        /*!< Clock domain relativity between AXI port 9 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous.                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI10_R_PRIORITY:  2;          /*!< Priority of read commands fromAXI port 10.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI10_W_PRIORITY:  2;          /*!< Priority of write commands from AXI port 10.
                                                         0 is the highest priority                                             */
           uint32_t             :  6;
      __IO uint32_t  AXI10_FIFO_TYPE_REG:  2;       /*!< Clock domain relativity between AXI port 10 and the controller
                                                         core.
                                                         Set to 0 for asynchronous,
                                                         set to 1 for 2:1 port:core pseudo-sync,
                                                         setto 2 for 1:2 port:core pseudo-sync,or
                                                         set to 3 for synchronous.                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_80;                   /*!< 0x9900_0140                                                           */
    
    struct {
      __IO uint32_t  ARB_CMD_Q_THRESHOLD:  3;       /*!< Threshold for command queue fullness related to overflow
                                                         Sets the command queue fullness that determines if ports will
                                                         be allowed tooverflow.
                                                         This parameter is used in conjunction with the axiY_bdw_ovflow
                                                          parameters.
                                                         In general, this parameter affects how many commands can be
                                                          accepted or pending in the command queue.
                                                         However, if the user wishes to always prevent bandwidthoverflow,
                                                         this parameter may be cleared to 'b0.
                                                         Because the command queue thresholdsignalling must be returned
                                                          to the arbitration logic,
                                                                                                                               */
           uint32_t             :  5;
      __IO uint32_t  AXI0_BDW   :  7;               /*!< Maximum bandwidth percentage for port 0.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         0.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI0_BDW_OVFLOW:  1;           /*!< Port 0 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 0
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI0_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 0.
                                                         Holds the current bandwidth usage of AXI port 0 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_81;                   /*!< 0x9900_0144                                                           */
    
    struct {
      __IO uint32_t  AXI1_BDW   :  7;               /*!< Maximum bandwidth percentage for port 1.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         1.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI1_BDW_OVFLOW:  1;           /*!< Port 1 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 1
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI1_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 1.
                                                         Holds the current bandwidth usage of AXI port 1 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI2_BDW   :  7;               /*!< Maximum bandwidth percentage for port 2.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         2.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_82;                   /*!< 0x9900_0148                                                           */
    
    struct {
      __IO uint32_t  AXI2_BDW_OVFLOW:  1;           /*!< Port 2 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 2
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI2_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 2.
                                                         Holds the current bandwidth usage of AXI port 2 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI3_BDW   :  7;               /*!< Maximum bandwidth percentage for port 3.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         3.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI3_BDW_OVFLOW:  1;           /*!< Port 3 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 3
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_83;                   /*!< 0x9900_014C                                                           */
    
    struct {
      __I  uint32_t  AXI3_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 3.
                                                         Holds the current bandwidth usage of AXI port 3 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI4_BDW   :  7;               /*!< Maximum bandwidth percentage for port 4.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         4.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI4_BDW_OVFLOW:  1;           /*!< Port 4 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 4
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI4_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 4.
                                                         Holds the current bandwidth usage of AXI port 4 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_84;                   /*!< 0x9900_0150                                                           */
    
    struct {
      __IO uint32_t  AXI5_BDW   :  7;               /*!< Maximum bandwidth percentage for port 5.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         5.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI5_BDW_OVFLOW:  1;           /*!< Port 5 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 5
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI5_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 5.
                                                         Holds the current bandwidth usage of AXI port 5 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI6_BDW   :  7;               /*!< Maximum bandwidth percentage for port 6.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         6.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_85;                   /*!< 0x9900_0154                                                           */
    
    struct {
      __IO uint32_t  AXI6_BDW_OVFLOW:  1;           /*!< Port 6 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 6
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI6_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 6.
                                                         Holds the current bandwidth usage of AXI port 6 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI7_BDW   :  7;               /*!< Maximum bandwidth percentage for port 7.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         7.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI7_BDW_OVFLOW:  1;           /*!< Port 7 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 7
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_86;                   /*!< 0x9900_0158                                                           */
    
    struct {
      __I  uint32_t  AXI7_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 7.
                                                         Holds the current bandwidth usage of AXI port 7 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI8_BDW   :  7;               /*!< Maximum bandwidth percentage for port 8.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         8.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI8_BDW_OVFLOW:  1;           /*!< Port 8 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 8
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI8_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 8.
                                                         Holds the current bandwidth usage of AXI port 8 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_87;                   /*!< 0x9900_015C                                                           */
    
    struct {
      __IO uint32_t  AXI9_BDW   :  7;               /*!< Maximum bandwidth percentage for port 9.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         9.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are                                            */
           uint32_t             :  1;
      __IO uint32_t  AXI9_BDW_OVFLOW:  1;           /*!< Port 9 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 9
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI9_CURRENT_BDW:  7;          /*!< Current bandwidth usage percentage for port 9.
                                                         Holds the current bandwidth usage of AXI port 8 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __IO uint32_t  AXI10_BDW  :  7;               /*!< Maximum bandwidth percentage for port 10.
                                                         Sets the maximum bandwidth allocation percentage for AXI port
                                                         10.
                                                         The percentage is specified as a hex value (0x01 - 0x64)
                                                         representing a decimal percentage valuefrom 1 - 100.
                                                         The user may set the value to avalue greater than 100% (greater
                                                          than 0x64)
                                                         if the user never wants to reach the bandwidth maximum.
                                                         Note: While this controller is connected toAHBand AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters a                                              */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_88;                   /*!< 0x9900_0160                                                           */
    
    struct {
      __IO uint32_t  AXI10_BDW_OVFLOW:  1;          /*!< Port 10 behavior when bandwidthmaximized.
                                                         Set to 1 to allow overflow
                                                         Determines the behavior of AXI port 10
                                                         when the maximum bandwidth has been reached.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                         interface blocks
                                                         so all port parameters are represented in terms of AXI                */
           uint32_t             :  7;
      __I  uint32_t  AXI10_CURRENT_BDW:  7;         /*!< Current bandwidth usage percentage for port 10.
                                                         Holds the current bandwidth usage of AXI port 10 as calculated
                                                         by the Arbiter.
                                                         Thepercentage will be specified as a hex value(0x01 - 0x64)
                                                         representing a decimal percentage value from 1 - 100.
                                                         Note: While this controller is connected toAHB and AXI buses,
                                                         the Controller coreonly connects to the AXI-Controller Core
                                                          interface blocks
                                                         so all port parameters are represented in terms of AXI.
                                                         READ-ONLY                                                             */
           uint32_t             :  1;
      __I  uint32_t  CKE_STATUS :  1;               /*!< Register access to cke_status signal.
                                                         Provides the value of the cke_status signalin a parameter.
                                                         This signal is the value of the control_ckesignal inside the
                                                         controller,
                                                         delayed by the number of controller clocks specified in thecke_delay
                                                          parameter
                                                         READ-ONLY                                                             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_89;                   /*!< 0x9900_0164                                                           */
    
    struct {
      __IO uint32_t  DLL_RST_DELAY: 16;             /*!< Minimum number of cycles required for DLL reset signaldll_rst_n
                                                         to be held.
                                                         If this signal is not being used by the PHY,
                                                         this parameter may be ignored
                                                         Sets the number of controller clocks that theDLL reset (dll_rst_n)
                                                          must be held assertedfor the DLL.
                                                         If the dll_rst_n signal is being used in the system,
                                                         this parameter may be useful.
                                                         If the dll_rst_n signal is not being used,
                                                         this parameter may be ignored                                         */
      __IO uint32_t  DLL_RST_ADJ_DLY:  8;           /*!< Minimum number of cycles aftersetting master delay
                                                         in DLL until the DLL reset signal dll_rst_n maybe asserted.
                                                         If this signal is not being used by the PHY,
                                                         this parameter may be ignored
                                                         Specifies the minimum number of controller clocks
                                                         after the master delay value isprogrammed
                                                         before the DLL reset (dll_rst_n) may be asserted.
                                                         If the dll_rst_n signal is being used in the system,
                                                         this parameter may be useful.
                                                         If the dll_rst_n signal is not being used,
                                                         this parameter may be ignored                                         */
      __I  uint32_t  TDFI_PHY_WRLAT:  4;            /*!< Holds the calculated DFI tPHY_WRLAT timing parameter.
                                                         Holds the calculated value of the DFI tphy_wrlat timing parameter,
                                                         the maximumnumber of DFI PHY clocks between
                                                         when a write command is sent on the DFI controlinterface
                                                         and when the dfi_wrdata_en signal is asserted.
                                                         This parameter is used to adjust the dfi_wrdata_en signal timing.
                                                         The minimumsupported value for the wrlat_adj parameteris 1,
                                                         and the minimum supported value fortdfi_phy_wrlat is 0.
                                                         tdfi_phy_wrlat = wrlat_adj + reg_dimm_enable - 1
                                                         All DFI tim                                                           */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_90;                   /*!< 0x9900_0168                                                           */
    
    struct {
      __I  uint32_t  UPDATE_ERROR_STATUS:  7;       /*!< Identifies the source of any DFI MC-initiated
                                                         or PHY-initiated update errors.
                                                         Value of 1 indicates a timing violation
                                                         of the associated timing parameter.
                                                         Reports errors in the PHY update process.This parameter will
                                                         be valid
                                                         when the DFI update error interrupt (bit 7)
                                                         in the int_status parameter is set to 'b1.
                                                         If multiple errors occur,
                                                         only the last error will be reported inthis parameter.
                                                         Each bit represents a violation of the timing defined in the
                                                          associated parameter:
                                                         * Bit [6] = tdfi_phyupd_resp
                                                         * Bit [                                                               */
           uint32_t             :  1;
      __IO uint32_t  TDFI_PHY_RDLAT:  4;            /*!< Holds the DFI tPHY_RDLAT timing parameter
                                                         Defines the DFI tphy_rdlat timing parameter,
                                                         the maximum number of DFI PHY clocks allowed from the assertion
                                                         of the dfi_rddata_en signal to the assertion
                                                         of the dfi_rddata_valid signal.
                                                         This value is also used in read/modify/write operations to determine
                                                         when read and write data can be merged,
                                                         when the DFI controller update request can be asserted
                                                         and for read ID recycling.
                                                         Programming this parameter with too small avalue can lead to
                                                         data corruption. However,progra                                       */
           uint32_t             :  4;
      __I  uint32_t  TDFI_RDDATA_EN:  4;            /*!< Holds the calculated DFI tRDDATA_EN timing parameter.
                                                         Holds the calculated value of the DFI trddata_en timing parameter,
                                                         the number of DFI PHY clocks from the assertion
                                                         of a read command on the DFI to the assertion
                                                         of the dfi_rddata_en signal.
                                                         This parameter is used to adjust the dfi_rddata_en signal timing.
                                                         The minimumsupported value for the rdlat_adj parameteris 2,
                                                         and the minimum supported value for tdfi_rddata_en is 1.
                                                         tdfi_rddata_en = rdlat_adj + reg_dimm_enable - 1
                                                         All DFI timing parameters will be d                                   */
           uint32_t             :  4;
      __IO uint32_t  DRAM_CLK_DISABLE:  1;          /*!< Set value for the dfi_dram_clk_disable signal.
                                                         Bit (0)controls cs0,
                                                         bit (1) controls cs1, etc.
                                                         Set each bit to 1 to disable                                          */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_91;                   /*!< 0x9900_016C                                                           */
    
    struct {
      __I  uint32_t  TDFI_CTRLUPD_MIN:  4;          /*!< Holds the DFI tCTRLUPD_MINtiming parameter.
                                                         Reports the DFI tctrlupd_min timing parameter,
                                                         the minimum number of DFI clocks that the dfi_ctrlupd_req signal
                                                         must be asserted.
                                                         All DFI timing parameters must be programmed relative to the
                                                          DFI clock.                                                           */
           uint32_t             :  4;
      __IO uint32_t  TDFI_CTRLUPD_MAX: 14;          /*!< Holds the DFI tCTRLUPD_MAX timing parameter.
                                                         If programmed to a non-zero,
                                                         a timing violation willcause an interrupt and
                                                         bit (1) set in the UPDATE_ERROR_STATUS parameter
                                                         Defines the DFI tctrlupd_max timingparameter,
                                                         the maximum number of DFI clocks that the dfi_ctrlupd_req signal
                                                         can assert.
                                                         If this timing is violated,
                                                         the controller will deassert the dfi_ctrlupd_req signal,
                                                         set the DFIupdate error interrupt (bit 7)
                                                         in the int_status parameter to 'b1
                                                         and report the error type in the update_error_status para             */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_92;                   /*!< 0x9900_0170                                                           */
    
    struct {
      __IO uint32_t  TDFI_PHYUPD_TYPE0: 16;         /*!< Holds the DFI tPHYUPD_TYPE0 timing parameter.
                                                         If programmed to a non-zero,
                                                         a timing violation willcause an interrupt
                                                         and bit (2) set in the UPDATE_ERROR_STATUS parameter
                                                         Defines the DFI tphyupd_typeX timing parameter,
                                                         the maximum number of DFI clocks that the dfi_phyupd_req signal
                                                         mayremain asserted
                                                         after the assertion of the dfi_phyupd_ack signal for each dfi_phyupd_typeX
                                                         .If this timing is violated,
                                                         the controller will deassert the dfi_phyupd_ack signal,
                                                         set theDFI update error interrupt (bit 7) in the in                   */
      __IO uint32_t  TDFI_PHYUPD_TYPE1: 16;         /*!< Holds the DFI tPHYUPD_TYPE1 timing parameter.
                                                         If programmed to a non-zero,
                                                         a timing violation willcause an interrupt
                                                         and bit (3) set in the UPDATE_ERROR_STATUS parameter.
                                                         Defines the DFI tphyupd_typeX timing parameter,
                                                         the maximum number of DFI clocks that the dfi_phyupd_req signal
                                                         mayremain asserted
                                                         after the assertion of the dfi_phyupd_ack signal for each dfi_phyupd_typeX
                                                         .If this timing is violated,
                                                         the controller will deassert the dfi_phyupd_ack signal,
                                                         set theDFI update error interrupt (bit 7) in the i                    */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_93;                   /*!< 0x9900_0174                                                           */
    
    struct {
      __IO uint32_t  TDFI_PHYUPD_TYPE2: 16;         /*!< Holds the DFI tPHYUPD_TYPE2 timing parameter.
                                                         If programmed to a non-zero,
                                                         a timing violation willcause an interrupt
                                                         and bit (4) set in the UPDATE_ERROR_STATUS parameter
                                                         Defines the DFI tphyupd_typeX timing parameter,
                                                         the maximum number of DFI clocks that the dfi_phyupd_req signal
                                                         mayremain asserted
                                                         after the assertion of the dfi_phyupd_ack signal for each dfi_phyupd_typeX
                                                         .If this timing is violated,
                                                         the controller will deassert the dfi_phyupd_ack signal,
                                                         set theDFI update error interrupt (bit 7) in the in                   */
      __IO uint32_t  TDFI_PHYUPD_TYPE3: 16;         /*!< Holds the DFI tPHYUPD_TYPE3 timing parameter.
                                                         If programmed to a non-zero,
                                                         a timing violation willcause an interrupt
                                                         and bit (5) set in the UPDATE_ERROR_STATUS parameter
                                                         Defines the DFI tphyupd_typeX timing parameter,
                                                         the maximum number of DFI clocks that the dfi_phyupd_req signal
                                                         mayremain asserted
                                                         after the assertion of the dfi_phyupd_ack signal for each dfi_phyupd_typeX
                                                         .If this timing is violated,
                                                         the controller will deassert the dfi_phyupd_ack signal,
                                                         set theDFI update error interrupt (bit 7) in the in                   */
    };
  };
  __IO uint16_t  TDFI_PHYUPD_RESP;                  /*!< 0x9900_0178
                                                         Holds the DFI tPHYUPD_RESP timing parameter.
                                                         If programmed to a non-zero,
                                                         a timing violation willcause an interrupt
                                                         and bit (6) set in the UPDATE_ERROR_STATUS parameter
                                                         Defines the DFI tphyupd_resp timingparameter,
                                                         the maximum number of DFI clocks
                                                         after the assertion of the dfi_phyupd_req signal to the assertion
                                                         of the dfi_phyupd_ack signal.
                                                         If this timing is violated,
                                                         the controller will set the DFIupdate error interrupt (bit 7)
                                                         in the int_status parameter to 'b1
                                                         and report the error type in t                                        */
  __I  uint16_t  RESERVED4;
  __IO uint32_t  TDFI_CTRLUPD_INTERVAL;             /*!< 0x9900_017C
                                                         Holds the DFI tCTRLUPD_INTERVAL timing parameter.
                                                         If programmed to a nonzero,
                                                         a timing violation will cause an interrupt
                                                         and bit (0) set in the UPDATE_ERROR_STATUS parameter
                                                         Defines the DFI tctrlupd_interval timing parameter,
                                                         the maximum number of DFI clocks that the Controller may wait
                                                         between assertions
                                                         of the dfi_ctrlupd_req signal.
                                                         If thistiming is violated,
                                                         the controller will set theDFI update error interrupt (bit 7)
                                                         in the int_status parameter to 'b1
                                                         and report the error type in the upda                                 */
  
  union {
    __IO uint32_t  DENALI_CTL_96;                   /*!< 0x9900_0180                                                           */
    
    struct {
      __IO uint32_t  RDLAT_ADJ  :  4;               /*!< Adjustment value for PHY read timing
                                                         Adjusts the relative timing between DFI read commands
                                                         and the dfi_rddata_en signal toconform to PHY timing requirements.
                                                         Setting this parameter to 0x2 will cause the dfi_rddata_en will
                                                         assert one DFI clock
                                                         after the dfi_address signal.
                                                         Each incremental increase will further delay the dfi_rddata_en
                                                          signal.
                                                         The minimum supported value forthis parameter is 2.
                                                         This parameter affects the actual PHY read latency (tdfi_rddata_en)
                                                          as follows:
                                                         tdfi_rddata_en = rdlat_adj + reg_di                                   */
           uint32_t             :  4;
      __IO uint32_t  WRLAT_ADJ  :  4;               /*!< Adjustment value for PHY writetiming
                                                         Adjusts the relative timing in memory clocks between DFI write
                                                         commands
                                                         and thedfi_wrdata_en signal to conform to PHY timing requirements.
                                                         Setting this parameter to 0x1 will cause the dfi_wrdata_en to
                                                          assert
                                                         on the samecontroller clock as the dfi_address.
                                                         Each incremental increase will delay the dfi_wrdata_en signal.
                                                         The minimumsupported value for this parameter is 1.
                                                         This parameter affects the actual PHY writelatency (tdfi_phy_wrlat)
                                                          as follows:
                                                         tdfi_phy_wrlat = wrlat_                                               */
           uint32_t             :  4;
      __IO uint32_t  TDFI_CTRL_DELAY:  4;           /*!< Delay from DFI command to memory command
                                                         Defines the DFI tctrl_delay timing parameter,
                                                         the number of DFI clocks
                                                         after an assertion or de-assertion
                                                         of the DFI control signals that the control signals
                                                         at the PHY-DRAMinterface will reflect the assertion or deassertion.
                                                         This parameter should be programmed to the number
                                                         of DFI clocks that the PHY requires to send a power-down
                                                         or selfrefresh command to the DRAM memories.
                                                         All DFI timing parameters must be programmed relative to the
                                                         DFI clock.
                                                         Note: This parameter                                                  */
           uint32_t             :  4;
      __IO uint32_t  TDFI_DRAM_CLK_DISABLE:  4;     /*!< Delay from DFI clock disable to memory clock disable
                                                         Defines the DFI tdram_clk_disable timing parameter,
                                                         the number of DFI clocks from the assertion
                                                         of the dfi_dram_clk_disablesignal
                                                         on the DFI until the clock to the DRAM memories,
                                                         at the PHY-DRAM boundary,
                                                         maintains a low value.
                                                         This parameter should be programmed to the number
                                                         of DFI clocks that the PHY requires to disable the memory clock
                                                         after the dfi_dram_clk_disable signal is asserted.
                                                         The user should determine these values based on their pad types.
                                                                                                                               */
    };
  };
  
  union {
    __IO uint32_t  DENALI_CTL_97;                   /*!< 0x9900_0184                                                           */
    
    struct {
      __IO uint32_t  TDFI_DRAM_CLK_ENABLE:  4;      /*!< Delay from DFI clock enable tomemory clock enable
                                                         Defines the DFI tdram_clk_enable timing parameter,
                                                         the number of DFI clocks from the de-assertion
                                                         of the dfi_dram_clk_disablesignal
                                                         on the DFI until the first valid risingedge
                                                         of the clock to the DRAM memories,
                                                         at the PHY-DRAM boundary.
                                                         This parameter is used to indicate the number
                                                         of DFI clocks that the PHY requires to respond to a deassertion
                                                         of the dfi_dram_clk_disable signal.
                                                         The user should determine these values based on their pad types.
                                                         For example,                                                          */
           uint32_t             :  4;
      __IO uint32_t  ODT_ALT_EN :  1;               /*!< Enable use of non-DFI odt_alt signal.
                                                         Set to 1 to enable
                                                         Enables the use of the non-DFI compliant alternative ODT internal
                                                         signal odt_alt,
                                                         which is externally viewed as the signal reserved0.
                                                         This signal is only required
                                                         if the user intends to use a CAS latency of 3 with ODT support        */
           uint32_t             :  7;
      __IO uint32_t  TDFI_PHY_WRDATA:  3;           /*!< Defines the DFI tPHY_WRDATA timing parameter
                                                         (in DFI PHYclocks),
                                                         the maximum cycles between a dfi_wrdata_en assertion and
                                                         a dfi_wrdata signal                                                   */
    };
  };
} DDR_Type;


/* ================================================================================ */
/* ================                     DDR_PHY                    ================ */
/* ================================================================================ */


/**
  * @brief DDR PHY (DDR_PHY)
  */

typedef struct {                                    /*!< DDR_PHY Structure                                                     */
  
  union {
    __IO uint16_t  DEN_PHY_DQ_TIMING_REG_0;         /*!< 0x9900_0200
                                                         Controls PHY slice 0
                                                         There is a den_phy_dq_timing_reg_X parameter for each of the
                                                         slices
                                                         of data sent on the DFI data bus.
                                                         * Bits [15:8] = tsel_select (DQ)
                                                         * Bits [7:0] = data_oe_select (DQ)
                                                         * All other bits are reserved for future use and must be set
                                                          to 'b0.                                                              */
    
    struct {
      __IO uint16_t  oe_end_s01 :  3;               /*!< Adjusts the ending point of the DQ pad output enable window
                                                         Lower numbers pull the falling edge earlier in time,
                                                         and larger numbers cause the falling edge to be delayed.
                                                         Each bit changes the outputenable time by a 1/4 cycle resolution.
                                                         This field must be set to at least the value
                                                         of oe_start_s0 + 2 to prevent disabling the pad
                                                         before the data is completely written.
                                                         Default 0x7.                                                          */
           uint16_t             :  1;
      __IO uint16_t  oe_start_s01:  3;              /*!< Adjusts the starting point of the DQ pad output enable window.
                                                         Lower numbers pull the rising edge earlier in time,
                                                         and larger numbers cause the risingedge to be delayed.
                                                         Each bit changes the output enable time by a 1/4 cycle resolution.
                                                         Default 0x2.                                                          */
           uint16_t             :  1;
      __IO uint16_t  tsel_end_s01:  4;              /*!< Defines the DQ pad dynamic termination select disable time.
                                                         Larger values increase the delay to when tsel turns off.
                                                         Each bit changes the outputenable time by a 1/2 cycle resolution.     */
      __IO uint16_t  tsel_start_s01:  4;            /*!< Defines the DQ pad dynamic termination select enable time.
                                                         Larger values add greater delay to when tsel turns on.
                                                         Each bit changes the output enable time by a 1/2 cycle resolution.    */
    };
  };
  __I  uint16_t  RESERVED;
  
  union {
    __IO uint16_t  DEN_PHY_DQS_TIMING_REG_0;        /*!< 0x9900_0204
                                                         Controls PHY slice 0
                                                         There is a den_phy_dqs_timing_reg_X parameter for each 
                                                         of the slices of data sent on the DFI data bus.
                                                         * Bits [15:8] = tsel_select (DQS)
                                                         * Bits [7:0] = dqs_oe_select (DQS)
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0.                                                               */
    
    struct {
      __IO uint16_t  oe_end_s00 :  4;               /*!< Adjusts the ending point
                                                         of the DQS pad output enable window.
                                                         Lower numbers pull the falling edge earlierin time,
                                                         and larger numbers cause the falling edge to be delayed.
                                                         Each bit changes the output enable time by a 1/4 cycle resolution.
                                                         This field must be set to at least the value
                                                         of oe_start_s0 +2 to prevent disabling the pad before the data
                                                         is completely written.
                                                         Default0x7.                                                           */
      __IO uint16_t  oe_start_s00:  4;              /*!< Adjusts the starting point
                                                         of the DQS pad output enable window.
                                                         Lower numbers pull the rising edge earlier in time,
                                                         and larger numbers cause the risingedge to be delayed.
                                                         Each bit changes the output enable time by a 1/4 cycle resolution.
                                                         Default 0x2.                                                          */
      __IO uint16_t  tsel_end_s00:  4;              /*!< Defines the DQS pad dynamic termination select disable time.
                                                         Larger values increase the delay to when tsel turns off.
                                                         Each bit changes the outputenable time by a 1/2 cycle resolution.     */
      __IO uint16_t  tsel_start_s00:  4;            /*!< Defines the DQS pad dynamic termination select enable time.
                                                         Larger values add greater delay to when tsel turns on.
                                                         Each bit changes the output enable time by a 1/2 cycle resolution.    */
    };
  };
  __I  uint16_t  RESERVED1;
  
  union {
    __IO uint32_t  DEN_PHY_GATE_LPBK_CTRL_REG_0;    /*!< 0x9900_0208
                                                         Controls PHY slice 0
                                                         There is a den_phy_gate_lpbk_ctrl_reg_Xparameter
                                                         for each of the slices of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0.                                                               */
    
    struct {
      __IO uint32_t  gate_cfg_s0:  3;               /*!< Coarse adjust of gate open time.
                                                         This value is the number of cycles to delaythe dfi_rddata_en
                                                         signal prior to opening the gate
                                                         in full cycle increments.
                                                         Decreasing this value pulls the gate earlier in time.
                                                         This field should be programmed such that the gate signal initiallylands
                                                         in the valid DQS gate window.
                                                         The valid DQS gate window is from the start
                                                         of the readpreamble to the first falling edge of DQS.                 */
      __IO uint32_t  gate_close_cfg_s0:  2;         /*!< Program with a nonzerovalue to extend the closing of the DQS
                                                         gate.
                                                         This should only be done when the round trip flight time
                                                         of the DQS (IO_Pad_Delay + (Flight Time * 2) + IO_Input_Pad_Delay)
                                                          + tDQSCK(max) is greater than 2 times the cycle time.                */
      __IO uint32_t  gate_error_delay_s0:  3;       /*!< Defines the number of cycles of margin allowed for the finalDQS
                                                         falling edge of a read burst.
                                                         An error will occur if the final DQS is not found
                                                         after DQS_FALLING_EDGE_EXP_DLY
                                                         and before (DQS_FALLING_EDGE_EXP_DLY+ gate_error_delay) cycles.
                                                         If this field is set to a non-zero value and an error occurs,
                                                         the PHY will automatically de-assert (close) the read DQS gate
                                                         and log the error in the dqs_error_out field (bit [24])
                                                         of the den_phy_obs_reg_0_X parameter.
                                                         In the event of an error,
                                                         the user should check the c                                           */
      __IO uint32_t  lpbk_en_s0 :  1;               /*!< Dicide if loopback test is enable
                                                         Controls the internal writemultiplexer                                */
      __IO uint32_t  lpbk_internal_s0:  1;          /*!< Define loopback test is internal or external
                                                         Controls the loopbackread multiplexer.                                */
      __IO uint32_t  Loopback_Control_s0:  2;       /*!< Loopback control
                                                                                                                               */
      __IO uint32_t  lpbk_fail_muxsel_s0:  1;       /*!< Selects the data output type for the lpbk_dq_data (SLICE 0)
                                                         Selects the data output type for the lpbk_dq_data_s0 and lpbk_dm_data_s0
                                                         of the den_phy_obs_reg_0_X parameter.                                 */
      __IO uint32_t  lpbk_err_check_timing_s0:  3;  /*!< Sets the cycle delay between the LFSR and loopback error check
                                                         logic to ensure
                                                         that the LFSR sourced data
                                                         and data being looped back arrive at the same clock cycle for
                                                          comparison.
                                                         This value is related to the rd_dly_sel_s0, and is equal to7.         */
           uint32_t             :  7;
      __IO uint32_t  clk_count_compare_sel_s0:  1;  /*!< Select clock count for posedge or negedge (used for dqs close
                                                         logic)                                                                */
      __IO uint32_t  close_last_sel_s0:  1;         /*!< Select last register for posedge or negedge (used for dqs close
                                                         logic)                                                                */
           uint32_t             :  4;
      __IO uint32_t  enable_half_cas_s0:  1;        /*!< Subtracts 1/2 cycle from the DQS gate value programmed
                                                         into gate_cfg_s0 of this parameter by 1/2 cycle. Default 0x0.
                                                         This is used when the gate is being aligned to the first DQS,
                                                         and then is removed to move the gate back into the center of
                                                         the preamble.
                                                                                                                               */
    };
  };
  __IO uint8_t   rd_dly_sel_s0;                     /*!< 0x9900_020C
                                                         Controls PHY slice 0
                                                         Holds the read delay setting.
                                                         read_delay setting for io_datain FIFO timing.
                                                         Controls the number of cycles to wait to pull data out
                                                         of the read FIFO that has been clocked by the read DQS signal.
                                                         This field should be programmed to the roundedup value
                                                         of the equation ASYNC_DELAY_max/tCK,
                                                         where ASYNC_DELAY_max is the worst case ASYNC_DELAY. * All other
                                                         bits are reserved for future use and must be set to 'b0               */
  __I  uint8_t   RESERVED2[3];
  
  union {
    __IO uint32_t  PHY_DLL_MASTER_CTRL_REG_0;       /*!< 0x9900_0210
                                                         Controls the DLL for slice 0
                                                         There is a phy_dll_master_ctrl_reg_X parameter
                                                         for each ofthe slices of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0.                                                               */
    
    struct {
      __IO uint32_t  param_dll_start_point_s0:  8;  /*!< This value is the initial delay value for the DLL.
                                                         This value is also used as the increment value
                                                         if the initial value is less than a half-clock cycle.
                                                         This field should be set such that
                                                         it is not greater than 7/8ths of a clock period given the worst
                                                         case element delay.
                                                         For example, if the frequency is 400MHz (2.5ns cycle time) with
                                                          a worst case element 80ps delay,
                                                         this this field should be set to = 2.5 * (7/8) / .080 = 27 elements.
                                                         This calculation helps determine the start point which achieves
                                                          the fastes                                                           */
           uint32_t             :  8;
      __IO uint32_t  param_dll_lock_num_s0:  3;     /*!< Holds the number of consecutive increment
                                                         or decrement indications that will trigger an unlock condition
                                                         and increment the dll_unlock_cnt_s0,
                                                         and either the lock_dec_dbg_s0
                                                         or lock_inc_dbg fields_s0 of the phy_dll_obs_reg_0_0 parameter.       */
           uint32_t             :  1;
      __IO uint32_t  param_phase_detect_sel_s0:  3; /*!< DLL Phase Detect Selector to handle the clock domain crossing
                                                         betweenthe clock and clk_wrdqs signal                                 */
      __IO uint32_t  param_dll_bypass_mode_s0:  1;  /*!< Controls the bypass mode of the master and slave DLLs.
                                                         If this bit is set,
                                                         The param_dll_bypass_mode is intended to be used only for debug.      */
    };
  };
  
  union {
    __IO uint16_t  PHY_DLL_SLAVE_CTRL_REG_0;        /*!< 0x9900_0214
                                                         Controls the DLL for slice 0
                                                         There is a phy_dll_slave_ctrl_reg_X parameter
                                                         foreach of the slices of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use
                                                         andmust be set to 'b0.                                                */
    
    struct {
      __IO uint16_t  param_dll_rddqs_delay_s0:  8;  /*!< Dicide delay value for read dqs in DLL,
                                                         If the value is 0x40 means 1/4 cycle of read DQS delay                */
      __IO uint16_t  param_dll_wrdqs_delay_s0:  8;  /*!< Dicide delay value for write dqs in DLL,
                                                         If the value is 0x40 means 1/4 cycle of write DQS delay               */
    };
  };
  __I  uint16_t  RESERVED3;
  
  union {
    __I  uint32_t  DEN_PHY_OBS_REG_0_0;             /*!< 0x9900_0218
                                                         Controls loopback status,
                                                         data andmasking info for slice 0.
                                                         Reports status for the PHY for data slice 0.
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0. READONLY                                                      */
    
    struct {
      __I  uint32_t  lpbk_start_s0:  1;             /*!< Defines the status of the loopback mode.                              */
      __I  uint32_t  lpbk_status_s0:  1;            /*!< Reports status of loopback errors                                     */
           uint32_t             :  2;
      __I  uint32_t  lpbk_dm_data_s0:  1;           /*!< Reports the actual data mask or the expected data mask,
                                                         depending on the setting of the lpbk_fail_muxsel_s0 field
                                                         of the den_phy_gate_lpbk_ctrl_reg_X parameter.                        */
           uint32_t             :  3;
      __I  uint32_t  lpbk_dq_data_s0: 16;           /*!< Reports the actual data or expected data,
                                                         depending on the setting of the lpbk_fail_muxsels0 field
                                                         of the den_phy_gate_lpbk_ctrl_reg_X parameter.
                                                                                                                               */
      __I  uint32_t  dqs_error_out_s0:  1;          /*!< Status signal to indicate that the logic gate had to be forced
                                                         closed.                                                               */
    };
  };
  
  union {
    __I  uint32_t  PHY_DLL_OBS_REG_0_0;             /*!< 0x9900_021C
                                                         Reports DLL status for slice 0.
                                                         There is a phy_dll_obs_reg_0_X parameter
                                                         for each of theslices of data sent on the DFI data bus.
                                                         READ-ONLY                                                             */
    
    struct {
      __I  uint32_t  dll_lock_s0:  1;               /*!< Indicates status of the master DLL                                    */
      __I  uint32_t  dll_locked_mode_s0:  2;        /*!< Defines the mode in which the DLL has achieved the lock               */
      __I  uint32_t  dll_unlock_cnt_s0:  5;         /*!< Reports the number of times that the master DLL consecutive
                                                         increment
                                                         or decrement value programmed into the param_dll_lock_num_s0
                                                         of the phy_dll_master_ctrl_reg_X parameter has beentriggered.
                                                          The count will saturate at a value of 0x1f.
                                                         Asserting the dll_rst_n signal will reset this counter to 0.          */
      __I  uint32_t  dll_lock_value_s0:  8;         /*!< Reports the numberof delay elements that the DLL has determined
                                                         for lock
                                                         in either full clock or half clock mode.
                                                         In full clock mode, this value equals the number ofdelay elements
                                                          in one cycle.
                                                         In half clock mode,this value equals the number of delay elements
                                                          in one half clock cycle.
                                                         In saturation mode, this value equals the maximum number of
                                                          delay elements.                                                      */
      __I  uint32_t  lock_dec_dbg_s0:  8;           /*!< Holds the state ofthe cumulative dll_lock_dec register
                                                         when the dll_unlock_cnt_s0 of this parameter was triggered to
                                                         decrement,
                                                         or was lastsaturated at a value of 0x1f                               */
      __I  uint32_t  lock_inc_dbg_s0:  8;           /*!< Holds the state ofthe cumulative dll_lock_inc register
                                                         when the dll_unlock_cnt_s0 of this parameter was triggered to
                                                         increment,
                                                         or was last saturated at a value of 0x1f.                             */
    };
  };
  
  union {
    __I  uint32_t  PHY_DLL_OBS_REG_1_0;             /*!< 0x9900_0220
                                                         Reports DLL status for slice 0.
                                                         There is a phy_dll_obs_reg_1_X parameter for each of the slices
                                                         of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use and must be set
                                                          to 'b0.                                                              */
    
    struct {
      __I  uint32_t  decoder_out_rd_s0:  8;         /*!< Holds the encoded value for the read delay line for this slice.       */
           uint32_t             :  8;
      __I  uint32_t  decoder_out_wr_s0:  8;         /*!< Holds the encoded value for the clk_wr delay line for thisslice.      */
    };
  };
  __I  uint32_t  RESERVED4[7];
  
  union {
    __IO uint16_t  DEN_PHY_DQ_TIMING_REG_1;         /*!< 0x9900_0240
                                                         Controls PHY slice 1
                                                         There is a den_phy_dq_timing_reg_X parameter for each of the
                                                         slices
                                                         of data sent on the DFI data bus.
                                                         * Bits [15:8] = tsel_select (DQ)
                                                         * Bits [7:0] = data_oe_select (DQ)
                                                         * All other bits are reserved for future use and must be set
                                                          to 'b0.                                                              */
    
    struct {
      __IO uint16_t  oe_end_s11 :  3;               /*!< Adjusts the ending point of the DQ pad output enable window
                                                         Lower numbers pull the falling edge earlier in time,
                                                         and larger numbers cause the falling edge to be delayed.
                                                         Each bit changes the outputenable time by a 1/4 cycle resolution.
                                                         This field must be set to at least the value
                                                         of oe_start_s1 + 2 to prevent disabling the pad
                                                         before the data is completely written.
                                                         Default 0x7.                                                          */
           uint16_t             :  1;
      __IO uint16_t  oe_start_s11:  3;              /*!< Adjusts the starting point of the DQ pad output enable window.
                                                         Lower numbers pull the rising edge earlier in time,
                                                         and larger numbers cause the risingedge to be delayed.
                                                         Each bit changes the output enable time by a 1/4 cycle resolution.
                                                         Default 0x2.
                                                                                                                               */
           uint16_t             :  1;
      __IO uint16_t  tsel_end_s11:  4;              /*!< Defines the DQ pad dynamic termination select disable time.
                                                         Larger values increase the delay to when tsel turns off.
                                                         Each bit changes the outputenable time by a 1/2 cycle resolution.     */
      __IO uint16_t  tsel_start_s11:  4;            /*!< Defines the DQ pad dynamic termination select enable time.
                                                         Larger values add greater delay to when tsel turns on.
                                                         Each bit changes the output enable time by a 1/2 cycle resolution.    */
    };
  };
  __I  uint16_t  RESERVED5;
  
  union {
    __IO uint16_t  DEN_PHY_DQS_TIMING_REG_1;        /*!< 0x9900_0244
                                                         Controls PHY slice 1
                                                         There is a den_phy_dqs_timing_reg_X parameter for each 
                                                         of the slices of data sent on the DFI data bus.
                                                         * Bits [15:8] = tsel_select (DQS)
                                                         * Bits [7:0] = dqs_oe_select (DQS)
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0.                                                               */
    
    struct {
      __IO uint16_t  oe_end_s10 :  4;               /*!< Adjusts the ending point
                                                         of the DQS pad output enable window.
                                                         Lower numbers pull the falling edge earlierin time,
                                                         and larger numbers cause the falling edge to be delayed.
                                                         Each bit changes the output enable time by a 1/4 cycle resolution.
                                                         This field must be set to at least the value
                                                         of oe_start_s1 +2 to prevent disabling the pad before the data
                                                         is completely written.
                                                         Default0x7.                                                           */
      __IO uint16_t  oe_start_s10:  4;              /*!< Adjusts the starting point
                                                         of the DQS pad output enable window.
                                                         Lower numbers pull the rising edge earlier in time,
                                                         and larger numbers cause the risingedge to be delayed.
                                                         Each bit changes the output enable time by a 1/4 cycle resolution.
                                                         Default 0x2.                                                          */
      __IO uint16_t  tsel_end_s10:  4;              /*!< Defines the DQS pad dynamic termination select disable time.
                                                         Larger values increase the delay to when tsel turns off.
                                                         Each bit changes the outputenable time by a 1/2 cycle resolution.     */
      __IO uint16_t  tsel_start_s10:  4;            /*!< Defines the DQS pad dynamic termination select enable time.
                                                         Larger values add greater delay to when tsel turns on.
                                                         Each bit changes the output enable time by a 1/2 cycle resolution.    */
    };
  };
  __I  uint16_t  RESERVED6;
  
  union {
    __IO uint32_t  DEN_PHY_GATE_LPBK_CTRL_REG_1;    /*!< 0x9900_0248
                                                         Controls PHY slice 1
                                                         There is a den_phy_gate_lpbk_ctrl_reg_Xparameter
                                                         for each of the slices of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0.                                                               */
    
    struct {
      __IO uint32_t  gate_cfg_s1:  3;               /*!< Coarse adjust of gate open time.
                                                         This value is the number of cycles to delaythe dfi_rddata_en
                                                         signal prior to opening the gate
                                                         in full cycle increments.
                                                         Decreasing this value pulls the gate earlier in time.
                                                         This field should be programmed such that the gate signal initiallylands
                                                         in the valid DQS gate window.
                                                         The valid DQS gate window is from the start
                                                         of the readpreamble to the first falling edge of DQS.                 */
      __IO uint32_t  gate_close_cfg_s1:  2;         /*!< Program with a nonzerovalue to extend the closing of the DQS
                                                         gate.
                                                         This should only be done when the round trip flight time
                                                         of the DQS (IO_Pad_Delay + (Flight Time * 2) + IO_Input_Pad_Delay)
                                                          + tDQSCK(max) is greater than 2 times the cycle time.                */
      __IO uint32_t  gate_error_delay_s1:  3;       /*!< Defines the number of cycles of margin allowed for the finalDQS
                                                         falling edge of a read burst.
                                                         An error will occur if the final DQS is not found
                                                         after DQS_FALLING_EDGE_EXP_DLY
                                                         and before (DQS_FALLING_EDGE_EXP_DLY+ gate_error_delay) cycles.
                                                         If this field is set to a non-zero value and an error occurs,
                                                         the PHY will automatically de-assert (close) the read DQS gate
                                                         and log the error in the dqs_error_out field (bit [24])
                                                         of the den_phy_obs_reg_0_X parameter.
                                                         In the event of an error,
                                                         the user should check the c                                           */
      __IO uint32_t  lpbk_en_s1 :  1;               /*!< Dicide if loopback test is enable
                                                         Controls the internal writemultiplexer                                */
      __IO uint32_t  lpbk_internal_s1:  1;          /*!< Define loopback test is internal or external
                                                         Controls the loopbackread multiplexer.                                */
      __IO uint32_t  Loopback_Control_s1:  2;       /*!< Loopback control
                                                                                                                               */
      __IO uint32_t  lpbk_fail_muxsel_s1:  1;       /*!< Selects the data output type for the lpbk_dq_data (SLICE 1)
                                                         Selects the data output type for the lpbk_dq_data_s0 and lpbk_dm_data_s0
                                                         of the den_phy_obs_reg_0_X parameter.                                 */
      __IO uint32_t  lpbk_err_check_timing_s1:  3;  /*!< Sets the cycle delay between the LFSR and loopback error check
                                                         logic to ensure
                                                         that the LFSR sourced data
                                                         and data being looped back arrive at the same clock cycle for
                                                          comparison.
                                                         This value is related to the rd_dly_sel_s1, and is equal to7.         */
           uint32_t             :  7;
      __IO uint32_t  clk_count_compare_sel_s1:  1;  /*!< Select clock count for posedge or negedge (used for dqs close
                                                         logic)                                                                */
      __IO uint32_t  close_last_sel_s1:  1;         /*!< Select last register for posedge or negedge (used for dqs close
                                                         logic)                                                                */
           uint32_t             :  4;
      __IO uint32_t  enable_half_cas_s1:  1;        /*!< Subtracts 1/2 cycle from the DQS gate value programmed
                                                         into gate_cfg_s1 of this parameter by 1/2 cycle. Default 0x0.
                                                         This is used when the gate is being aligned to the first DQS,
                                                         and then is removed to move the gate back into the center of
                                                         the preamble.
                                                                                                                               */
    };
  };
  __IO uint8_t   rd_dly_sel_s1;                     /*!< 0x9900_024C
                                                         Controls PHY slice 1
                                                         Holds the read delay setting.
                                                         read_delay setting for io_datain FIFO timing.
                                                         Controls the number of cycles to wait to pull data out
                                                         of the read FIFO that has been clocked by the read DQS signal.
                                                         This field should be programmed to the roundedup value
                                                         of the equation ASYNC_DELAY_max/tCK,
                                                         where ASYNC_DELAY_max is the worst case ASYNC_DELAY. * All other
                                                         bits are reserved for future use and must be set to 'b0               */
  __I  uint8_t   RESERVED7[3];
  
  union {
    __IO uint32_t  PHY_DLL_MASTER_CTRL_REG_1;       /*!< 0x9900_0250
                                                         Controls the DLL for slice 1
                                                         There is a phy_dll_master_ctrl_reg_X parameter
                                                         for each ofthe slices of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0.                                                               */
    
    struct {
      __IO uint32_t  param_dll_start_point_s1:  8;  /*!< This value is the initial delay value for the DLL.
                                                         This value is also used as the increment value
                                                         if the initial value is less than a half-clock cycle.
                                                         This field should be set such that
                                                         it is not greater than 7/8ths of a clock period given the worst
                                                         case element delay.
                                                         For example, if the frequency is 400MHz (2.5ns cycle time) with
                                                          a worst case element 80ps delay,
                                                         this this field should be set to = 2.5 * (7/8) / .080 = 27 elements.
                                                         This calculation helps determine the start point which achieves
                                                          the fastes                                                           */
           uint32_t             :  8;
      __IO uint32_t  param_dll_lock_num_s1:  3;     /*!< Holds the number of consecutive increment
                                                         or decrement indications that will trigger an unlock condition
                                                         and increment the dll_unlock_cnt_s1,
                                                         and either the lock_dec_dbg_s1
                                                         or lock_inc_dbg fields_s1 of the phy_dll_obs_reg_0_1 parameter.       */
           uint32_t             :  1;
      __IO uint32_t  param_phase_detect_sel_s1:  3; /*!< DLL Phase Detect Selector to handle the clock domain crossing
                                                         betweenthe clock and clk_wrdqs signal                                 */
      __IO uint32_t  param_dll_bypass_mode_s1:  1;  /*!< Controls the bypass mode of the master and slave DLLs.
                                                         If this bit is set,
                                                         The param_dll_bypass_mode is intended to be used only for debug.      */
    };
  };
  
  union {
    __IO uint16_t  PHY_DLL_SLAVE_CTRL_REG_1;        /*!< 0x9900_0254
                                                         Controls the DLL for slice 1
                                                         There is a phy_dll_slave_ctrl_reg_X parameter
                                                         foreach of the slices of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use
                                                         andmust be set to 'b0.                                                */
    
    struct {
      __IO uint16_t  param_dll_rddqs_delay_s1:  8;  /*!< Dicide delay value for read dqs in DLL,
                                                         If the value is 0x40 means 1/4 cycle of read DQS delay                */
      __IO uint16_t  param_dll_wrdqs_delay_s1:  8;  /*!< Dicide delay value for write dqs in DLL,
                                                         If the value is 0x40 means 1/4 cycle of write DQS delay               */
    };
  };
  __I  uint16_t  RESERVED8;
  
  union {
    __I  uint32_t  DEN_PHY_OBS_REG_0_1;             /*!< 0x9900_0258
                                                         Controls loopback status,
                                                         data andmasking info for slice 0.
                                                         Reports status for the PHY for data slice 0.
                                                         * All other bits are reserved for future use and must be set
                                                         to 'b0. READONLY                                                      */
    
    struct {
      __I  uint32_t  lpbk_start_s1:  1;             /*!< Defines the status of the loopback mode.                              */
      __I  uint32_t  lpbk_status_s1:  1;            /*!< Reports status of loopback errors                                     */
           uint32_t             :  2;
      __I  uint32_t  lpbk_dm_data_s1:  1;           /*!< Reports the actual data mask or the expected data mask,
                                                         depending on the setting of the lpbk_fail_muxsel_s1 field
                                                         of the den_phy_gate_lpbk_ctrl_reg_X parameter.                        */
           uint32_t             :  3;
      __I  uint32_t  lpbk_dq_data_s1: 16;           /*!< Reports the actual data or expected data,
                                                         depending on the setting of the lpbk_fail_muxsel_s1 field
                                                         of the den_phy_gate_lpbk_ctrl_reg_X parameter.
                                                                                                                               */
      __I  uint32_t  dqs_error_out_s1:  1;          /*!< Status signal to indicate that the logic gate had to be forced
                                                         closed.                                                               */
    };
  };
  
  union {
    __I  uint32_t  PHY_DLL_OBS_REG_0_1;             /*!< 0x9900_025C
                                                         Reports DLL status for slice 1.
                                                         There is a phy_dll_obs_reg_0_X parameter
                                                         for each of theslices of data sent on the DFI data bus.
                                                         READ-ONLY                                                             */
    
    struct {
      __I  uint32_t  dll_lock_s1:  1;               /*!< Indicates status of the master DLL                                    */
      __I  uint32_t  dll_locked_mode_s1:  2;        /*!< Defines the mode in which the DLL has achieved the lock               */
      __I  uint32_t  dll_unlock_cnt_s1:  5;         /*!< Reports the number of times that the master DLL consecutive
                                                         increment
                                                         or decrement value programmed into the param_dll_lock_num_s1
                                                         of the phy_dll_master_ctrl_reg_X parameter has beentriggered.
                                                          The count will saturate at a value of 0x1f.
                                                         Asserting the dll_rst_n signal will reset this counter to 0.          */
      __I  uint32_t  dll_lock_value_s1:  8;         /*!< Reports the numberof delay elements that the DLL has determined
                                                         for lock
                                                         in either full clock or half clock mode.
                                                         In full clock mode, this value equals the number ofdelay elements
                                                          in one cycle.
                                                         In half clock mode,this value equals the number of delay elements
                                                          in one half clock cycle.
                                                         In saturation mode, this value equals the maximum number of
                                                          delay elements.                                                      */
      __I  uint32_t  lock_dec_dbg_s1:  8;           /*!< Holds the state ofthe cumulative dll_lock_dec register
                                                         when the dll_unlock_cnt_s1 of this parameter was triggered to
                                                         decrement,
                                                         or was lastsaturated at a value of 0x1f                               */
      __I  uint32_t  lock_inc_dbg_s1:  8;           /*!< Holds the state ofthe cumulative dll_lock_inc register
                                                         when the dll_unlock_cnt_s1 of this parameter was triggered to
                                                         increment,
                                                         or was last saturated at a value of 0x1f.                             */
    };
  };
  
  union {
    __I  uint32_t  PHY_DLL_OBS_REG_1_1;             /*!< 0x9900_0260
                                                         Reports DLL status for slice 1.
                                                         There is a phy_dll_obs_reg_1_X parameter for each of the slices
                                                         of data sent on the DFI data bus.
                                                         * All other bits are reserved for future use and must be set
                                                          to 'b0.                                                              */
    
    struct {
      __I  uint32_t  decoder_out_rd_s1:  8;         /*!< Holds the encoded value for the read delay line for this slice.       */
           uint32_t             :  8;
      __I  uint32_t  decoder_out_wr_s1:  8;         /*!< Holds the encoded value for the clk_wr delay line for thisslice.      */
    };
  };
  __I  uint32_t  RESERVED9[39];
  __IO uint8_t   read_data_valid_delay;             /*!< 0x9900_0300
                                                         Number of cycles to delay the dfi_rddata_en signal to produce
                                                         dfi_rddata_valid.
                                                         This field should be programmed to TWO more than the largest
                                                          rd_dly_sel value
                                                         in the den_phy_read_ctrl_reg_X parameters.
                                                         * All other bits are reserved for future use and must be set
                                                          to 'b0.                                                              */
  __I  uint8_t   RESERVED10[7];
  
  union {
    __IO uint32_t  PHY_PAD_DRIVE_REG_0;             /*!< 0x9900_0308
                                                         Controls the pad drive parameters for the DQ, DM and DQS pads.
                                                         Any bits not listed are reserved for future use and must be
                                                         set to 'b0.                                                           */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  data_io_half_drive:  1;        /*!< Decide if half drive is used for data/dm ddr io                       */
           uint32_t             :  2;
      __IO uint32_t  data_io_pwd:  1;               /*!< Decide if the data/dm ddr io is power on                              */
           uint32_t             : 12;
      __IO uint32_t  dqs_io_half_drive:  1;         /*!< Decide if half drive is used for dqs ddr io                           */
           uint32_t             :  2;
      __IO uint32_t  ddr1_dqs_io_pwd:  1;           /*!< Decide if the ddr1 dqs io is power on                                 */
    };
  };
  
  union {
    __IO uint32_t  PHY_PAD_DRIVE_REG_1;             /*!< 0x9900_030C
                                                         Controls the pad drive parameters for the DQ, DM and DQS pads.
                                                         Any bits not listed are reserved for future use and must be
                                                         set to 'b0.                                                           */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  addr_io_half_drive:  1;        /*!< Decide if half drive is used for addr/cmd ddr io                      */
           uint32_t             :  2;
      __IO uint32_t  addr_io_pwd:  1;               /*!< Decide if the addr/cmd ddr io is power on                             */
           uint32_t             : 12;
      __IO uint32_t  ddr_clk_io_half_drive:  1;     /*!< Decide if half drive is used for ddr clk io                           */
           uint32_t             :  2;
      __IO uint32_t  ddr_clk_io_pwd:  1;            /*!< Decide if the ddr clk io is power on                                  */
    };
  };
  
  union {
    __IO uint32_t  PHY_PAD_DRIVE_REG_2;             /*!< 0x9900_0310
                                                         Controls the pad drive parameters for the feedback pads.
                                                         Any bits not listed are reserved for future useand must be set
                                                         to 'b0.                                                               */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  feedback_io_half_drive:  1;    /*!< Decide if half drive is used for feedback ddr io                      */
           uint32_t             :  2;
      __IO uint32_t  feedback_io_pwd:  1;           /*!< Decide if the feedback ddr io is power on                             */
    };
  };
} DDR_PHY_Type;


/* ================================================================================ */
/* ================                     CQ_RAM                     ================ */
/* ================================================================================ */


/**
  * @brief Memory space for Command Queue (8KBytes) (CQ_RAM)
  */

typedef struct {                                    /*!< CQ_RAM Structure                                                      */
  __IO uint32_t  RAM0;                              /*!< CQ RAM 0 (Unit: 2KB)                                                  */
  __I  uint32_t  RESERVED[511];
  __IO uint32_t  RAM1;                              /*!< CQ RAM 1 (Unit: 2KB)                                                  */
  __I  uint32_t  RESERVED1[511];
  __IO uint32_t  RAM2;                              /*!< CQ RAM 2 (Unit: 2KB)                                                  */
  __I  uint32_t  RESERVED2[511];
  __IO uint32_t  RAM3;                              /*!< CQ RAM 3 (Unit: 2KB)                                                  */
} CQ_RAM_Type;


/* ================================================================================ */
/* ================                      CQ_1                      ================ */
/* ================================================================================ */


/**
  * @brief Command Queue (CQ_1)
  */

typedef struct {                                    /*!< CQ_1 Structure                                                        */
  __IO uint32_t  CMD_START_ADDR;                    /*!< For Write: The SRAM Start address for CQ.
                                                         For Read: The SRAM Current Read address for CQ.                       */
  __IO uint32_t  CMD_END_ADDR;                      /*!< The SRAM End address for CQ.                                          */
  __I  uint32_t  RESERVED;
  __IO uint32_t  CMD_EN;                            /*!< 1: Enable the CQ Function                                             */
  __I  uint32_t  RESERVED1;
  
  union {
    __IO uint32_t  CMD_CONTROL;                     /*!< CQ Control Register                                                   */
    
    struct {
      __I  uint32_t  CMD_RDY    :  1;               /*!< 1: Means the CQ HW is ready or SRAM Address is reach the CMD_END_ADDR. */
      __I  uint32_t  CMD_INT    :  1;               /*!< 1: The interrupt signal for CQ                                        */
      __I  uint32_t  CMD_HMI_ERR:  1;               /*!< 1: The AHB2.0 has occured ERROR response to CQ HW.                    */
      __I  uint32_t  CMD_NO_ERR :  1;               /*!< 1: The CMD_NO is error (CMD_NO is only <12, if CMD_NO >=12,
                                                         the CMD_NO_ERR will be set to 1.                                      */
           uint32_t             :  4;
      __O  uint32_t  CLR_CMD_INT:  1;               /*!< Write 1 to clear CMD_INT to 0.                                        */
      __O  uint32_t  CLR_CMD_HMI_ERR:  1;           /*!< Write 1 to clear CMD_HMI_ERR to 0.                                    */
      __O  uint32_t  CLR_CMD_NO_ERR:  1;            /*!< Write 1 to clear CMD_NO_ERR to 0.                                     */
    };
  };
  __IO uint32_t  CMD_POLLING_PERIOD_UNIT;           /*!< The time interval between every Read Data Command for Read-Bit
                                                         Polling Command.                                                      */
} CQ_1_Type;


/* --------------------  End of section using anonymous unions  ------------------- */
#if defined(__CC_ARM)
  #pragma pop
#elif defined(__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning restore
#else
  #warning Not supported compiler type
#endif




/* ================================================================================ */
/* ================              Peripheral memory map             ================ */
/* ================================================================================ */

#define GLB_BASE                        0x90000000UL
#define SARAD_BASE                      0x90020000UL
#define RTC_BASE                        0x90030000UL
#define MC_BASE                         0x90040000UL
#define USB_PHY1_BASE                   0x90050000UL
#define USB_PHY2_BASE                   0x90060000UL
#define EFUSE_BASE                      0x90100000UL
#define RF_CTRL1_BASE                   0x90110000UL
#define RF_CTRL2_BASE                   0x90120000UL
#define SF_BASE                         0x90300000UL
#define SDIO_WIFI_BASE                  0x90310000UL
#define SDIO_1_BASE                     0x90320000UL
#define SDIO_2_BASE                     0x90330000UL
#define CRC_BASE                        0x90340000UL
#define ENC_DMA_BASE                    0x90350000UL
#define PWM_BASE                        0x90400000UL
#define AHB1_BASE                       0x91000000UL
#define ADO_BASE                        0x91100000UL
#define SDADC_BASE                      0x91100350UL
#define DMA_BASE                        0x91200000UL
#define APBC_BASE                       0x91300000UL
#define FAT_BASE                        0x91400000UL
#define SSP_BASE                        0x92000000UL
#define UART1_BASE                      0x92100000UL
#define UART2_BASE                      0x92200000UL
#define INTC_BASE                       0x92300000UL
#define I2C1_BASE                       0x92400000UL
#define I2C2_BASE                       0x92500000UL
#define WDRT_BASE                       0x92900000UL
#define WDIT_BASE                       0x92A00000UL
#define GPIO_BASE                       0x92B00000UL
#define Timer1_BASE                     0x92C00000UL
#define Timer2_BASE                     0x92D00000UL
#define Timer3_BASE                     0x92E00000UL
#define AHB2_BASE                       0x93000000UL
#define AHB3_BASE                       0x94000000UL
#define JPEG_BASE                       0x94100000UL
#define EHCI_1_BASE                     0x94200000UL
#define EHCI_2_BASE                     0x94300000UL
#define USBD_BASE                       0x94400000UL
#define IMG_BASE                        0x95000000UL
#define H264_BASE                       0x96000000UL
#define H264_Dec_BASE                   0x96000000UL
#define SEN_BASE                        0x97000000UL
#define MIPI_BASE                       0x97001800UL
#define LCD_BASE                        0x98000000UL
#define DDR_BASE                        0x99000000UL
#define DDR_PHY_BASE                    0x99000200UL
#define CQ_RAM_BASE                     0x9A000000UL
#define CQ_1_BASE                       0x9A010000UL
#define CQ_2_BASE                       0x9A010020UL
#define CQ_3_BASE                       0x9A010040UL
#define CQ_4_BASE                       0x9A010060UL


/* ================================================================================ */
/* ================             Peripheral declaration             ================ */
/* ================================================================================ */

#define GLB                             ((GLB_Type                *) GLB_BASE)
#define SARAD                           ((SARAD_Type              *) SARAD_BASE)
#define RTC                             ((RTC_Type                *) RTC_BASE)
#define MC                              ((MC_Type                 *) MC_BASE)
#define USB_PHY1                        ((USB_PHY1_Type           *) USB_PHY1_BASE)
#define USB_PHY2                        ((USB_PHY2_Type           *) USB_PHY2_BASE)
#define EFUSE                           ((EFUSE_Type              *) EFUSE_BASE)
#define RF_CTRL1                        ((RF_CTRL1_Type           *) RF_CTRL1_BASE)
#define RF_CTRL2                        ((RF_CTRL1_Type           *) RF_CTRL2_BASE)
#define SF                              ((SF_Type                 *) SF_BASE)
#define SDIO_WIFI                       ((SDIO_WIFI_Type          *) SDIO_WIFI_BASE)
#define SDIO_1                          ((SDIO_WIFI_Type          *) SDIO_1_BASE)
#define SDIO_2                          ((SDIO_WIFI_Type          *) SDIO_2_BASE)
#define CRC                             ((CRC_Type                *) CRC_BASE)
#define ENC_DMA                         ((ENC_DMA_Type            *) ENC_DMA_BASE)
#define PWM                             ((PWM_Type                *) PWM_BASE)
#define AHB1                            ((AHB1_Type               *) AHB1_BASE)
#define ADO                             ((ADO_Type                *) ADO_BASE)
#define SDADC                           ((SDADC_Type              *) SDADC_BASE)
#define DMA                             ((DMA_Type                *) DMA_BASE)
#define APBC                            ((APBC_Type               *) APBC_BASE)
#define FAT                             ((FAT_Type                *) FAT_BASE)
#define SSP                             ((SSP_Type                *) SSP_BASE)
#define UART1                           ((UART1_Type              *) UART1_BASE)
#define UART2                           ((UART1_Type              *) UART2_BASE)
#define INTC                            ((INTC_Type               *) INTC_BASE)
#define I2C1                            ((I2C1_Type               *) I2C1_BASE)
#define I2C2                            ((I2C1_Type               *) I2C2_BASE)
#define WDRT                            ((WDRT_Type               *) WDRT_BASE)
#define WDIT                            ((WDRT_Type               *) WDIT_BASE)
#define GPIO                            ((GPIO_Type               *) GPIO_BASE)
#define Timer1                          ((Timer1_Type             *) Timer1_BASE)
#define Timer2                          ((Timer1_Type             *) Timer2_BASE)
#define Timer3                          ((Timer1_Type             *) Timer3_BASE)
#define AHB2                            ((AHB2_Type               *) AHB2_BASE)
#define AHB3                            ((AHB3_Type               *) AHB3_BASE)
#define JPEG                            ((JPEG_Type               *) JPEG_BASE)
#define EHCI_1                          ((EHCI_1_Type             *) EHCI_1_BASE)
#define EHCI_2                          ((EHCI_1_Type             *) EHCI_2_BASE)
#define USBD                            ((USBD_Type               *) USBD_BASE)
#define IMG                             ((IMG_Type                *) IMG_BASE)
#define H264                            ((H264_Type               *) H264_BASE)
#define H264_Dec                        ((H264_Dec_Type           *) H264_Dec_BASE)
#define SEN                             ((SEN_Type                *) SEN_BASE)
#define MIPI                            ((MIPI_Type               *) MIPI_BASE)
#define LCD                             ((LCD_Type                *) LCD_BASE)
#define DDR                             ((DDR_Type                *) DDR_BASE)
#define DDR_PHY                         ((DDR_PHY_Type            *) DDR_PHY_BASE)
#define CQ_RAM                          ((CQ_RAM_Type             *) CQ_RAM_BASE)
#define CQ_1                            ((CQ_1_Type               *) CQ_1_BASE)
#define CQ_2                            ((CQ_1_Type               *) CQ_2_BASE)
#define CQ_3                            ((CQ_1_Type               *) CQ_3_BASE)
#define CQ_4                            ((CQ_1_Type               *) CQ_4_BASE)


/** @} */ /* End of group Device_Peripheral_Registers */
/** @} */ /* End of group _510PF */
/** @} */ /* End of group SONiX Technology Co., Ltd. */

#ifdef __cplusplus
}
#endif


#endif  /* _510PF_H */

